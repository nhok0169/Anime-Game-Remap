
#
# ===== Note =====
#
# This script was auto-generated by AG Remap's ScriptBuilder tool,
#   a build system tool used in AG Remap's CI pipeline that transforms the API source code
#   into a single script
#
# For more info, check out the Github to ScriptBuilder at:
# https://github.com/nhok0169/Anime-Game-Remap/tree/nhok0169/Tools/ScriptBuilder
#
# ***** ScriptBuilder Stats *****
#
# Version: 1.0.0
# Authors: Albert Gold#2696
# Datetime Ran: Friday, December 06, 2024 02:13:05.216 AM UTC
# Run Hash: d7468051-ef67-43df-a337-a3633dd6b2ef
# 
# *******************************
# ================
# 
# ########## START OF AUTO-GENERATED SCRIPT ##########


# ===== Anime Game Remap (AG Remap) =====
# Authors: NK#1321, Albert Gold#2696
#
# if you used it to remap your mods pls give credit for "Nhok0169" and "Albert Gold#2696"
# Special Thanks:
#   nguen#2011 (for support)
#   SilentNightSound#7430 (for internal knowdege so wrote the blendCorrection code)
#   HazrateGolabi#1364 (for being awesome, and improving the code)
#
# ***** AG Remap Script Stats *****
#
# Version: 4.1.1
# Authors: NK#1321, Albert Gold#2696
# Datetime Compiled: Friday, December 06, 2024 02:13:05.216 AM UTC
# Build Hash: 6c9a678e-ffdc-4b29-a14c-f28dc940a5eb
#
# *********************************
#


import os, argparse, copy, shutil, ntpath, re, uuid, pip._internal as pip, importlib, math, traceback, struct, configparser

from enum import Enum
from typing import Set, Union, Optional, Callable, List, TYPE_CHECKING, TypeVar, Dict, Tuple, Generic, Any, Hashable, Type, DefaultDict
from collections import defaultdict, OrderedDict, deque
from functools import cmp_to_key
from types import ModuleType



# change our current working directory to this file, allowing users to run program
#   by clicking on the script instead of running by CLI
if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.abspath(__file__)))


# CommandFormatter: Text formatting for the help page of the command 
class CommandFormatter(argparse.MetavarTypeHelpFormatter, argparse.RawTextHelpFormatter):
    pass


class CommandOpts(Enum):
    Src = "--src"
    DeleteBackup = '--deleteBackup'
    FixOnly = '--fixOnly'
    Revert = '--undo'
    All = '--all'
    Types = "--types"
    FixedTypes = "--remappedTypes"
    Version = "--version"
    Log = "--log"
    DefaultType = "--defaultType"


class ShortCommandOpts(Enum):
    Src = "-s"
    DeleteBackup = '-d'
    FixOnly = '-f'
    Revert = '-u'
    All = '-a'
    Types = "-t"
    FixedTypes = "-rt"
    Version = "-v"
    Log = "-l"
    DefaultType = "-dt"


class FileExt(Enum):
    """
    Different file extensions for files
    """

    Ini = ".ini"
    """
    Initialization file extension
    """

    Txt = ".txt"
    """
    Text file extension
    """

    Buf = ".buf"
    """
    Buffer file extension    
    """

    DDS = ".dds"
    """
    `Direct Draw Surface`_ file extension
    """


class FileTypes(Enum):
    """
    Different types of files the software encounters
    """

    Default = "file"
    """
    Default file type
    """

    Ini = f"*{FileExt.Ini.value} file"
    """
    Initialization files
    """

    Blend = f"Blend{FileExt.Buf.value}"
    """
    Blend.buf files
    """

    Texture = f"*{FileExt.DDS.value}"
    """
    Texture .dds files
    """

    RemapBlend = f"Remap{Blend}"
    """
    RemapBlend.buf files    
    """

    Log = f"RemapFixLog{FileExt.Txt.value}"
    """
    Log file
    """

    RemapTexture = f"RemapTex{FileExt.DDS.value}"
    """
    RemapTex.dds files
    """


# CommandBuilder: Class for building the command
class CommandBuilder():
    def __init__(self):
        self._argParser = argparse.ArgumentParser(description='Ports mods from characters onto their skin counterparts', formatter_class=CommandFormatter)
        self._addArguments()
        self._args = argparse.Namespace()


    def parse(self) -> argparse.Namespace:
        self._args = self._argParser.parse_args()
        self.parseArgs()
        return self._args

    def parseArgs(self):
        if (self._args.types is not None):
            self._args.types = self._args.types.split(",")

        if (self._args.remappedTypes is not None):
            self._args.remappedTypes = self._args.remappedTypes.split(",")

    def _addArguments(self):
        self._argParser.add_argument(ShortCommandOpts.Src.value, CommandOpts.Src.value, action='store', type=str, help="The starting path to run this fix. If this option is not specified, then will run the fix from the current directory.")
        self._argParser.add_argument(ShortCommandOpts.Version.value, CommandOpts.Version.value, action='store', type=str, help="The game version we want the fix to be compatible with. If this option is not specified, then will use the latest game version")
        self._argParser.add_argument(ShortCommandOpts.DeleteBackup.value, CommandOpts.DeleteBackup.value, action='store_true', help=f'deletes backup copies of the original {FileExt.Ini.value} files')
        self._argParser.add_argument(ShortCommandOpts.FixOnly.value, CommandOpts.FixOnly.value, action='store_true', help='only fixes the mod without cleaning any previous runs of the script')
        self._argParser.add_argument(ShortCommandOpts.Revert.value, CommandOpts.Revert.value, action='store_true', help='Undo the previous runs of the script')
        self._argParser.add_argument(ShortCommandOpts.Log.value, CommandOpts.Log.value, action='store', type=str, help=f'The folder location to log the printed out text into a seperate {FileExt.Txt.value} file. If this option is not specified, then will not log the printed out text.')
        self._argParser.add_argument(ShortCommandOpts.All.value, CommandOpts.All.value, action='store_true', help=f'Parses all {FileTypes.Ini.value}s that the program encounters. This option supersedes the {CommandOpts.Types.value} option')
        self._argParser.add_argument(ShortCommandOpts.DefaultType.value, CommandOpts.DefaultType.value, action='store', type=str, help=f'''The default mod type to use if the {FileTypes.Ini.value} belongs to some unknown mod
If the {CommandOpts.All.value} is set to True, then this argument will be 'raiden'.
Otherwise, if this value is not specified, then any mods with unknown types will be skipped

See below for the different names/aliases of the supported types of mods.''')

        self._argParser.add_argument('-t', CommandOpts.Types.value, action='store', type=str, help=f'''Parses {FileTypes.Ini.value}s that the program encounters for only specific types of mods. If the {CommandOpts.Types.value} option has been specified, this option has no effect. 
By default, if this option is not specified, will parse the {FileTypes.Ini.value}s for all the supported types of mods. 

Please specify the types of mods using the the mod type's name or alias, then seperate each name/alias with a comma(,)
eg. raiden,arlecchino,ayaya

See below for the different names/aliases of the supported types of mods.''')

        self._argParser.add_argument(ShortCommandOpts.FixedTypes.value, CommandOpts.FixedTypes.value, action='store', type=str, help=f"""From all the mods to fix, specified by the {CommandOpts.Types.value} option, will specifically remap those mods to the mods specified by this option. 
For a mod specified by the {CommandOpts.Types.value} option, if none of its corresponding remapped mods are specified by this option, then the mod specified by the {CommandOpts.Types.value} option will be remapped to all its corresponding mods.
 
-------------------
eg.

If this program was ran with the following options:
{CommandOpts.Types.value} kequeen,jean
{CommandOpts.FixedTypes.value} jeanSea

the program will do the following remap:
keqing --> keqingOpulent
Jean --> JeanSea

Note that Jean will not remap to JeanCN
-------------------


By default, if this option is not specified, will remap all the mods specified in {CommandOpts.Types.value} to their corresponding remapped mods. 

Please specify the types of mods using the the mod type's name or alias, then seperate each name/alias with a comma(,)
eg. raiden,arlecchino,ayaya

See below for the different names/aliases of the supported types of mods.""")

    def addEpilog(self, epilog: str):
        self._argParser.epilog = epilog


T = TypeVar('T')
N = TypeVar('N')
Pattern = TypeVar('Pattern')
TextIoWrapper = TypeVar('TextIoWrapper')
BuildCls = TypeVar("BuildCls")
Image = TypeVar("PIL.Image")


HashData = HashData = {4.0 : {"Amber": {"draw_vb": "870a7499", "position_vb": "caddc4c6", "blend_vb": "ca5bd26e", "texcoord_vb": "e3047676", "ib": "9976d124",
                 "tex_head_diffuse": "ae27902d", "tex_head_lightmap": "29b001ba", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "bc86882f", "tex_body_lightmap": "9e1294dd", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "1d064079", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "AmberCN": {"draw_vb": "da0adf2f", "position_vb": "7f94e8da", "blend_vb": "f35340d5", "texcoord_vb": "dbc594b6", "ib": "8cc9274b",
                    "tex_head_diffuse": "ae27902d", "tex_head_lightmap": "29b001ba", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "f683bcac", "tex_body_lightmap": "69b6e698", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "1d064079", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "Barbara": {"draw_vb": "f41c47cf", "position_vb": "85282151", "blend_vb": "22a31278", "texcoord_vb": "0f18519e", "ib": "231723d2",
                    "tex_head_diffuse": "d9d24fbf", "tex_head_lightmap": "f89f1ed6", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "d5fd9da6", "tex_body_lightmap": "0c0ce0ef", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_dress_diffuse": "d5fd9da6", "tex_dress_lightmap": "0c0ce0ef", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "d9f80241", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "BarbaraSummertime": {"draw_vb": "60fcbabe", "position_vb": "8b9e7c22", "blend_vb": "639d62b6", "texcoord_vb": "27057f58", "ib": "a411cfbc",
                    "tex_head_diffuse": "fa94dcc6", "tex_head_lightmap": "07b96e90", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "fa78e66c", "tex_body_lightmap": "a8eec489", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_dress_diffuse": "fa78e66c", "tex_dress_lightmap": "a8eec489", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "72a0dee8", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "Fischl": {"draw_vb": "6c491d3b", "position_vb": "9838aedf", "blend_vb": "0d1c1932", "texcoord_vb": "d451d8d8", "ib": "5cfc7a92",
                   "tex_head_diffuse": "8b7f4637", "tex_head_lightmap": "3b8e30d7", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "9f758879", "tex_body_lightmap": "3c5e7327", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "59cd2559",
                   "tex_dress_diffuse": "9f758879", "tex_dress_lightmap": "3c5e7327", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "0cd456af", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398"},
        "FischlHighness": {"draw_vb": "3cc8f82b", "position_vb": "8f473224", "blend_vb": "dbd6a5c3", "texcoord_vb": "a800a294", "ib": "95bf8d7e",
                   "tex_head_diffuse": "de37696a", "tex_head_lightmap": "2f2f6932", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "a132243b", "tex_body_lightmap": "61c02f66", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "0cd456af", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "Ganyu": {"draw_vb": "721ca964", "position_vb": "a5169f1d", "blend_vb": "6f47a39d", "texcoord_vb": "cf27251f", "ib": "2da186bc",
                  "tex_head_diffuse": "6d78ac96", "tex_head_lightmap": "9b0d2126", "tex_head_shadowramp": "7eb5b84e",
                  "tex_body_diffuse": "8a151913", "tex_body_lightmap": "dbcf1d72", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                  "tex_dress_diffuse": "8a151913", "tex_dress_lightmap": "dbcf1d72", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                  "tex_face_diffuse": "b2657593", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "Jean": {"draw_vb": "e6055135", "position_vb": "191af650", "blend_vb": "3cb8153c", "texcoord_vb": "1722136c", "ib": "29835d20",
                 "tex_head_diffuse": "dba2791d", "tex_head_lightmap": "0bd77e81", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "d1ae8efe", "tex_body_lightmap": "cee17ba5", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "c2d1a57e", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "JeanCN": {"draw_vb": "2a29e333", "position_vb": "93bb2522", "blend_vb": "d159bf31", "texcoord_vb": "0ffefb98", "ib": "920c0b3f",
                   "tex_head_diffuse": "6eca0f93", "tex_head_lightmap": "92ed604c", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "0f9c7705", "tex_body_lightmap": "617c45a0", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "c2d1a57e", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "JeanSea": {"draw_vb": "972d56ee", "position_vb": "16fef1eb", "blend_vb": "ac801371", "texcoord_vb": "3ffb0363", "ib": "5114a891",
                   "tex_head_diffuse": "3b4efe72", "tex_head_lightmap": "4b8a3da9", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "e555db10", "tex_body_lightmap": "15671abb", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "e555db10", "tex_dress_lightmap": "15671abb", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "c2d1a57e", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "Keqing": {"draw_vb": "4526145e", "position_vb": "3aaf3e94", "blend_vb": "0bf8e621", "texcoord_vb": "723848fe", "ib": "f325e394",
                   "tex_head_diffuse": "58de714b", "tex_head_lightmap": "da3e4a28", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "874b8c0b", "tex_body_lightmap": "0695efb7", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "874b8c0b", "tex_dress_lightmap": "0695efb7", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "d8c9c399", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "KeqingOpulent": {"draw_vb": "efcc8769", "position_vb": "0d7e3cc5", "blend_vb": "6f010b58", "texcoord_vb": "52f78cb7", "ib": "44bba21c",
                   "tex_head_diffuse": "e2d7ae66", "tex_head_lightmap": "13e2b0ab", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "2af5bf71", "tex_body_lightmap": "195af53a", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "c2b17f84", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_shadowramp": "7eb5b84e"},
        "Kirara": {"draw_vb": "e656b9fd", "position_vb": "cc833025", "blend_vb": "01d54938", "texcoord_vb": "33b3d6e5", "ib": "ce3dc5a2",
                   "tex_head_normalmap": "6006d89d", "tex_head_diffuse": "0998fcda", "tex_head_lightmap": "c90298cc", "tex_head_metalmap": "b0e08915",
                   "tex_body_normalmap": "acf97111", "tex_body_diffuse": "9feba8b9", "tex_body_lightmap": "2fadf527", "tex_body_metalmap": "b0e08915",
                   "tex_dress_normalmap": "acf97111", "tex_dress_diffuse": "9feba8b9", "tex_dress_lightmap": "2fadf527", "tex_dress_metalmap": "b0e08915",
                   "tex_face_normalmap": "6eb20522", "tex_face_diffuse": "4e3376db", "tex_face_lightmap": "30180763"},
        "Mona": {"draw_vb": "00741928", "position_vb": "20d0bfab", "blend_vb": "52f0e9a0", "texcoord_vb": "a8191396", "ib": "ef876207",
                 "tex_head_diffuse": "b518c5a5", "tex_head_lightmap": "0c679d22", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                 "tex_body_diffuse": "5f873d89", "tex_body_lightmap": "29d50a21", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                 "tex_face_diffuse": "8e116301", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "MonaCN": {"draw_vb": "41f18240", "position_vb": "ee5ed1dc", "blend_vb": "bad2731b", "texcoord_vb": "e543af5d", "ib": "ed79ea5b",
                   "tex_head_diffuse": "0320a4d2", "tex_head_lightmap": "df0f8b90", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "c043f913", "tex_body_lightmap": "a3369d08", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "8e116301", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "Nilou":  {"draw_vb": "2f95abf6", "position_vb": "b2acc1df", "blend_vb": "fda8e783", "texcoord_vb": "583fba29", "ib": "265e34e3",
                   "tex_head_normalmap": "6f0680d3", "tex_head_diffuse": "9caa70ad", "tex_head_lightmap": "b2501b97", "tex_head_metalmap": "b0e08915",
                   "tex_body_normalmap": "a87ce1c0", "tex_body_diffuse": "91cb97a8", "tex_body_lightmap": "29cf0914", "tex_body_metalmap": "b0e08915",
                   "tex_dress_normalmap": "a87ce1c0", "tex_dress_diffuse": "91cb97a8", "tex_dress_lightmap": "29cf09   14", "tex_dress_metalmap": "b0e08915",
                   "tex_face_diffuse": "0957b10f", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "3f396398", "tex_face_metalmap": "b0e08915"},
        "Ningguang": {"draw_vb": "e4fc5902", "position_vb": "55b43e99", "blend_vb": "9f7dc19c", "texcoord_vb": "906ad233", "ib": "93085db7",
                   "tex_head_diffuse": "e0789f0d", "tex_head_lightmap": "5d182ae7", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "5ffe95c2", "tex_body_lightmap": "64e6b893", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "5ffe95c2", "tex_dress_lightmap": "64e6b893", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "4cc85338", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "NingguangOrchid": {"draw_vb": "10de9c78", "position_vb": "db37b198", "blend_vb": "a8246d4a", "texcoord_vb": "396aa3ec", "ib": "f1d09b47",
                   "tex_head_diffuse": "b68d7488", "tex_head_lightmap": "bc1034dd", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "a4597b85", "tex_body_lightmap": "0e26784e", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "a4597b85", "tex_dress_lightmap": "0e26784e", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "4cc85338", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "Raiden": {"draw_vb": "a05e7bec", "position_vb": "e48c61f3", "blend_vb": "1a495487", "texcoord_vb": "0c37fc86", "ib": "428c56cd"},
        "RaidenBoss": {"blend_vb": "fe5c0180"},
        "Rosaria": {"draw_vb": "9e1868d9", "position_vb": "748f40a5", "blend_vb": "4de959bd", "texcoord_vb": "06b8fbf5", "ib": "5d18b9d6",
                    "tex_head_diffuse": "81b2d0ca", "tex_head_lightmap": "2f19c547", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                    "tex_body_diffuse": "9abde85f", "tex_body_lightmap": "743ffc09", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                    "tex_dress_diffuse": "81b2d0ca", "tex_dress_lightmap": "2f19c547", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                    "tex_extra_diffuse": "9abde85f", "tex_extra_lightmap": "743ffc09", "tex_extra_metalmap": "b0e08915", "tex_extra_shadowramp": "7eb5b84e",
                    "tex_face_diffuse": "2abd61ee", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "RosariaCN": {"draw_vb": "f3d4a01a", "position_vb": "59a1f8b1", "blend_vb": "a7bee046", "texcoord_vb": "86e0d16b", "ib": "851e4de1",
                      "tex_head_diffuse": "55280cb0", "tex_head_lightmap": "825c32a0", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                      "tex_body_diffuse": "bd6fcf34", "tex_body_lightmap": "cf7b6deb", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                      "tex_dress_diffuse": "55280cb0", "tex_dress_lightmap": "825c32a0", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                      "tex_extra_diffuse": "bd6fcf34", "tex_extra_lightmap": "cf7b6deb", "tex_extra_metalmap": "b0e08915", "tex_extra_shadowramp": "7eb5b84e",
                      "tex_face_diffuse": "2abd61ee", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"},
        "Shenhe": {"draw_vb": "fde191d7", "position_vb": "e44b58b5", "blend_vb": "541cf273", "texcoord_vb": "86c4f5ec", "ib": "0b7d4e4d",
                   "tex_head_diffuse": "7da9c07b", "tex_head_lightmap": "e134c758", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "7eb5b84e",
                   "tex_body_diffuse": "cba1d6ec", "tex_body_lightmap": "ce5176af", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "7eb5b84e",
                   "tex_dress_diffuse": "cba1d6ec", "tex_dress_lightmap": "ce5176af", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "7eb5b84e",
                   "tex_face_diffuse": "f5f393cb", "tex_face_lightmap": "4e3376db", "tex_face_shadow": "bf9fccca", "tex_face_shadowramp": "7eb5b84e"}},
4.1 : {"Amber": {"draw_vb":"0eef5bbe"},
       "AmberCN": {"draw_vb":"53eff008"},
       "Barbara": {"draw_vb": "7df968e8"},
       "BarbaraSummertime": {"draw_vb": "e9199599"},
       "Fischl": {"draw_vb":"e5ac321c"},
       "FischlHighness": {"draw_vb": "b52dd70c"},
       "Ganyu": {"draw_vb": "fbf98643"},
       "Jean": {"draw_vb":"6fe07e12"},
       "JeanCN": {"draw_vb":"a3cccc14"},
       "JeanSea": {"draw_vb": "1ec879c9"},
       "Keqing": {"draw_vb": "ccc33b79"},
       "KeqingOpulent": {"draw_vb": "6629a84e"},
       "Kirara": {"draw_vb": "6fb396da"},
       "Mona": {"draw_vb":"8991360f"},
       "MonaCN": {"draw_vb":"c814ad67"},
       "Nilou": {"draw_vb": "a67084d1"},
       "Ningguang": {"draw_vb": "6d197625"},
       "NingguangOrchid": {"draw_vb": "993bb35f"},
       "Raiden": {"draw_vb":"29bb54cb"},
       "Rosaria": {"draw_vb":"17fd47fe"},
       "RosariaCN": {"draw_vb":"7a318f3d"},
       "Shenhe": {"draw_vb": "7404bef0"}},
4.3 : {"Amber": {"ib":"a1a2bbfb"},
       "Barbara": {"ib": "1bc3490d"},
       "BarbaraSummertime": {"ib": "9cc5a563"},
       "AmberCN": {"ib":"b41d4d94"},
       "Fischl": {"ib": "6428104d"},
       "FischlHighness": {"ib": "ad6be7a1"},
       "Ganyu": {"ib": "1575ec63"},
       "Jean": {"ib":"115737ff"},
       "JeanCN": {"ib":"aad861e0"},
       "JeanSea": {"ib": "69c0c24e"},
       "Keqing": {"ib": "cbf1894b"},
       "KeqingOpulent": {"ib": "7c6fc8c3"},
       "Kirara": {"ib": "f6e9af7d"},
       "Mona": {"ib":"d75308d8"},
       "MonaCN": {"ib":"d5ad8084"},
       "Nilou": {"ib": "1e8a5e3c"},
       "Ningguang": {"ib": "abdc3768"},
       "NingguangOrchid": {"ib":"c904f198"},
       "Raiden": {"ib":"7a583c12"},
       "Rosaria": {"ib":"65ccd309"},
       "RosariaCN": {"ib":"bdca273e"},
       "Shenhe": {"ib": "33a92492"}},
4.4 : {"Amber": {"position_vb": "a2ea4b2d", "blend_vb": "36d20a67", "texcoord_vb": "81b777ca", "ib": "b03c7e30"},
       "AmberCN": {"position_vb": "557b2eff"},
       "Fischl": {"position_vb": "bf6aef4d"},
       "Mona": {"position_vb": "7a1dc890", "blend_vb": "b043715a"},
       "MonaCN": {"position_vb": "515f3ce6"},
       "Ningguang": {"draw_vb": "4c2f9a0a", "position_vb": "f9e1b52b", "blend_vb": "735eaea4", "texcoord_vb": "1f0ab400", "ib": "ad75352c"},
       "ShenheFrostFlower": {"draw_vb": "6102c3ef", "position_vb": "ee0980eb", "blend_vb": "263019b8", "texcoord_vb": "d36f368d", "ib": "83a9116d",
                             "tex_head_normalmap": "4e5d638d", "tex_head_diffuse": "1ab2f510", "tex_head_lightmap": "b0e08915", "tex_head_shadowramp": "58d2635b",
                             "tex_body_normalmap": "625d0bb4", "tex_body_diffuse": "51529edd", "tex_body_lightmap": "b0e08915", "tex_body_shadowramp": "58d2635b",
                             "tex_dress_normalmap": "4e5d638d", "tex_dress_diffuse": "1ab2f510", "tex_dress_lightmap": "7eb5b84e", "tex_dress_shadowramp": "000050-ps-t3", # is the hash for "tex_dress_shadowramp" even valid? reference: https://github.com/SilentNightSound/GI-Model-Importer-Assets/commit/79d40a4d4708500f44035ade5a6be6c5d6cb0285#diff-2f0914f9ffdcb1e85d8a1e64ba1f12bc7521da3a7f184a2c2eccbaeb702c9290
                             "tex_extra_normalmap": "625d0bb4", "tex_extra_diffuse": "51529edd", "tex_extra_lightmap": "7eb5b84e", "tex_extra_shadowramp": "000049-ps-t3"},
       "GanyuTwilight": {"draw_vb": "1ad9c181", "position_vb": "9b3f356e", "blend_vb": "9a5c01d2", "texcoord_vb": "5ff2f1d1", "ib": "cb283c86",
                         "tex_head_normalmap": "f8aa8a9d", "tex_head_diffuse": "ad1ed796", "tex_head_lightmap": "191ebe05", "tex_head_metalmap": "b0e08915",
                         "tex_body_normalmap": "e304bdcf", "tex_body_diffuse": "13fa0b53", "tex_body_lightmap": "b0e08915", "tex_body_shadowramp": "58d2635b",
                         "tex_dress_normalmap": "e304bdcf", "tex_dress_diffuse": "13fa0b53", "tex_dress_lightmap": "b0e089    15", "tex_dress_shadowramp": "58d2635b"},
       "Kirara": {"position_vb": "b57d7fe2"}},
4.6 : {"Arlecchino" : {"draw_vb": "44e3487a", "position_vb": "6895f405", "blend_vb": "e211de60", "texcoord_vb": "8b17a419", "ib": "e811d2a1"},
       "ArlecchinoBoss": {"draw_vb": "970e7336", "position_vb": "cf66bef6", "blend_vb": "5227c79e", "texcoord_vb": "a75e7052", "ib": "480f1267"}},
4.8 : {"NilouBreeze": {"draw_vb": "3f79fabb", "position_vb": "7d53d78f", "blend_vb": "49bede49", "texcoord_vb": "b976b848", "ib": "00439fbb",
                   "tex_head_diffuse": "2593dea6", "tex_head_lightmap": "3f78afbf", "tex_head_metalmap": "b0e08915", "tex_head_shadowramp": "58d2635b",
                   "tex_body_diffuse": "9f7e392b", "tex_body_lightmap": "e3e73b29", "tex_body_metalmap": "b0e08915", "tex_body_shadowramp": "58d2635b", 
                   "tex_dress_diffuse": "9f7e392b", "tex_dress_lightmap": "e3e73b29", "tex_dress_metalmap": "b0e08915", "tex_dress_shadowramp": "58d2635b"},
        "KiraraBoots": {"draw_vb": "4955fc99", "position_vb": "f8013ba9", "blend_vb": "53a2502b", "texcoord_vb": "596e8fe0", "ib": "846979e2",
                   "tex_head_normalmap": "c715bcf7", "tex_head_diffuse": "16fbe9b0", "tex_head_lightmap": "f74f093d", "tex_head_metalmap": "b0e08915",
                   "tex_body_normalmap": "89a118ba", "tex_body_diffuse": "e3a21e6f", "tex_body_lightmap": "8ca27fd3", "tex_body_metalmap": "b0e08915",
                   "tex_dress_normalmap": "e3a21e6f", "tex_dress_diffuse": "8ca27fd3", "tex_dress_lightmap": "7eb5b84e", "tex_dress_metalmap": "b0e08915"}}}


DefaultCacheSize = 128

class Cache(Generic[T]):
    """
    Class for a generic cache

    .. container:: operations

        **Supported Operations:**

        .. describe:: len(x)

            Retrieves the size of the :class:`Cache`, ``x``

        .. describe:: x[key]

            Retrieves the value from the :class:`Cache`, ``x``, from the key ``key``

        .. describe:: x[key] = newValue

            Sets the key ``key`` of the :class:`Cache`, ``x``, to have the value of ``newValue``

    :raw-html:`<br />`

    Parameters
    ----------
    capacity: :class:`int`
        The maximum capacity of the cache :raw-html:`<br />` :raw-html:`<br />`

        **Default**: 128

    cacheStorage: Optional[Any]
        The type of `KVP`_ (Key-value pair) data structure to use for the cache. If this parameter is ``None``, then will use a dictionary :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    capacity: :class:`int`
        The maximum capacity of the cache

    cacheStorage: Any
        The type of `KVP`_ (Key-value pair) data structure to use for the cache.
    """

    def __init__(self, capacity: int = DefaultCacheSize, cacheStorage: Optional[Any] = None):
        self.capacity = capacity

        if (cacheStorage is None):
            self._cache = {}
        else:
            self._cache = cacheStorage

    def __getitem__(self, key: Hashable) -> Optional[T]:
        return self._cache[key]

    def __setitem__(self, key: Hashable, value: T) -> None:
        self._cache[key] = value

    def __len__(self) -> int:
        return len(self._cache)

    def clear(self) -> None:
        """
        Clears the cache
        """
        self._cache.clear()


class LruCache(Cache):
    """
    This class inherits from :class:`Cache`

    Class for an `LRU cache`_

    .. container:: operations

        **Supported Operations:**

        .. describe:: len(x)

            Retrieves the size of the :class:`LruCache`, ``x``

        .. describe:: x[key]

            Retrieves the value from the :class:`LruCache`, ``x``, from the key ``key``

        .. describe:: x[key] = newValue

            Sets the key ``key`` of the :class:`LruCache`, ``x``, to have the value of ``newValue``

    :raw-html:`<br />`

    Parameters
    ----------
    capacity: :class:`int`
        The maximum capacity of the cache :raw-html:`<br />` :raw-html:`<br />`

        **Default**: 128
    """

    def __init__(self, capacity: int = DefaultCacheSize):
        super().__init__(capacity, OrderedDict())

    def __getitem__(self, key: Hashable) -> Optional[T]:
        if key not in self._cache:
            raise KeyError(f"{key}")

        self._cache.move_to_end(key)
        return self._cache[key]

    def __setitem__(self, key: Hashable, value: T) -> None:
        if len(self._cache) == self.capacity:
            self._cache.popitem(last=False)

        self._cache[key] = value
        self._cache.move_to_end(key)


class Algo():
    """
    Tools for some basic algorithms
    """

    @classmethod
    def _getMid(cls, left, right) -> int:
        return int(left + (right - left) / 2)

    @classmethod
    def binarySearch(cls, lst: List[T], target: T, compare: Callable[[T, T], bool]) -> List[Union[int, bool]]:
        """
        Performs `binary search`_ to search for 'target' in 'lst'

        Parameters
        ----------
        lst: List[T]
            The sorted list we are searching from

        target: T
            The target element to search for in the list

        compare: Callable[[T, T], :class:`bool`]
            The `compare function`_ for comparing elements in the list with the target element

        Returns
        -------
        [:class:`int`, :class:`bool`]
            * The first element is whether the target element is found in the list
            * The second element is the found index or the index that we expect the target element to be in the list
        """

        left = 0
        right = len(lst) - 1
        mid = cls._getMid(left, right)

        while (left <= right):
            midItem = lst[mid]
            compResult = compare(midItem, target)

            if (compResult == 0):
                return [True, mid]
            elif (compResult > 0):
                right = mid - 1
            else:
                left = mid + 1

            mid = cls._getMid(left, right)

        return [False, left]
    
    @classmethod
    def binaryInsert(cls, lst: List[T], target: T, compare: Callable[[T, T], bool], optionalInsert: bool = False) -> bool:
        """
        Insert's 'target' into 'lst' using `binary search`_

        Parameters
        ----------
        lst: List[T]
            The sorted list we want to insert the target element

        target: T
            The target element to insert

        compare: Callable[[T, T], :class:`bool`]
            The `compare function`_ for comparing elements in the list with the target element

        optionalInsert: :class:`bool`
            Whether to still insert the target element into the list if the element target element is found in the list :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`bool`
            Whether the target element has been inserted into the list
        """

        found = False
        inserted = False

        found, insertInd = cls.binarySearch(lst, target, compare)
        if (not optionalInsert or not found):
            lst.insert(insertInd, target)
            inserted = True

        return inserted


class Version():
    """
    Class for handling game versions

    Parameters
    ----------
    versions: Optional[List[float]]
        The versions available

        **Default**: ``None``

    Attributes
    ----------
    _versionCache: :class:`LruCache`
        Cache to store the closest available versions based off the versions that the user searches :raw-html:`<br />` :raw-html:`<br />`

        * The keys in the `LRU cache`_ are the versions the user searches
        * The values in the  `LRU cache`_ are the corresponding versions available to the versions the user searches
    """

    def __init__(self, versions: Optional[List[float]] = None):
        if (versions is None):
            versions = []

        self._latestVersion: Optional[float] = None
        self._versionCache = LruCache()
        self.versions = versions

    @property
    def versions(self):
        """
        The available versions

        :getter: The versions in sorted ascending order
        :setter: Sets the new versions
        :type: List[float]
        """

        return self._versions
    
    @versions.setter
    def versions(self, newVersions: List[float]) -> List[float]:
        self.clear()

        self._versions = list(set(newVersions))
        self._versions.sort()
        if (self._versions):
            self._latestVersion = self._versions[-1]

    @property
    def latestVersion(self) -> Optional[float]:
        """
        The latest version available

        :getter: The latest version
        :type: Optional[float]
        """

        return self._latestVersion

    def clear(self):
        """
        Clears all the version data
        """

        self._versions = []
        self._latestVersion = None
        self._versionCache.clear()
    
    def _updateLatestVersion(self, newVersion: float):
        """
        Updates the latest version

        Parameters
        ----------
        newVersion: :class:`float`
            The new available version
        """

        if (self._latestVersion is None):
            self._latestVersion = newVersion
            return
        
        self._latestVersion = max(self._latestVersion, newVersion)

    def _add(self, newVersion: float):
        if (not self._versions or newVersion > self._versions[-1]):
            self._versions.append(newVersion)
        elif (newVersion < self._versions[0]):
            self._versions.insert(0, newVersion)
        else:
            Algo.binaryInsert(self._versions, newVersion, lambda v1, v2: v1 - v2, optionalInsert = True)

    def add(self, newVersion: float):
        """
        Adds a new version

        Parameters
        ----------
        newVersion: :class:`float`
            The new version to add
        """

        self._add(newVersion)
        self._updateLatestVersion(newVersion)

    def findClosest(self, version: Optional[float], fromCache: float = True) -> Optional[float]:
        """
        Finds the closest version available

        Parameters
        ----------
        version: Optional[:class:`float`]
            The version to be searched :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will assume we want the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fromCache: :class:`float`
            Whether we want the result to be accessed from the cache :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        Optional[:class:`float`]
            The closest version available or ``None`` if there are no versions available
        """

        if (self._latestVersion is None):
            return None

        if (version is None):
            return self._latestVersion

        if (fromCache):
            try:
                return self._versionCache[version]
            except KeyError:
                pass

        found, ind = Algo.binarySearch(self._versions, version, lambda v1, v2: v1 - v2)

        result = 0
        if (found):
            result = self._versions[ind]
        elif (ind > 0):
            result = self._versions[ind - 1]
        else:
            result = self._versions[0]

        self._versionCache[version] = result
        return result


class DictTools():
    """
    Tools for handling with Dictionaries
    """

    @classmethod
    def getFirstKey(cls, dict: Dict[Any, Any]) -> Any:
        """
        Retrieves the first key in a dictionary

        Parameters
        ----------
        dict: Dict[Any, Any]
            The dictionary we are working with

            .. note::
                The dictionary must not be empty

        Returns
        -------
        Any
            The first key of the dictionary
        """

        return next(iter(dict))

    @classmethod
    def getFirstValue(cls, dict: Dict[Any, Any]) -> Any:
        """
        Retrieves the first value in a dictionary

        Parameters
        ----------
        dict: Dict[Any, Any]
            The dictionary we are working with

        Returns
        -------
        Any
            The first value of the dictionary
        """

        return dict[cls.getFirstKey(dict)]
    
    @classmethod
    def update(cls, srcDict: Dict[Hashable, Any], newDict: Dict[Hashable, Any], combineDuplicate: Optional[Callable[[Any, Any], Any]] = None) -> Dict[Hashable, Any]:
        """
        Updates ``srcDict`` based off the new values from ``newDict``

        Parameters
        ----------
        srcDict: Dict[Hashable, Any]
            The dictionary to be updated

        newDict: Dict[Hashable, Any]
            The dictionary to help with updating ``srcDict``

        combineDuplicate: Optional[Callable[[Any, Any], Any]]
            Function for handling cases where there contains the same key in both dictionaries :raw-html:`<br />` :raw-html:`<br />`

            * The first parameter comes from ``srcDict``
            * The second parameter comes from ``newDict``

            If this value is set to ``None``, then will use the key from ``newDict`` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[Hashable, Any]
            Reference to the updated dictionary
        """

        if (combineDuplicate is None):
            srcDict.update(newDict)
            return srcDict
        
        combinedValues = {}
        srcDictLen = len(srcDict)
        newDictLen = len(newDict)
        
        shortDict = srcDict
        longDict = newDict
        if (srcDictLen > newDictLen):
            shortDict = newDict
            longDict = srcDict

        for key in shortDict:
            if (key in longDict):
                combinedValues[key] = combineDuplicate(srcDict[key], newDict[key])

        srcDict.update(newDict)
        srcDict.update(combinedValues)
        return srcDict


    @classmethod
    def combine(cls, dict1: Dict[Hashable, Any], dict2: Dict[Hashable, Any], combineDuplicate: Optional[Callable[[Any, Any], Any]] = None) -> Dict[Hashable, Any]:
        """
        Creates a new dictionary from combining 2 dictionaries

        Parameters
        ----------
        dict1: Dict[Hashable, Any]
            The destination of where we want the combined dictionaries to be stored

        dict2: Dict[Hashable, Any]
            The dictionary we want to combine with

        combineDuplicate: Optional[Callable[[Any, Any], Any]]
            Function for handling cases where there contains the same key in both dictionaries

            If this value is set to ``None``, then will use the key from 'dict2' :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        makeNewCopy: :class:`bool`
            Whether we want the resultant dictionary to be newly created or to be updated into ``dict1``

        Returns
        -------
        Dict[Hashable, Any]
            The new combined dictionary
        """

        new_dict = {**dict1, **dict2}

        if (combineDuplicate is None):
            return new_dict

        for key in new_dict:
            if key in dict1 and key in dict2:
                new_dict[key] = combineDuplicate(new_dict[key], dict1[key])

        return new_dict
    
    @classmethod
    def invert(cls, dict: Dict[Hashable, Hashable]) -> Dict[Hashable, Hashable]:
        """
        Inverts a dictionary by making the keys the values and the values the keys

        Parameters
        ----------
        dict: Dict[Hashable, Hashable]
            The dictionary to invert

        Returns
        -------
        Dict[Hashable, Hashable]
            The inverted dictionary
        """

        return {v: k for k, v in dict.items()}
    
    @classmethod
    def filter(cls, dict: Dict[Hashable, Any], predicate: Callable[[Hashable, Any], bool]) -> Dict[Hashable, Any]:
        """
        Filters a dictionary

        Parameters
        ----------
        dict: Dict[Hashable, Hashable]
            The dictionary to filter

        predicate: Callable[[Hashable, Any], :class:`bool`]
            The predicate used for the filter :raw-html:`<br />` :raw-html:`<br />`

            The predicate has the following parameters

            #. The key of the dictionary
            #. The value of the dictionary

        Returns
        -------
        Dict[Hashable, Any]
            The filtered dictionary
        """

        return {key: value for key, value in dict.items() if predicate(key, value)}
    
    @classmethod
    def _forDict(cls, nestedDict: Dict[Hashable, Any], keyNames: List[str], func: Callable[[Dict[str, str], Dict[str, Any]], Any], currentKeyInd: int, keys: Dict[str, Hashable], values: Dict[str, Hashable]) -> Any:
        keyNamesLen = len(keyNames)
        if (currentKeyInd >= keyNamesLen):
            func(keys, values)
            return

        keyName = keyNames[currentKeyInd]
        for key in nestedDict:
            currentVal = nestedDict[key]
            keys[keyName] = key
            values[keyName] = currentVal
            cls._forDict(currentVal, keyNames, func, currentKeyInd + 1, keys, values)

    @classmethod
    def forDict(cls, nestedDict: Dict[Hashable, Any], keyNames: List[str], func: Callable[[Dict[str, Hashable], Dict[str, Any]], Any]):
        """
        Iterates over a nested dictionary

        Parameters
        ----------
        nestedDict: Dict[Hashable, Any]
            The nested dictionary to iterate over

        keyNames: List[:class:`str`]
            The variable names of the keys in the nested dictionary

        func: Callable[Dict[:class:`str`, Hashable], Dict[:class:`str`, Any], Any]
            callback function that will be called at the leaf node of the nested dictionary :raw-html:`<br />` :raw-html:`<br />`

            The function contains the following arguments:
            #. The dictionary keys encountered in the current iteration
            #. The corresponding values encountered at each dictionary layer in the current iteration
        """

        keys = {}
        values = {}
        cls._forDict(nestedDict, keyNames, func, 0, keys, values)
        


class ModAssets(Generic[T]):
    """
    Class to handle assets of any type for a mod

    .. note::
        This is a `bipartite graph`_ that maps assets to fix from to assets to fix to

    Parameters
    ----------
    repo: Dict[:class:`str`, Dict[:class:`str`, T]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, T]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The inner key is the name of the asset
        * The inner value is the content for the asset
    """

    def __init__(self, repo: Dict[float, Dict[str, T]], map: Optional[Dict[str, Set[str]]] = None):
        self._repo = repo
        self._fixFrom: Set[str] = set()
        self._fixTo: Set[str] = set()
        self._map = map

        if (self._map is None):
            self._map = {}  

        if (self._fixFrom is None):
            self._fixFrom = set()

        if (self._fixTo is None):
            self._fixTo = set()

        self._versions: Dict[str, Version] = {}

    @property
    def versions(self) -> Dict[str, Version]:
        """
        The game versions available for the assets :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the assets
        * The values are versions for the asset

        :getter: Returns all the available game versions for the assets
        :type: Dict[:class:`str`, :class:`Version`]
        """

        return self._versions
    
    @property
    def fixFrom(self) -> Set[str]:
        """
        The names of the assets to fix from using the predefined mods

        :getter: Retrieves the names of assets used to fix from
        :type: Set[:class:`str`]
        """
        
        return self._fixFrom

    @property
    def fixTo(self) -> Set[str]:
        """
        The names of the assets to fix to using the predefined mods

        :getter: Retrives the names of assets to fix to
        :type: Set[:class:`str`]
        """

        return self._fixTo
    
    @property
    def map(self) -> Dict[str, Set[str]]:
        """
        The `adjacency list`_ used to map assets to fix from to assets to fix to

        :getter: Retrieves the `adjacency list`_
        :setter: Sets a new `adjacency list`_
        :type: Dict[:class:`str`, Set[:class:`str`]]
        """

        return self._map
    
    @map.setter
    def map(self, newMap: Dict[str, Set[str]]):
        self.clear(flush = True, clearMap = True)
        self.addMap(newMap)

    def clear(self, flush: bool = True, clearMap: bool = False):
        """
        Clears all the assets

        Parameters
        ----------
        flush: :class:`bool`
            Whether to flush out (reload) any cached data
            
            **Default**: ``False``

        clearMap: :class:`bool`
            Whether to clear out the mapping for the assets 

            **Default**: ``False``
        """

        if (flush):
            self._versions.clear()

        if (clearMap):
            self._fixFrom = set()
            self._fixTo = set()
            self._map = {}

    def loadFromPreset(self):
        """
        Reinitializes to load the predefined mods
        """

        map = self._map
        self.clear(clearMap = True)
        self.map = map

    @classmethod
    def updateMap(cls, srcMap: Dict[str, Set[str]], newMap: Dict[str, Set[str]]) -> Dict[str, Set[str]]:
        """
        Combines 2 maps together

        Parameters
        ----------
        srcMap: Dict[:class:`str`, Set[:class:`str`]]
            The map to be updates

        newMap: Dict[:class:`str`, Set[:class:`str`]]
            The new map to update ``srcMap``

        Returns
        -------
        Dict[:class:`str`, Set[:class:`str`]]
            The updated map
        """

        return DictTools.update(srcMap, newMap, combineDuplicate = lambda oldToAssets, newToAssets: oldToAssets.union(newToAssets))
    

    def _updateAssetContent(self, srcAsset: T, newAsset: T) -> T:
        """
        Combines the content of 2 assets

        Parameters
        ----------
        srcAsset: T
            The content of the asset to be updates

        newAsset: T
            The new asset to update into ``srcAsset`` 

        Returns
        -------
        T
            The updated asset
        """

        pass

    def _updateDupAssets(self, srcAsset: Dict[str, Any], newAsset: Dict[str, Any]):
        return DictTools.update(srcAsset, newAsset, combineDuplicate = self._updateAssetContent)
    
    def updateRepo(self, srcRepo: Dict[float, Dict[str, Any]], newRepo: Dict[float, Dict[str, Any]]) -> Dict[float, Dict[str, Any]]:
        """
        Updates the values in ``srcRepo``

        Parameters
        ----------
        srcRepo: Dict[:class:`float`, Dict[:class:`str`, Any]]
            The first repo to be combined

        newRepo: Dict[:class:`float`, Dict[:class:`str`, Any]]
            The second repo to be combined

        Returns
        -------
        Dict[:class:`float`, Dict[:class:`str`, Any]]
            The combined repo
        """

        result = DictTools.update(srcRepo, newRepo, combineDuplicate = self._updateDupAssets)
        return result

    def _addVersion(self, name: str, version: float):
        """
        Adds a new version for a particular asset

        Parameters
        ----------
        name: :class:`str`
            The name of the asset

        version: :class:`float`
            The game version
        """
        try:
            self._versions[name]
        except KeyError:
            self._versions[name] = Version()

        self._versions[name].add(version)

    def findClosestVersion(self, name: str, version: Optional[float] = None, fromCache: bool = True) -> float:
        """
        Finds the closest available game version from :attr:`ModStrAssets._toAssets` for a particular asset

        Parameters
        ----------
        name: :class:`str`
            The name of the asset to search

        version: Optional[:class:`float`]
            The game version to be searched :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will assume we want the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fromCache: :class:`bool`
            Whether to use the result from the cache

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            The name for the particular asset is not found

        Returns
        -------
        :class:`float`
            The latest game version from the assets that corresponds to the desired version 
        """

        try:
            self._versions[name]
        except KeyError as e:
            raise KeyError(f"Asset name, '{name}', not found in the available versions") from e

        result = self._versions[name].findClosest(version, fromCache = fromCache)
        if (result is None):
            raise KeyError(f"No available versions for the asset by the name, '{name}'")

        return result
        
    def _partition(self, map: Dict[str, Set[str]], assets: Dict[float, Dict[str, Any]]) -> Tuple[Dict[str, Set[str]], Set[str], Set[str]]:
        """
        * Creates the `bipartition`_ for the assets to fix from vs the assets to fix to
        * Filters the mapping such that all the asset names in the new mapping exist in `assets`

        Parameters
        ----------
        map: Dict[:class:`str`, Set[:class:`str`]]
            The desired mapping for the assets for fixing

        assets: Dict[:class:`float`, Dict[:class:`str`, Any]]
            The source for all the assets :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)

        Returns
        -------
        Tuple[Dict[:class:`str`, Set[:class:`str`]], Set[:class:`str`], Set[:class:`str`]]
            The following output is in the same order as listed below: :raw-html:`<br />` :raw-html:`<br />`

            #. The new mapping with all asset names being in `assets`
            #. The names of the assets to fix from
            #. The names of the assets to fix to
        """

        newMap = {}
        fixFrom = set()
        fixTo = set()

        vertices = set()
        visited = {}

        # retrieve all the vertices in the map
        for fromAsset in map:
            vertices.add(fromAsset)
            currentToAssets = map[fromAsset]
            vertices = vertices.union(currentToAssets)

        visited = {}
        for vertex in vertices:
            visited[vertex] = False

        # get all the vertices in the map that are visited in the assets repo
        for version in assets:
            versionAssets = assets[version]

            for assetName in versionAssets:
                if (assetName in vertices and not visited[assetName]):
                    visited[assetName] = True

        # creates the new sub-map and bipartition with vertices definitely being in the assets repo
        for fromAsset in map:
            if (not visited[fromAsset]):
                continue
            
            currentToAssets = map[fromAsset]
            newCurrentToAssets = set(filter(lambda toAsset: visited[toAsset], currentToAssets))

            if (not newCurrentToAssets):
                continue

            newMap[fromAsset] = newCurrentToAssets
            fixFrom.add(fromAsset)
            fixTo = fixTo.union(newCurrentToAssets)

        return (newMap, fixFrom, fixTo)
    
    def _updateVersions(self, assets: Dict[float, Dict[str, T]]):
        """
        Updates the versioning of the assets

        Parameters
        ----------
        assets: T
            The assets for checking the versioning
        """
        pass
    
    def addMap(self, assetMap: Dict[str, Set[str]], assets: Optional[Dict[float, Dict[str, T]]] = None):
        """
        Adds a new map to the existing map on how to retrieve the assets

        Parameters
        ----------
        assetMap: Dict[:class:`str`, Set[:class:`str`]]
            The new `adjacency list`_ used to map assets to fix from to assets to fix to

        assets: Optional[T]
            Any new assets that needs to be added/updated to the existing assets to support the given map

            **Default**: ``None``
        """

        if (assets is None):
            assets = {}

        self._repo = self.updateRepo(self._repo, assets)
        newAddMap, addFixFrom, addFixTo = self._partition(assetMap, self._repo)

        self._repo = self._repo
        if (not addFixFrom or not addFixTo):
            return

        self._map = self.updateMap(self._map, newAddMap)
        self._fixFrom = self._fixFrom.union(addFixFrom)
        self._fixTo = self._fixTo.union(addFixTo)

        # update the versions
        self._updateVersions(assets)


    def addMapping(self, fromAsset: str, toAssets: Set[str], assets: Any):
        """
        Adds a new mapping of how to fix the assets

        Parameters
        ----------
        fromAsset: :class:`str`
            The name of the asset to fix from

        toAssets: Set[:class:`str`]
            The names of the assets to fix to

        assets: Any
            Any new assets that needs to be added/updated to the existing assets to support the new mapping
        """

        map = {fromAsset: toAssets}
        self.addMap(map, assets)


class ModIdAssets(ModAssets[Dict[str, str]]):
    """
    This class inherits from :class:`ModAssets`

    Class to handle hashes, indices, and other string id type assets for a mod

    Parameters
    ----------
    repo: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
        The original source for any preset assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version of the assets
        * The first inner key is the name of the asset
        * The second inner key is the type of asset
        * The most inner value is the id for the asset

        .. note::
            The id value for each asset should be unique

    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, repo: Dict[float, Dict[str, Dict[str, str]]], map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(repo, map = map)

        self._fromAssets: Dict[str, List[Tuple[str, str]]] = {}
        self._toAssets: Dict[float, Dict[str, Dict[str, str]]] = {}
        self.loadFromPreset()

    @property
    def fromAssets(self) -> Dict[str, Tuple[Set[str], str]]:
        """
        The assets to fix from :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the ids for the asset
        * The values contains metadata about the assets to fix to where each tuple contains:

            # The names of the assets
            # The type of asset

        :getter: Returns the assets needed to be fixed
        :type: Dict[:class:`str`, Tuple[Set[:class:`str`], :class:`str`]]
        """

        return self._fromAssets
    
    @property
    def toAssets(self) -> Dict[float, Dict[str, Dict[str, str]]]:
        """
        The assets to fix to: :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the game version number for the assets
        * The first inner key is the name of the assets
        * The most inner key is the type of asset
        * The most inner value is the id for the asset

        :getter: Returns the new assets that will replace the old assets
        :type: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
        """
        return self._toAssets

    def clear(self, flush: bool = True, clearMap: bool = False):
        self._fromAssets = {}
        self._toAssets = {}
        super().clear(flush = flush, clearMap = clearMap)

    def loadFromPreset(self):
        super().loadFromPreset()
        self._loadFromAssets()
        self._loadToAssets()

    def get(self, assetName: str, assetType: str, version: Optional[float] = None) -> str:
        """
        Retrieves the corresponding id asset from :attr:`ModStrAssets._toAssets`

        Parameters
        ----------
        assetName: :class:`str`
            The name of the assets we want

        assetType: :class:`str`
            The name of the type of asset we want.

        version: Optional[:class:`float`]
            The game version we want the asset to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            If the corresponding asset based on the search parameters is not found
            
        Returns
        -------
        :class:`str`
            The found asset
        """

        closestVersion = self.findClosestVersion(assetName, version = version)
        assets = self._toAssets[closestVersion]
        return assets[assetName][assetType]
    
    def replace(self, fromAsset: str, version: Optional[float] = None, toAssets: Optional[Union[str, Set[str]]] = None) -> Union[Optional[str], Dict[str, str]]:
        """
        Retrieves the corresponding asset to replace 'fromAsset'

        Parameters
        ----------
        fromAsset: :class:`str`
            The asset to be replaced

        version: Optional[:class:`float`]
            The game version we want the asset to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        toAssets: Optional[Union[:class:`str`, Set[:class:`str`]]]
            The assets to used for replacement

        Returns
        -------
        Union[:class:`str`, Dict[:class:`str`, :class:`str`]]
            The corresponding assets for the fix to replace, if available :raw-html:`<br />` :raw-html:`<br />`

            The result is a string if the passed in parameter 'toAssets' is also a string :raw-html:`<br />` :raw-html:`<br />`
            
            Otherwise, the result is a dictionary such that: :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the names of the assets
            * The values are the corresponding asset ids to replace
        """

        if (fromAsset not in self._fromAssets):
            if (isinstance(toAssets, str)):
                return None
            else:
                return {}

        toAssetMetadata = self._fromAssets[fromAsset]
        toAssetType = toAssetMetadata[1]
        toAssetNames = toAssetMetadata[0]

        resultAsStr = False
        if (toAssets is not None and isinstance(toAssets, str)):
            toAssetNames = {toAssets}
            resultAsStr = True
        elif (toAssets is not None and toAssets):
            toAssetNames = toAssetNames.intersection(toAssets)

        result = {}
        for toAssetName in toAssetNames:
            try:
                currentReplacement = self.get(toAssetName, toAssetType, version = version)
            except KeyError:
                continue
            else:
                result[toAssetName] = currentReplacement

        if (not resultAsStr):
            return result
        
        try:
            return result[toAssets]
        except KeyError:
            return None
    
    def _loadFromAssets(self):
        self._fromAssets = self._getFromAssets(self._map, self._repo)  

    def _loadToAssets(self):
        self._toAssets = self._getToAssets(self._fixTo, self._repo)
        
    def _updateAssetContent(self, srcAsset: Dict[str, str], newAsset: Dict[str, str]) -> Dict[str, str]:
        return DictTools.update(srcAsset, newAsset)

    def _getAssetChanges(self, oldAssets: Dict[float, Dict[str, Dict[str, str]]], newAssets: Dict[float, Dict[str, Dict[str, str]]]) -> Tuple[Dict[str, str], Dict[float, Dict[str, Dict[str, str]]], Dict[float, Dict[str, Dict[str, str]]]]:
        assetsToRemove = {}
        assetsToUpdate = {}
        changedIds = {}
        commonVersions = set(oldAssets.keys()).intersection(set(newAssets.keys()))
        
        for version in commonVersions:
            oldVersionAssets = oldAssets[version]
            newVersionAssets = newAssets[version]
            commonAssetNames = set(oldVersionAssets).intersection(set(newVersionAssets.keys()))

            for assetName in commonAssetNames:
                oldVersionNameAssets = oldVersionAssets[assetName]
                newVersionNameAssets = newVersionAssets[assetName]
                commonAssetTypes = set(oldVersionNameAssets.keys()).intersection(set(newVersionNameAssets.keys()))

                for assetType in commonAssetTypes:
                    oldAsset = oldVersionNameAssets[assetType]
                    newAsset = newVersionNameAssets[assetType]

                    if (oldAsset != newAsset):
                        assetsToRemove[version][assetName][assetType] = oldAsset
                        assetsToUpdate[version][assetName][assetType] = newAsset
                        changedIds[oldAsset] = newAsset

        return [changedIds, assetsToRemove, assetsToUpdate]

    @classmethod
    def _updateFromAssetsIds(self, fromAssets: Dict[str, Tuple[Set[str], str]], changedAssetIds: Dict[str, str]):
        for oldAssetId in changedAssetIds:
            newAssetId = changedAssetIds[oldAssetId]
            assetMetadata = fromAssets[oldAssetId]
            fromAssets.pop(oldAssetId)
            fromAssets[newAssetId] = assetMetadata

    @classmethod
    def _getFromAssets(cls, map: Dict[str, Set[str]], assets: Dict[float, Dict[str, Dict[str, str]]]) -> Dict[str, Tuple[Set[str], str]]:
        """
        Retrieves the assets to fix from

        Parameters
        ----------
        map: Dict[str, Set[str]]
            The mapping for fixing the assets

        assets: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
            The source for all the assets :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)

        Returns
        -------
        Dict[:class:`str`, Tuple[Set[:class:`str`], :class:`str`]]
            The assets to fix from :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the ids for the asset
            * The values contains metadata about the assets to fix to where each tuple contains:

                # The names of the assets
                # The type of asset

        """

        result = {}
        if (not map):
            return result

        invertedAssets = defaultdict(lambda: {})
        toAssets = defaultdict(lambda: set())

        for version in assets:
            versionAssets = assets[version]

            # get all the available assets to fix from
            for name in map:
                try:
                    asset = versionAssets[name]
                except KeyError:
                    continue
                else:
                    asset = DictTools.invert(asset)
                    DictTools.update(invertedAssets[name], asset)

            # get the available assets to fix to
            for name in map:
                toAssetNames = map[name]
                for toAssetName in toAssetNames:
                    try:
                        asset = versionAssets[toAssetName]
                    except:
                        continue
                    else:
                        toAssets[toAssetName] = toAssets[toAssetName].union(set(asset.keys()))

        # organize the assets
        for fromAssetName in invertedAssets:
            asset = invertedAssets[fromAssetName]
            toAssetNames = map[fromAssetName]

            for assetId in asset:
                assetType = asset[assetId]
                toNames = set()

                for toAssetName in toAssetNames:
                    toAssetTypes = toAssets[toAssetName]
                    if (assetType in toAssetTypes):
                        toNames.add(toAssetName)

                metadata = (toNames, assetType)
                result[assetId] = metadata

        return result
    
    @classmethod
    def _removeToAssets(cls, toAssets: Dict[float, Dict[str, Dict[str, str]]], assetsToRemove: Dict[float, Dict[str, Dict[str, str]]]):
        for version in toAssets:
            versionAssets = toAssets[version]
            
            for name in versionAssets:
                currentAssets = versionAssets[name]

                for type in currentAssets:
                    try:
                        assetsToRemove[version][name][type]
                    except:
                        continue
                    else:
                        toAssets[version][name].pop(type)

                if (not toAssets[version][name]):
                    toAssets[version].pop(name)

            if (not toAssets[version]):
                toAssets.pop(version)
    
    def _getToAssets(self, assetNames: Set[str], assets: Dict[float, Dict[str, Dict[str, str]]]) -> Dict[float, Dict[str, Dict[str, str]]]:
        """
        Retrieves the assets to fix to

        Parameters
        ----------
        assetNames: Set[:class:`str`]
            The names of the assets to fix to

        assets: Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
            The source for all the assets :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)

        Returns
        -------
        Dict[:class:`float`, Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
            The assets to fix to  :raw-html:`<br />` :raw-html:`<br />`

            * The outer key is the game version number for the assets
            * The first inner key is the name of the asset
            * The second inner key is the type of asset
            * The most inner value is the id for the asset (must be unique)
        """

        result = {}
        if (not assetNames):
            return result
        
        prevToAssets = defaultdict(lambda: {})

        for version, versionAssets in assets.items():
            currentToAssets = {}

            for name in assetNames:
                try:
                    asset = versionAssets[name]
                except KeyError:
                    continue
                else:
                    prevAsset = prevToAssets[name]
                    DictTools.update(prevAsset, asset)
                    
                    if (prevAsset):
                        currentToAssets[name] = copy.deepcopy(prevAsset)
                        self._addVersion(name, version)

            if (currentToAssets):
                result[version] = currentToAssets

        return result


    def addMap(self, assetMap: Dict[str, Set[str]], assets: Optional[Dict[float, Dict[str, Dict[str, str]]]] = None):
        super().addMap(assetMap, assets = assets)
        if (assets is None):
            assets = {}

        changedIds, assetsIdsToRemove, assetsIdsToUpdate = self._getAssetChanges(self._repo, assets)
        self._repo = self.updateRepo(self._repo, assets)
        newAddMap, addFixFrom, addFixTo = self._partition(assetMap, self._repo)

        self._repo = self._repo
        if (not addFixFrom or not addFixTo):
            return

        self._map = self.updateMap(self._map, newAddMap)
        self._fixFrom = self._fixFrom.union(addFixFrom)
        self._fixTo = self._fixTo.union(addFixTo)

        # update the assets to fix from
        self._updateFromAssetsIds(self._fromAssets, changedIds)
        addFromAssets = self._getFromAssets(newAddMap, self._repo)
        DictTools.update(self._fromAssets, addFromAssets)

        # update the assets to fix to
        self._removeToAssets(self._toAssets, assetsIdsToRemove)

        addToAssetNames = set(map(lambda versionAssets: versionAssets.keys(), assetsIdsToUpdate.values()))
        addToAssetNames = addToAssetNames.union(addFixTo)
        addToAssets = self._getToAssets(addToAssetNames, self._repo)

        DictTools.update(self._toAssets, addToAssets, combineDuplicate = self._updateDupAssets)


class Hashes(ModIdAssets):
    """
    This class inherits from :class:`ModDictStrAssets`
    
    Class for managing hashes for a mod

    Parameters
    ----------
    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the hashes to fix from to the hashes to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(HashData, map = map)


IndexData = {4.0 : {"Amber": {"head": "0", "body": "5670"},
        "AmberCN": {"head": "0", "body": "5670"},
        "Barbara": {"head": "0", "body": "12015", "dress": "46248"},
        "BarbaraSummertime": {"head": "0", "body": "11943", "dress": "45333"},
        "Fischl": {"head": "0", "body": "11535", "dress": "42471"},
        "FischlHighness": {"head": "0", "body": "23091"},
        "Ganyu": {"head": "0", "body": "12822", "dress": "47160"},
        "Jean": {"head": "0", "body": "7779"},
        "JeanCN": {"head": "0", "body": "7779"},
        "JeanSea": {"head": "0", "body": "7662", "dress": "52542"},
        "Keqing": {"head": "0", "body": "10824", "dress": "48216"},
        "KeqingOpulent": {"head": "0", "body": "19623"},
        "Kirara": {"head": "0", "body": "37128", "dress": "75234"},
        "Mona": {"head": "0", "body": "17688"},
        "MonaCN": {"head": "0", "body": "17688"},
        "Nilou": {"head": "0", "body": "44844", "dress": "64080"},
        "Ningguang": {"head": "0", "body": "12384", "dress": "47157"},
        "NingguangOrchid": {"head": "0", "body": "43539", "dress": "56124"},
        "Rosaria": {"head": "0", "body": "11139", "dress": "44088", "extra": "45990"},
        "RosariaCN": {"head": "0", "body": "11025", "dress": "46539", "extra": "48441"},
        "Shenhe": {"head": "0", "body": "14385", "dress": "48753"}},
        4.4: {"ShenheFrostFlower": {"head": "0", "body": "31326", "dress": "66588", "extra": "70068"},
              "GanyuTwilight": {"head": "0", "body": "50817", "dress": "74235"}},
        4.6: {"Arlecchino": {"head": "0", "body": "40179", "dress": "74412"},
              "ArlecchinoBoss": {"head": "0", "body": "40179", "dress": "74412"}},
        4.8: {"NilouBreeze": {"head": "0", "body": "44538", "dress": "73644"},
              "KiraraBoots": {"head": "0", "body": "36804", "dress": "80295"}}}


class Indices(ModIdAssets):
    """
    This class inherits from :class:`ModDictStrAssets`
    
    Class for managing indices for a mod

    Parameters
    ----------
    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the indices to fix from to the indices to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(IndexData, map = map)


class VGRemap():
    """
    Class for handling the vertex group remaps for mods

    Parameters
    ----------
    vgRemap: Dict[:class:`int`, :class:`int`] 
        The vertex group remap from one type of mod to another
    """

    def __init__(self, vgRemap: Dict[int, int]):
        self._maxIndex = 0
        self.remap = vgRemap

    @property
    def remap(self):
        """
        The vertex group remap

        :getter: Retrieves the remap
        :setter: Sets a new remap
        :type: Dict[:class:`int`, :class:`int`]
        """

        return self._remap

    @remap.setter
    def remap(self, newVgRemap: Dict[int, int]):
        self._remap = newVgRemap
        if (self._remap):
            self._maxIndex = max(list(self._remap.keys()))
        else:
            self._maxIndex = None

    @property
    def maxIndex(self):
        """
        The maximum index in the vertex group remap

        :getter: Retrieves the max index
        :type: :class:`int`
        """

        return self._maxIndex


VGRemapData = {4.0: { "Amber" : {"AmberCN": VGRemap({0: 7, 1: 6, 2: 9, 3: 10, 4: 11, 5: 29, 6: 8, 7: 12, 8: 13, 9: 14, 10: 15, 11: 16, 12: 17, 
                               13: 77, 14: 1, 15: 0, 16: 73, 17: 18, 18: 19, 19: 20, 20: 21, 21: 53, 22: 70, 23: 74, 24: 50, 
                               25: 30, 26: 47, 27: 51, 28: 76, 29: 75, 30: 24, 31: 71, 32: 28, 33: 27, 34: 54, 35: 52, 36: 31, 
                               37: 72, 38: 55, 39: 56, 40: 61, 41: 58, 42: 62, 43: 64, 44: 65, 45: 67, 46: 68, 47: 57, 48: 59, 49: 60, 
                               50: 63, 51: 66, 52: 69, 53: 48, 54: 26, 55: 25, 56: 49, 57: 32, 58: 33, 59: 38, 60: 35, 61: 39, 62: 41, 
                               63: 42, 64: 44, 65: 45, 66: 34, 67: 36, 68: 37, 69: 40, 70: 43, 71: 46, 72: 22, 73: 23, 74: 2, 75: 3, 76: 4, 77: 5})},
        "AmberCN": {"Amber" : VGRemap({0: 15, 1: 14, 2: 74, 3: 75, 4: 76, 5: 77, 6: 1, 7: 0, 8: 6, 9: 2, 10: 3, 11: 4, 12: 7, 13: 8, 14: 9, 15: 10, 
                               16: 11, 17: 12, 18: 17, 19: 18, 20: 19, 21: 20, 22: 72, 23: 73, 24: 30, 25: 55, 26: 54, 27: 33, 28: 32, 
                               29: 5, 30: 25, 31: 36, 32: 57, 33: 58, 34: 66, 35: 60, 36: 67, 37: 68, 38: 59, 39: 61, 40: 69, 41: 62, 42: 
                               63, 43: 70, 44: 64, 45: 65, 46: 71, 47: 26, 48: 53, 49: 56, 50: 24, 51: 27, 52: 35, 53: 21, 54: 34, 55: 38, 
                               56: 39, 57: 47, 58: 41, 59: 48, 60: 49, 61: 40, 62: 42, 63: 50, 64: 43, 65: 44, 66: 51, 67: 45, 68: 46, 69: 52, 
                               70: 22, 71: 31, 72: 37, 73: 16, 74: 23, 75: 29, 76: 28, 77: 13})},
        "Barbara": {"BarbaraSummertime": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 86, 7: 86, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: 12, 
                                          15: 13, 16: 14, 17: 15, 18: 16, 19: 17, 20: 18, 21: 19, 22: 19, 23: 20, 24: 20, 25: 21, 26: 21, 
                                          27: 22, 28: 22, 29: 84, 30: 18, 31: 57, 32: 57, 33: 23, 34: 23, 35: 24, 36: 24, 37: 25, 38: 25, 
                                          39: 26, 40: 26, 41: 27, 42: 27, 43: 28, 44: 28, 45: 29, 46: 29, 47: 30, 48: 30, 49: 31, 50: 59, 
                                          51: 33, 52: 83, 53: 35, 54: 36, 55: 37, 56: 38, 57: 39, 58: 40, 59: 41, 60: 42, 61: 43, 62: 44, 
                                          63: 45, 64: 46, 65: 47, 66: 48, 67: 49, 68: 50, 69: 51, 70: 52, 71: 53, 72: 54, 73: 55, 74: 56, 
                                          75: 57, 76: 58, 77: 60, 78: 61, 79: 62, 80: 63, 81: 64, 82: 65, 83: 66, 84: 67, 85: 68, 86: 69, 
                                          87: 70, 88: 71, 89: 72, 90: 73, 91: 74, 92: 75, 93: 76, 94: 77, 95: 78, 96: 79, 97: 80, 98: 81, 
                                          99: 82, 100: 84, 101: 85, 102: 86 })},
        "BarbaraSummertime": {"Barbara": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 8, 7: 9, 8: 10, 9: 11, 10: 12, 11: 13, 12: 14, 13: 15, 14: 16, 
                                          15: 17, 16: 18, 17: 19, 18: 20, 19: 22, 20: 23, 21: 26, 22: 27, 23: 34, 24: 35, 25: 38, 26: 39, 27: 42, 
                                          28: 43, 29: 46, 30: 47, 31: 49, 32: 50, 33: 51, 34: 52, 35: 53, 36: 54, 37: 55, 38: 56, 39: 57, 40: 58, 
                                          41: 59, 42: 60, 43: 61, 44: 62, 45: 63, 46: 64, 47: 65, 48: 66, 49: 67, 50: 68, 51: 69, 52: 70, 53: 71, 
                                          54: 72, 55: 73, 56: 74, 57: 75, 58: 76, 59: 50, 60: 77, 61: 78, 62: 79, 63: 80, 64: 81, 65: 82, 66: 83, 
                                          67: 84, 68: 85, 69: 86, 70: 87, 71: 88, 72: 89, 73: 90, 74: 91, 75: 92, 76: 93, 77: 94, 78: 95, 79: 96, 
                                          80: 97, 81: 98, 82: 99, 83: 52, 84: 100, 85: 101, 86: 102 })},
        "Fischl" : {"FischlHighness": VGRemap({1: 40, 2: 0, 3: 1, 4: 3, 5: 4, 6: 5, 7: 6, 8: 7, 9: 8, 10: 9, 11: 10, 12: 11, 13: 12, 14: 13, 15: 14, 
                                               16: 15, 17: 16, 18: 17, 19: 17, 20: 19, 21: 20, 22: 21, 23: 22, 24: 23, 25: 24, 26: 25, 27: 26, 28: 27, 
                                               29: 28, 30: 29, 31: 30, 32: 29, 33: 30, 34: 31, 35: 32, 36: 31, 37: 32, 38: 33, 39: 34, 40: 35, 41: 36, 
                                               42: 37, 43: 38, 44: 39, 45: 40, 46: 41, 47: 42, 48: 43, 49: 44, 50: 45, 51: 46, 52: 47, 53: 48, 54: 49, 
                                               55: 50, 56: 51, 57: 52, 58: 53, 59: 54, 60: 55, 61: 56, 62: 57, 63: 58, 64: 59, 65: 60, 66: 61, 67: 62, 
                                               68: 63, 69: 64, 70: 65, 71: 66, 72: 67, 73: 68, 74: 69, 75: 70, 76: 71, 77: 72, 78: 73, 79: 74, 80: 75, 
                                               81: 76, 82: 77, 83: 78, 84: 79, 85: 80, 86: 81, 87: 82, 88: 83, 89: 84, 90: 85, 91: 86, 92: 87, 93: 88, 94: 89})},
        "FischlHighness": {"Fischl": VGRemap({0: 2, 1: 3, 2: 46, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11, 11: 12, 12: 13, 13: 14, 14: 15, 
                                               15: 16, 16: 17, 17: 18, 18: 19, 19: 20, 20: 21, 21: 22, 22: 23, 23: 24, 24: 25, 25: 26, 26: 27, 27: 28, 
                                               28: 29, 29: 30, 30: 31, 31: 34, 32: 35, 33: 38, 34: 39, 35: 40, 36: 41, 37: 42, 38: 43, 39: 44, 40: 0, 41: 46, 
                                               42: 47, 43: 48, 44: 49, 45: 50, 46: 51, 47: 52, 48: 53, 49: 54, 50: 55, 51: 56, 52: 57, 53: 58, 54: 59, 55: 60, 
                                               56: 61, 57: 62, 58: 63, 59: 64, 60: 65, 61: 66, 62: 67, 63: 68, 64: 69, 65: 70, 66: 71, 67: 72, 68: 73, 69: 74, 
                                               70: 75, 71: 76, 72: 77, 73: 78, 74: 79, 75: 80, 76: 81, 77: 82, 78: 83, 79: 84, 80: 85, 81: 86, 82: 87, 83: 88, 
                                               84: 89, 85: 90, 86: 91, 87: 92, 88: 93, 89: 94})},
        "Jean" : {"JeanCN": VGRemap({0: 50, 1: 102, 2: 103, 3: 104, 4: 79, 5: 56, 6: 24, 7: 25, 8: 33, 9: 34, 10: 35, 11: 30, 12: 31, 13: 32, 14: 26, 
                             15: 27, 16: 28, 17: 29, 18: 58, 19: 75, 20: 76, 21: 59, 22: 60, 23: 61, 24: 62, 25: 63, 26: 64, 27: 65, 28: 66, 
                             29: 67, 30: 68, 31: 69, 32: 70, 33: 71, 34: 72, 35: 73, 36: 52, 37: 51, 38: 6, 39: 7, 40: 10, 41: 11, 42: 12, 
                             43: 13, 44: 2, 45: 3, 46: 81, 47: 98, 48: 99, 49: 82, 50: 83, 51: 84, 52: 85, 53: 86, 54: 87, 55: 88, 56: 89, 
                             57: 90, 58: 91, 59: 92, 60: 93, 61: 94, 62: 95, 63: 96, 64: 53, 65: 54, 66: 4, 67: 5, 68: 16, 69: 17, 70: 14, 
                             71: 15, 72: 8, 73: 9, 74: 19, 75: 18, 76: 0, 77: 1, 78: 21, 79: 23, 80: 20, 81: 22, 82: 47, 83: 48, 84: 49, 85: 43, 
                             86: 44, 87: 45, 88: 46, 89: 40, 90: 41, 91: 42, 92: 36, 93: 37, 94: 38, 95: 39, 96: 55, 97: 77, 98: 57, 99: 74, 
                             100: 78, 101: 100, 102: 80, 103: 97, 104: 101}),
                  "JeanSea": VGRemap({0: 30, 1: 82, 2: 83, 3: 84, 4: 59, 5: 36, 6: 4, 7: 5, 8: 13, 9: 14, 10: 15, 11: 10, 12: 11, 13: 12, 14: 6, 15: 7,
                                    16: 8, 17: 9, 18: 38, 19: 55, 20: 56, 21: 39, 22: 40, 23: 41, 24: 42, 25: 43, 26: 44, 27: 45, 28: 46, 29: 47, 
                                    30: 48, 31: 49, 32: 50, 33: 51, 34: 52, 35: 53, 36: 32, 37: 31, 46: 61, 47: 78, 48: 79, 49: 62, 50: 63, 51: 
                                    64, 52: 65, 53: 66, 54: 67, 55: 68, 56: 69, 57: 70, 58: 71, 59: 72, 60: 73, 61: 74, 62: 75, 63: 76, 64: 33, 
                                    65: 34, 74: 2, 75: 0, 82: 27, 83: 28, 84: 29, 85: 23, 86: 24, 87: 25, 88: 26, 89: 20, 90: 21, 91: 22, 92: 16, 
                                    93: 17, 94: 18, 95: 19, 96: 35, 97: 57, 98: 37, 99: 54, 100: 58, 101: 80, 102: 60, 103: 77, 104: 81})},
        "JeanCN": {"Jean": VGRemap({0: 76, 1: 77, 2: 44, 3: 45, 4: 66, 5: 67, 6: 38, 7: 39, 8: 72, 9: 73, 10: 40, 11: 41, 12: 42, 13: 43, 14: 70, 15: 71, 
                            16: 68, 17: 69, 18: 75, 19: 74, 20: 80, 21: 78, 22: 81, 23: 79, 24: 6, 25: 7, 26: 14, 27: 15, 28: 16, 29: 17, 30: 11, 
                            31: 12, 32: 13, 33: 8, 34: 9, 35: 10, 36: 92, 37: 93, 38: 94, 39: 95, 40: 89, 41: 90, 42: 91, 43: 85, 44: 86, 45: 87, 
                            46: 88, 47: 82, 48: 83, 49: 84, 50: 0, 51: 37, 52: 36, 53: 64, 54: 65, 55: 96, 56: 5, 57: 98, 58: 18, 59: 21, 60: 22, 
                            61: 23, 62: 24, 63: 25, 64: 26, 65: 27, 66: 28, 67: 29, 68: 30, 69: 31, 70: 32, 71: 33, 72: 34, 73: 35, 74: 99, 75: 19, 
                            76: 20, 77: 97, 78: 100, 79: 4, 80: 102, 81: 46, 82: 49, 83: 50, 84: 51, 85: 52, 86: 53, 87: 54, 88: 55, 89: 56, 90: 57, 
                            91: 58, 92: 59, 93: 60, 94: 61, 95: 62, 96: 63, 97: 103, 98: 47, 99: 48, 100: 101, 101: 104, 102: 1, 103: 2, 104: 3}),
                   "JeanSea": VGRemap({18: 0, 19: 2, 24: 4, 25: 5, 26: 6, 27: 7, 28: 8, 29: 9, 30: 10, 31: 11, 32: 12, 33: 13, 34: 14, 35: 15, 
                                       36: 16, 37: 17, 38: 18, 39: 19, 40: 20, 41: 21, 42: 22, 43: 23, 44: 24, 45: 25, 46: 26, 47: 27, 48: 28, 
                                       49: 29, 50: 30, 51: 31, 52: 32, 53: 33, 54: 34, 55: 35, 56: 36, 57: 37, 58: 38, 59: 39, 60: 40, 61: 41, 62: 42, 
                                       63: 43, 64: 44, 65: 45, 66: 46, 67: 47, 68: 48, 69: 49, 70: 50, 71: 51, 72: 52, 73: 53, 74: 54, 75: 55, 76: 56, 
                                       77: 57, 78: 58, 79: 59, 80: 60, 81: 61, 82: 62, 83: 63, 84: 64, 85: 65, 86: 66, 87: 67, 88: 68, 89: 69, 90: 70, 
                                       91: 71, 92: 72, 93: 73, 94: 74, 95: 75, 96: 76, 97: 77, 98: 78, 99: 79, 100: 80, 101: 81, 102: 82, 103: 83, 104: 84})},
        "JeanSea": {"Jean": VGRemap({0: 75, 1: 75, 2: 74, 3: 74, 4: 6, 5: 7, 6: 14, 7: 15, 8: 16, 9: 17, 10: 11, 11: 12, 12: 13, 13: 8, 14: 9, 15: 10, 16: 92, 
                                     17: 93, 18: 94, 19: 95, 20: 89, 21: 90, 22: 91, 23: 85, 24: 86, 25: 87, 26: 88, 27: 82, 28: 83, 29: 84, 30: 0, 
                                     31: 37, 32: 36, 33: 64, 34: 65, 35: 96, 36: 5, 37: 98, 38: 18, 39: 21, 40: 22, 41: 23, 42: 24, 43: 25, 44: 26, 
                                     45: 27, 46: 28, 47: 29, 48: 30, 49: 31, 50: 32, 51: 33, 52: 34, 53: 35, 54: 99, 55: 19, 56: 20, 57: 97, 58: 100, 
                                     59: 4, 60: 102, 61: 46, 62: 49, 63: 50, 64: 51, 65: 52, 66: 53, 67: 54, 68: 55, 69: 56, 70: 57, 71: 58, 72: 59, 
                                     73: 60, 74: 61, 75: 62, 76: 63, 77: 103, 78: 47, 79: 48, 80: 101, 81: 104, 82: 1, 83: 2, 84: 3}),
                    "JeanCN": VGRemap({0: 18, 1: 18, 2: 19, 3: 19, 4: 24, 5: 25, 6: 26, 7: 27, 8: 28, 9: 29, 10: 30, 11: 31, 12: 32, 13: 33, 14: 34, 15: 35, 16: 36, 17: 37, 
                                       18: 38, 19: 39, 20: 40, 21: 41, 22: 42, 23: 43, 24: 44, 25: 45, 26: 46, 27: 47, 28: 48, 29: 49, 30: 50, 31: 51, 32: 52, 
                                       33: 53, 34: 54, 35: 55, 36: 56, 37: 57, 38: 58, 39: 59, 40: 60, 41: 61, 42: 62, 43: 63, 44: 64, 45: 65, 46: 66, 47: 67, 
                                       48: 68, 49: 69, 50: 70, 51: 71, 52: 72, 53: 73, 54: 74, 55: 75, 56: 76, 57: 77, 58: 78, 59: 79, 60: 80, 61: 81, 62: 82, 
                                       63: 83, 64: 84, 65: 85, 66: 86, 67: 87, 68: 88, 69: 89, 70: 90, 71: 91, 72: 92, 73: 93, 74: 94, 75: 95, 76: 96, 77: 97, 
                                       78: 98, 79: 99, 80: 100, 81: 101, 82: 102, 83: 103, 84: 104})},
        "Mona": {"MonaCN": VGRemap({0: 37, 1: 38, 2: 39, 3: 36, 4: 58, 5: 30, 6: 31, 7: 32, 8: 29, 9: 57, 10: 26, 11: 25, 12: 24, 13: 27, 14: 28, 15: 34, 
                            16: 35, 17: 40, 18: 33, 19: 81, 20: 106, 21: 102, 22: 47, 23: 43, 24: 46, 25: 44, 26: 42, 27: 41, 28: 45, 29: 105, 30: 104, 
                            31: 60, 32: 54, 33: 53, 34: 20, 35: 83, 36: 56, 37: 55, 38: 21, 39: 15, 40: 10, 41: 16, 42: 11, 43: 5, 44: 23, 45: 0, 46: 6, 
                            47: 1, 48: 22, 49: 77, 50: 49, 51: 50, 52: 100, 53: 51, 54: 52, 55: 79, 56: 2, 57: 7, 58: 3, 59: 4, 60: 8, 61: 9, 62: 12, 
                            63: 17, 64: 13, 65: 14, 66: 18, 67: 19, 68: 59, 69: 76, 70: 82, 71: 99, 72: 80, 73: 103, 74: 48, 75: 101, 76: 84, 77: 90, 
                            78: 87, 79: 93, 80: 96, 81: 97, 82: 85, 83: 86, 84: 88, 85: 89, 86: 91, 87: 92, 88: 94, 89: 95, 90: 98, 91: 78, 92: 61, 
                            93: 67, 94: 64, 95: 70, 96: 73, 97: 74, 98: 62, 99: 63, 100: 65, 101: 66, 102: 68, 103: 69, 104: 71, 105: 72, 106: 75})},
        "MonaCN": {"Mona": VGRemap({0: 45, 1: 47, 2: 56, 3: 58, 4: 59, 5: 43, 6: 46, 7: 57, 8: 60, 9: 61, 10: 40, 11: 42, 12: 62, 13: 64, 14: 65, 15: 39, 
                            16: 41, 17: 63, 18: 66, 19: 67, 20: 34, 21: 38, 22: 48, 23: 44, 24: 12, 25: 11, 26: 10, 27: 13, 28: 14, 29: 8, 30: 5, 
                            31: 6, 32: 7, 33: 18, 34: 15, 35: 16, 36: 3, 37: 0, 38: 1, 39: 2, 40: 17, 41: 27, 42: 26, 43: 23, 44: 25, 45: 28, 46: 24, 
                            47: 22, 48: 74, 49: 50, 50: 51, 51: 53, 52: 54, 53: 33, 54: 32, 55: 37, 56: 36, 57: 9, 58: 4, 59: 68, 60: 31, 61: 92, 
                            62: 98, 63: 99, 64: 94, 65: 100, 66: 101, 67: 93, 68: 102, 69: 103, 70: 95, 71: 104, 72: 105, 73: 96, 74: 97, 75: 106, 
                            76: 69, 77: 49, 78: 91, 79: 55, 80: 72, 81: 19, 82: 70, 83: 35, 84: 76, 85: 82, 86: 83, 87: 78, 88: 84, 89: 85, 90: 77, 
                            91: 86, 92: 87, 93: 79, 94: 88, 95: 89, 96: 80, 97: 81, 98: 90, 99: 71, 100: 52, 101: 75, 102: 21, 103: 73, 104: 30, 
                            105: 29, 106: 20})},
        "Ningguang": {"NingguangOrchid": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14,
                            15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 29: 28, 30: 29,
                            31: 30, 32: 31, 33: 32, 34: 33, 35: 34, 36: 35, 37: 36, 38: 37, 39: 38, 40: 39, 41: 40, 42: 41, 43: 42, 44: 43, 45: 44,
                            46: 45, 47: 46, 48: 47, 52: 48, 53: 49, 54: 50, 55: 51, 56: 52, 57: 53, 58: 54, 59: 55, 60: 56, 61: 57, 62: 58, 63: 59,
                            64: 60, 65: 61, 66: 62, 67: 63, 68: 64, 69: 65, 70: 66, 71: 67, 72: 68, 73: 69, 74: 70, 75: 71, 76: 72, 77: 73, 78: 74,
                            79: 75, 80: 76, 81: 77, 82: 78, 83: 79, 84: 80, 85: 81, 86: 82, 87: 83, 88: 84, 89: 85, 90: 86, 91: 87, 92: 88, 93: 89,
                            94: 90, 95: 91, 96: 92, 97: 93, 98: 94, 99: 95, 100: 96, 101: 97, 102: 98, 103: 99, 104: 100, 105: 101, 106: 102, 107: 103,
                            108: 104, 109: 105, 110: 106, 111: 107, 112: 108, 113: 109, 114: 110, 115: 111, 116: 112, 117: 113, 118: 114})},
        "NingguangOrchid": {"Ningguang": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 
                               17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 29, 29: 30, 30: 31, 31: 32, 
                               32: 33, 33: 34, 34: 35, 35: 36, 36: 37, 37: 38, 38: 39, 39: 40, 40: 41, 41: 42, 42: 43, 43: 44, 44: 45, 45: 46, 46: 47, 
                               47: 48, 48: 52, 49: 53, 50: 54, 51: 55, 52: 56, 53: 57, 54: 58, 55: 59, 56: 60, 57: 61, 58: 62, 59: 63, 60: 64, 61: 65, 
                               62: 66, 63: 67, 64: 68, 65: 69, 66: 70, 67: 71, 68: 72, 69: 73, 70: 74, 71: 75, 72: 76, 73: 77, 74: 78, 75: 79, 76: 80, 
                               77: 81, 78: 82, 79: 83, 80: 84, 81: 85, 82: 86, 83: 87, 84: 88, 85: 89, 86: 90, 87: 91, 88: 92, 89: 93, 90: 94, 91: 95, 
                               92: 96, 93: 97, 94: 98, 95: 99, 96: 100, 97: 101, 98: 102, 99: 103, 100: 104, 101: 105, 102: 106, 103: 107, 104: 108, 
                               105: 109, 106: 110, 107: 111, 108: 112, 109: 113, 110: 114, 111: 115, 112: 116, 113: 117, 114: 118})},
        "Rosaria": {"RosariaCN": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 
                                  16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 
                                  30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 
                                  44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 
                                  58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 
                                  72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 82: 82, 83: 83, 84: 84, 85: 85,
                                  86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97})},
        "RosariaCN": {"Rosaria": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 
                                  16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 
                                  30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 
                                  44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 
                                  58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 
                                  72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 82: 82, 83: 83, 84: 84, 85: 85,
                                  86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97})},
        "Raiden": {"RaidenBoss": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 60, 9: 61, 10: 66, 11: 67,
                                12: 8, 13: 9, 14: 10, 15: 11, 16: 12, 17: 13, 18: 14, 19: 15, 20: 16, 21: 17,
                                22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: 23, 28: 24, 29: 25, 30: 26, 31: 27,
                                32: 28, 33: 29, 34: 30, 35: 31, 36: 32, 37: 33, 38: 34, 39: 35, 40: 36, 41: 37,
                                42: 38, 43: 39, 44: 40, 45: 41, 46: 42, 47: 94, 48: 43, 49: 44, 50: 45, 51: 46,
                                52: 47, 53: 48, 54: 49, 55: 50, 56: 51, 57: 52, 58: 53, 59: 54, 60: 55, 61: 56,
                                62: 57, 63: 58, 64: 59, 65: 114, 66: 116, 67: 115, 68: 117, 69: 74, 70: 62, 71: 64,
                                72: 106, 73: 108, 74: 110, 75: 75, 76: 77, 77: 79, 78: 87, 79: 89, 80: 91, 81: 95,
                                82: 97, 83: 99, 84: 81, 85: 83, 86: 85, 87: 68, 88: 70, 89: 72, 90: 104, 91: 112,
                                92: 93, 93: 63, 94: 65, 95: 107, 96: 109, 97: 111, 98: 76, 99: 78, 100: 80, 101: 88,
                                102: 90, 103: 92, 104: 96, 105: 98, 106: 100, 107: 82, 108: 84, 109: 86, 110: 69,
                                111: 71, 112: 73, 113: 105, 114: 113, 115: 101, 116: 102, 117: 103})},
         "RaidenBoss": {"Raiden": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 12, 9: 13, 10: 14, 11: 15, 12: 16, 13: 17, 14: 18, 15: 19, 16: 20, 
                                           17: 21, 18: 22, 19: 23, 20: 24, 21: 25, 22: 26, 23: 27, 24: 28, 25: 29, 26: 30, 27: 31, 28: 32, 29: 33, 30: 34, 31: 35, 
                                           32: 36, 33: 37, 34: 38, 35: 39, 36: 40, 37: 41, 38: 42, 39: 43, 40: 44, 41: 45, 42: 46, 43: 48, 44: 49, 45: 50, 46: 51,
                                           47: 52, 48: 53, 49: 54, 50: 55, 51: 56, 52: 57, 53: 58, 54: 59, 55: 60, 56: 61, 57: 62, 58: 63, 59: 64, 60: 8, 61: 9, 62: 70, 
                                           63: 93, 64: 71, 65: 94, 66: 10, 67: 11, 68: 87, 69: 110, 70: 88, 71: 111, 72: 89, 73: 112, 74: 69, 75: 75, 76: 98, 77: 76, 78: 99, 
                                           79: 77, 80: 100, 81: 84, 82: 107, 83: 85, 84: 108, 85: 86, 86: 109, 87: 78, 88: 101, 89: 79, 90: 102, 91: 80, 92: 103, 93: 92, 
                                           94: 47, 95: 81, 96: 104, 97: 82, 98: 105, 99: 83, 100: 106, 101: 115, 102: 116, 103: 117, 104: 90, 105: 113, 106: 72, 107: 95, 
                                           108: 73, 109: 96, 110: 74, 111: 97, 112: 91, 113: 114, 114: 65, 115: 67, 116: 66, 117: 68})},
         "Keqing": {"KeqingOpulent": VGRemap({0: 100, 1: 101, 2: 102, 3: 76, 4: 52, 5: 3, 6: 2, 7: 16, 8: 17, 9: 9, 10: 10, 11: 11, 12: 12,
                                    13: 13, 14: 14, 15: 15, 16: 4, 17: 5, 18: 6, 19: 7, 20: 8, 21: 54, 22: 71, 23: 72, 24: 55, 25: 56,
                                    26: 57, 27: 58, 28: 59, 29: 60, 30: 61, 31: 62, 32: 63, 33: 64, 34: 65, 35: 66, 36: 67, 37: 68, 38: 69,
                                    39: 46, 40: 47, 41: 38, 42: 39, 43: 40, 44: 41, 45: 47, 46: 47, 47: 78, 48: 95, 49: 96, 50: 79, 51: 80,
                                    52: 81, 53: 82, 54: 83, 55: 84, 56: 85, 57: 86, 58: 87, 59: 88, 60: 89, 61: 90, 62: 91, 63: 92, 64: 93,
                                    65: 48, 66: 49, 67: 42, 68: 43, 69: 44, 70: 45, 71: 49, 72: 49, 73: 1, 74: 0, 75: 50, 76: 51, 77: 28,
                                    78: 29, 79: 30, 80: 19, 81: 20, 82: 21, 83: 34, 84: 35, 85: 22, 86: 23, 87: 24, 88: 36, 89: 37, 90: 31,
                                    91: 32, 92: 33, 93: 25, 94: 26, 95: 27, 101: 73, 102: 53, 103: 70, 104: 74, 105: 97, 106: 77, 107: 94, 108: 98, 109: 18})},
         "KeqingOpulent": {"Keqing": VGRemap({0: 74, 1: 73, 2: 6, 3: 5, 4: 16, 5: 17, 6: 18, 7: 19, 8: 20, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 7, 17: 8, 18: 109, 
                                    19: 80, 20: 81, 21: 82, 22: 85, 23: 86, 24: 87, 25: 93, 26: 94, 27: 95, 28: 77, 29: 78, 30: 79, 31: 90, 32: 91, 33: 92, 34: 83, 35: 84, 
                                    36: 88, 37: 89, 38: 41, 39: 42, 40: 43, 41: 44, 42: 67, 43: 68, 44: 69, 45: 70, 46: 39, 47: 40, 48: 65, 49: 66, 50: 75, 51: 76, 52: 4, 
                                    53: 102, 54: 21, 55: 24, 56: 25, 57: 26, 58: 27, 59: 28, 60: 29, 61: 30, 62: 31, 63: 32, 64: 33, 65: 34, 66: 35, 67: 36, 68: 37, 69: 38, 
                                    70: 103, 71: 22, 72: 23, 73: 101, 74: 104, 76: 3, 77: 106, 78: 47, 79: 50, 80: 51, 81: 52, 82: 53, 83: 54, 84: 55, 85: 56, 86: 57, 87: 58, 
                                    88: 59, 89: 60, 90: 61, 91: 62, 92: 63, 93: 64, 94: 107, 95: 48, 96: 49, 97: 105, 98: 108, 100: 0, 101: 1, 102: 2})}},
4.4: {"Amber": {"AmberCN": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 
                            17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 
                            32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 
                            48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 
                            64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77})},
      "AmberCN": {"Amber": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 
                            17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 
                            32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 
                            48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 
                            64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77})},
      "Ganyu": {"GanyuTwilight": VGRemap({0: 91, 1: 92, 2: 93, 3: 68, 4: 45, 5: 3, 6: 2, 7: 10, 8: 11, 9: 15, 10: 16, 11: 12, 12: 17, 13: 19, 14: 13, 15: 18, 
                                          16: 4, 17: 6, 18: 7, 19: 8, 20: 47, 21: 64, 22: 65, 23: 48, 24: 49, 25: 50, 26: 51, 27: 52, 28: 53, 29: 54, 30: 55, 
                                          31: 56, 32: 57, 33: 58, 34: 59, 35: 60, 36: 61, 37: 62, 38: 37, 39: 38, 40: 70, 41: 87, 42: 88, 43: 71, 44: 72, 45: 
                                          73, 46: 74, 47: 75, 48: 76, 49: 77, 50: 78, 51: 79, 52: 80, 53: 81, 54: 82, 55: 83, 56: 84, 57: 85, 58: 39, 59: 40, 
                                          60: 1, 61: 0, 62: 24, 63: 24, 64: 20, 65: 21, 66: 22, 67: 23, 68: 28, 69: 29, 70: 30, 71: 24, 72: 25, 73: 26, 74: 27, 
                                          75: 31, 76: 32, 77: 33, 78: 36, 79: 35, 80: 41, 81: 42, 82: 43, 83: 44, 84: 66, 85: 46, 86: 63, 87: 67, 88: 89, 89: 69, 
                                          90: 86, 91: 90, 92: 34})},
      "GanyuTwilight": {"Ganyu": VGRemap({0: 61, 1: 60, 2: 6, 3: 5, 4: 16, 5: 16, 6: 17, 7: 18, 8: 19, 9: 4, 10: 7, 11: 8, 12: 11, 13: 14, 14: 4, 15: 9, 16: 10, 
                                          17: 12, 18: 15, 19: 13, 20: 64, 21: 65, 22: 66, 23: 67, 24: 71, 25: 72, 26: 73, 27: 74, 28: 68, 29: 69, 30: 70, 31: 75, 
                                          32: 76, 33: 77, 34: 92, 35: 79, 36: 78, 37: 38, 38: 39, 39: 58, 40: 59, 41: 80, 42: 81, 43: 82, 44: 83, 45: 4, 46: 85, 
                                          47: 20, 48: 23, 49: 24, 50: 25, 51: 26, 52: 27, 53: 28, 54: 29, 55: 30, 56: 31, 57: 32, 58: 33, 59: 34, 60: 35, 61: 36, 
                                          62: 37, 63: 86, 64: 21, 65: 22, 66: 84, 67: 87, 68: 3, 69: 89, 70: 40, 71: 43, 72: 44, 73: 45, 74: 46, 75: 47, 76: 48, 
                                          77: 49, 78: 50, 79: 51, 80: 52, 81: 53, 82: 54, 83: 55, 84: 56, 85: 57, 86: 90, 87: 41, 88: 42, 89: 88, 90: 91, 91: 0, 92: 1, 93: 2})},
      "Mona": {"MonaCN": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 
                              18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 
                              34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 
                              50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 
                              66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 
                              82: 82, 83: 83, 84: 84, 85: 85, 86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97, 
                              98: 98, 99: 99, 100: 100, 101: 101, 102: 102, 103: 103, 104: 104, 105: 105, 106: 106})},
      "MonaCN": {"Mona": VGRemap({0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 
                              18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 
                              34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 
                              50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 
                              66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 
                              82: 82, 83: 83, 84: 84, 85: 85, 86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97, 
                              98: 98, 99: 99, 100: 100, 101: 101, 102: 102, 103: 103, 104: 104, 105: 105, 106: 106})},
      "Shenhe": {"ShenheFrostFlower": VGRemap({0: 106, 1: 106, 2: 106, 3: 106, 4: 0, 5: 1, 6: 81, 7: 2, 8: 3, 9: 4, 10: 5, 11: 6, 12: 7, 13: 8, 14: 9, 15: 10, 16: 11, 17: 12, 
                                            18: 13, 19: 14, 20: 15, 21: 18, 22: 19, 23: 20, 24: 21, 25: 2, 26: 2, 27: 106, 28: 4, 29: 4, 30: 106, 31: 22, 32: 22, 33: 56, 
                                            34: 56, 35: 56, 36: 56, 37: 57, 38: 57, 39: 57, 40: 57, 41: 22, 42: 25, 43: 26, 44: 27, 45: 28, 46: 29, 47: 28, 48: 29, 49: 39, 
                                            50: 40, 51: 41, 52: 42, 53: 45, 54: 46, 55: 47, 56: 48, 57: 0, 58: 1, 59: 56, 60: 57, 61: 58, 62: 59, 63: 60, 64: 61, 65: 62, 
                                            66: 63, 67: 64, 68: 65, 69: 66, 70: 67, 71: 68, 72: 69, 73: 70, 74: 71, 75: 72, 76: 73, 77: 74, 78: 75, 79: 76, 80: 77, 81: 78, 
                                            82: 79, 83: 80, 84: 81, 85: 82, 86: 83, 87: 84, 88: 85, 89: 86, 90: 87, 91: 88, 92: 89, 93: 90, 94: 91, 95: 92, 96: 93, 97: 94, 
                                            98: 95, 99: 96, 100: 97, 101: 98, 102: 99, 103: 100, 104: 101, 105: 102, 106: 103, 107: 104, 108: 105, 109: 106})},
      "ShenheFrostFlower": {"Shenhe": VGRemap({0: 57, 1: 58, 2: 7, 3: 8, 4: 9, 5: 10, 6: 11, 7: 12, 8: 13, 9: 14, 10: 15, 11: 16, 12: 17, 13: 18, 14: 19, 15: 20, 16: 61, 17: 61, 18: 21, 
                                            19: 22, 20: 23, 21: 24, 22: 41, 23: 109, 24: 109, 25: 42, 26: 43, 27: 44, 28: 47, 29: 48, 30: 41, 31: 82, 32: 82, 33: 62, 34: 41, 35: 105, 
                                            36: 105, 37: 85, 38: 81, 39: 49, 40: 50, 41: 51, 42: 52, 43: 57, 44: 104, 45: 53, 46: 54, 47: 55, 48: 56, 49: 58, 50: 81, 51: 104, 52: 81, 
                                            53: 57, 54: 104, 55: 58, 56: 59, 57: 60, 58: 61, 59: 62, 60: 63, 61: 64, 62: 65, 63: 66, 64: 67, 65: 68, 66: 69, 67: 70, 68: 71, 69: 72, 
                                            70: 73, 71: 74, 72: 75, 73: 76, 74: 77, 75: 78, 76: 79, 77: 80, 78: 81, 79: 82, 80: 83, 81: 84, 82: 85, 83: 86, 84: 87, 85: 88, 86: 89, 
                                            87: 90, 88: 91, 89: 92, 90: 93, 91: 94, 92: 95, 93: 96, 94: 97, 95: 98, 96: 99, 97: 100, 98: 101, 99: 102, 100: 103, 101: 104, 102: 105, 
                                            103: 106, 104: 107, 105: 108, 106: 109})}},
4.6: {"Arlecchino": {"ArlecchinoBoss": VGRemap({0: 47, 1: 49, 2: 48, 3: 50, 4: 51, 5: 52, 6: 53, 7: 54, 8: 55, 9: 56, 10: 57, 11: 58, 12: 59, 13: 61, 14: 60, 15: 62, 16: 65, 17: 63, 
                                                18: 64, 19: 66, 20: 67, 21: 69, 22: 71, 23: 73, 24: 75, 25: 77, 26: 79, 27: 81, 28: 68, 29: 70, 30: 72, 31: 74, 32: 76, 33: 78, 34: 80, 
                                                35: 82, 36: 83, 37: 84, 38: 85, 39: 86, 40: 88, 41: 90, 42: 87, 43: 89, 44: 91, 45: 92, 46: 94, 47: 96, 48: 98, 49: 100, 50: 93, 51: 95, 
                                                52: 97, 53: 99, 54: 101, 55: 102, 56: 103, 57: 104, 58: 106, 59: 107, 60: 110, 61: 105, 62: 108, 63: 109, 64: 111, 65: 112, 66: 113, 
                                                67: 114, 68: 115, 69: 0, 70: 1, 71: 2, 72: 3, 73: 4, 74: 5, 75: 6, 76: 7, 77: 8, 78: 9, 79: 10, 80: 11, 81: 12, 82: 13, 83: 14, 84: 15,
                                                85: 16, 86: 17, 87: 18, 88: 19, 89: 20, 90: 21, 91: 22, 92: 23, 93: 24, 94: 25, 95: 26, 96: 27, 97: 28, 98: 29, 99: 30, 100: 31, 
                                                101: 32, 102: 33, 103: 34, 104: 35, 105: 36, 106: 37, 107: 38, 108: 39, 109: 40, 110: 41, 111: 42, 112: 43, 113: 44, 114: 45, 115: 46})},
      "ArlecchinoBoss": {"Arlecchino": VGRemap({0: 47, 1: 49, 2: 48, 3: 50, 4: 51, 5: 52, 6: 53, 7: 54, 8: 55, 9: 56, 10: 57, 11: 58, 12: 59, 13: 61, 14: 60, 15: 62, 16: 65, 17: 63, 
                                                18: 64, 19: 66, 20: 67, 21: 69, 22: 71, 23: 73, 24: 75, 25: 77, 26: 79, 27: 81, 28: 68, 29: 70, 30: 72, 31: 74, 32: 76, 33: 78, 34: 80, 
                                                35: 82, 36: 83, 37: 84, 38: 85, 39: 86, 40: 88, 41: 90, 42: 87, 43: 89, 44: 91, 45: 92, 46: 94, 47: 96, 48: 98, 49: 100, 50: 93, 51: 95, 
                                                52: 97, 53: 99, 54: 101, 55: 102, 56: 103, 57: 104, 58: 106, 59: 107, 60: 110, 61: 105, 62: 108, 63: 109, 64: 111, 65: 112, 66: 113, 
                                                67: 114, 68: 115, 69: 0, 70: 1, 71: 2, 72: 3, 73: 4, 74: 5, 75: 6, 76: 7, 77: 8, 78: 9, 79: 10, 80: 11, 81: 12, 82: 13, 83: 14, 84: 15,
                                                85: 16, 86: 17, 87: 18, 88: 19, 89: 20, 90: 21, 91: 22, 92: 23, 93: 24, 94: 25, 95: 26, 96: 27, 97: 28, 98: 29, 99: 30, 100: 31, 
                                                101: 32, 102: 33, 103: 34, 104: 35, 105: 36, 106: 37, 107: 38, 108: 39, 109: 40, 110: 41, 111: 42, 112: 43, 113: 44, 114: 45, 115: 46})}},
4.8: {"Kirara": {"KiraraBoots": VGRemap({0: 89, 1: 89, 2: 87, 3: 19, 4: 19, 5: 23, 6: 23, 7: 89, 8: 1, 9: 1, 10: 89, 11: 2, 12: 2, 13: 89, 14: 1, 15: 2, 16: 3, 17: 4, 18: 5, 19: 6, 
                                         20: 7, 21: 8, 22: 9, 23: 10, 24: 43, 25: 8, 26: 8, 27: 11, 28: 12, 29: 43, 30: 43, 31: 13, 32: 14, 33: 15, 34: 16, 35: 17, 36: 18, 37: 19, 
                                         38: 20, 39: 21, 40: 22, 41: 23, 42: 24, 43: 25, 44: 26, 45: 18, 46: 18, 47: 18, 48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 40, 54: 42, 
                                         55: 40, 56: 42, 57: 27, 58: 28, 59: 29, 60: 30, 61: 31, 62: 32, 63: 33, 64: 34, 65: 35, 66: 36, 67: 37, 68: 38, 69: 39, 70: 40, 71: 41, 
                                         72: 42, 73: 43, 74: 44, 75: 45, 76: 46, 77: 47, 78: 48, 79: 49, 80: 50, 81: 51, 82: 52, 83: 53, 84: 54, 85: 55, 86: 56, 87: 57, 88: 58, 
                                         89: 59, 90: 60, 91: 64, 92: 61, 93: 62, 94: 63, 95: 64, 96: 65, 97: 66, 98: 67, 99: 68, 100: 69, 101: 70, 102: 71, 103: 72, 104: 73, 
                                         105: 74, 106: 75, 107: 76, 108: 77, 109: 78, 110: 79, 111: 80, 112: 81, 113: 82, 114: 86, 115: 83, 116: 84, 117: 85, 118: 86, 119: 87, 120: 88, 121: 89})},
      "KiraraBoots": {"Kirara": VGRemap({0: 0, 1: 14, 2: 15, 3: 16, 4: 17, 5: 18, 6: 19, 7: 20, 8: 21, 9: 22, 10: 23, 11: 27, 12: 28, 13: 31, 14: 32, 15: 33, 16: 34, 17: 35, 18: 36, 
                                         19: 37, 20: 38, 21: 39, 22: 40, 23: 41, 24: 42, 25: 43, 26: 44, 27: 57, 28: 58, 29: 59, 30: 60, 31: 61, 32: 62, 33: 63, 34: 64, 35: 65, 
                                         36: 66, 37: 67, 38: 68, 39: 69, 40: 70, 41: 71, 42: 72, 43: 73, 44: 74, 45: 75, 46: 76, 47: 77, 48: 78, 49: 79, 50: 80, 51: 81, 52: 82, 
                                         53: 83, 54: 84, 55: 85, 56: 86, 57: 87, 58: 88, 59: 89, 60: 90, 61: 92, 62: 93, 63: 94, 64: 95, 65: 96, 66: 97, 67: 98, 68: 99, 69: 100, 
                                         70: 101, 71: 102, 72: 103, 73: 104, 74: 105, 75: 106, 76: 107, 77: 108, 78: 109, 79: 110, 80: 111, 81: 112, 82: 113, 83: 115, 84: 116, 
                                         85: 117, 86: 118, 87: 119, 88: 120, 89: 121})},
      "Nilou": {"NilouBreeze": VGRemap({0: 48, 1: 48, 2: 52, 3: 56, 4: 56, 5: 56, 6: 10, 7: 11, 8: 12, 9: 13, 10: 16, 11: 17, 12: 18, 13: 19, 14: 20, 
                                              15: 21, 16: 22, 17: 23, 18: 24, 19: 25, 20: 30, 21: 31, 22: 32, 23: 35, 24: 36, 25: 37, 26: 78, 27: 16, 28: 
                                              16, 29: 21, 30: 78, 31: 41, 32: 42, 33: 43, 34: 78, 35: 44, 36: 45, 37: 46, 38: 48, 39: 48, 40: 49, 41: 50, 
                                              42: 99, 43: 122, 44: 47, 45: 69, 46: 62, 47: 69, 48: 69, 49: 52, 50: 48, 51: 49, 52: 50, 53: 51, 54: 3, 55: 52, 
                                              56: 53, 57: 54, 58: 55, 59: 8, 60: 56, 61: 57, 62: 58, 63: 122, 64: 59, 65: 60, 66: 61, 67: 61, 68: 62, 69: 63, 
                                              70: 64, 71: 64, 72: 65, 73: 66, 74: 67, 75: 68, 76: 68, 77: 69, 78: 70, 79: 71, 80: 72, 81: 72, 82: 73, 83: 74, 
                                              84: 75, 85: 76, 86: 78, 87: 79, 88: 80, 89: 81, 90: 82, 91: 83, 92: 84, 93: 85, 94: 86, 95: 87, 96: 88, 97: 89, 
                                              98: 90, 99: 91, 100: 92, 101: 93, 102: 94, 103: 95, 104: 96, 105: 97, 106: 98, 107: 99, 108: 100, 109: 101, 
                                              110: 102, 111: 103, 112: 104, 113: 105, 114: 106, 115: 107, 116: 108, 117: 109, 118: 110, 119: 111, 120: 112, 
                                              121: 113, 122: 114, 123: 115, 124: 116, 125: 117, 126: 118, 127: 119, 128: 120, 129: 121, 130: 122, 131: 123, 
                                              132: 124, 133: 125, 134: 126})},
      "NilouBreeze": {"Nilou": VGRemap({0: 50, 1: 52, 2: 53, 3: 54, 4: 134, 5: 55, 6: 57, 7: 58, 8: 59, 9: 134, 10: 6, 11: 7, 12: 8, 13: 9, 14: 64, 15: 67, 16: 10, 17: 11, 18: 12, 19: 
                                        13, 20: 14, 21: 15, 22: 16, 23: 17, 24: 18, 25: 19, 26: 86, 27: 86, 28: 86, 29: 86, 30: 20, 31: 21, 32: 22, 33: 21, 34: 21, 35: 23, 36: 24, 
                                        37: 25, 38: 24, 39: 24, 40: 26, 41: 31, 42: 32, 43: 33, 44: 35, 45: 36, 46: 37, 47: 44, 48: 50, 49: 51, 50: 52, 51: 53, 52: 55, 53: 56, 
                                        54: 57, 55: 58, 56: 60, 57: 61, 58: 62, 59: 64, 60: 65, 61: 66, 62: 68, 63: 69, 64: 70, 65: 72, 66: 73, 67: 74, 68: 75, 69: 77, 70: 78, 
                                        71: 79, 72: 80, 73: 82, 74: 83, 75: 84, 76: 85, 77: 64, 78: 86, 79: 87, 80: 88, 81: 89, 82: 90, 83: 91, 84: 92, 85: 93, 86: 94, 87: 95, 
                                        88: 96, 89: 97, 90: 98, 91: 99, 92: 100, 93: 101, 94: 102, 95: 103, 96: 104, 97: 105, 98: 106, 99: 107, 100: 108, 101: 109, 102: 110, 
                                        103: 111, 104: 112, 105: 113, 106: 114, 107: 115, 108: 116, 109: 117, 110: 118, 111: 119, 112: 120, 113: 121, 114: 122, 115: 123, 
                                        116: 124, 117: 125, 118: 126, 119: 127, 120: 128, 121: 129, 122: 130, 123: 131, 124: 132, 125: 133, 126: 134})}}}


class VGRemaps(ModAssets[Dict[str, VGRemap]]):
    """
    This class inherits from :class:`ModAssets`

    Class to handle Vertex Group Remaps fsor a mod

    Parameters
    ----------
    map: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        The `adjacency list`_  that maps the assets to fix from to the assets to fix to using the predefined mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, map: Optional[Dict[str, Set[str]]] = None):
        super().__init__(VGRemapData, map = map)

        self._versions: Dict[str, Dict[str, Version]] = {}
        self.loadFromPreset()

    @property
    def versions(self) -> Dict[str, Version]:
        """
        The game versions available for the assets :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the assets to map from
        * The inner keys are the names of the assets to map to
        * The inner values are versions for the assets

        :getter: Returns all the available game versions for the assets
        :type: Dict[:class:`str`, Dict[:class:`str`, :class:`Version`]]
        """

        return self._versions

    def _updateAssetContent(self, asset1: Dict[str, VGRemap], asset2: Dict[str, VGRemap]) -> T:
        return DictTools.update(asset1, asset2)

    def loadFromPreset(self):
        super().loadFromPreset()
        self._updateVersions(self._repo)
    
    def _addVersion(self, fromAsset: str, toAsset: str, version: float):
        """
        Adds a new version for a particular asset

        Parameters
        ----------
        name: :class:`str`
            The name of the asset

        version: :class:`float`
            The game version
        """

        try:
            self._versions[fromAsset]
        except KeyError:
            self._versions[fromAsset] = {}

        try:
            self._versions[fromAsset][toAsset]
        except KeyError:
            self._versions[fromAsset][toAsset] = Version()

        self._versions[fromAsset][toAsset].add(version)

    def findClosestVersion(self, fromAsset: str, toAsset: str, version: Optional[float] = None, fromCache: bool = True) -> float:
        """
        Finds the closest available game version from :attr:`ModStrAssets._toAssets` for a particular asset

        Parameters
        ----------
        fromAsset: :class:`str`
            The name of the asset to map from

        toAsset: :class:`str`
            The name of the asset to map to

        version: Optional[:class:`float`]
            The game version to be searched :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will assume we want the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fromCache: :class:`bool`
            Whether to use the result from the cache

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            The name for the particular asset is not found

        Returns
        -------
        :class:`float`
            The latest game version from the assets that corresponds to the desired version 
        """
        try:
            self._versions[fromAsset][toAsset]
        except KeyError as e:
            raise KeyError(f"Asset mapping from '{fromAsset}' to '{toAsset}' not found in the available versions") from e

        result = self._versions[fromAsset][toAsset].findClosest(version, fromCache = fromCache)
        if (result is None):
            KeyError("No available versions for the asset mapping")

        return result
    
    def get(self, fromAsset: str, toAsset: str, version: Optional[float] = None) -> str:
        """
        Retrieves the corresponding vertex group remap

        Parameters
        ----------
        fromAsset: :class:`str`
            The name of the asset to map from

        toAsset: :class:`str`
            The name of the asset to map to

        version: Optional[:class:`float`]
            The game version we want the remap to come from :raw-html:`<br />` :raw-html:`<br />`

            If This value is ``None``, then will retrieve the asset of the latest version. :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`KeyError`
            If the corresponding asset based on the search parameters is not found
            
        Returns
        -------
        :class:`str`
            The found asset
        """

        closestVersion = self.findClosestVersion(fromAsset, toAsset, version = version)
        result = self._repo[closestVersion][fromAsset][toAsset]
        return result

    def _updateVersions(self, assets: Dict[float, Dict[str, Dict[str, VGRemap]]]):
        assetNamesToUpdate = self.fixFrom.union(self.fixTo)

        for version, versionAssets in assets.items():
            for fromAssetName in versionAssets:
                if (fromAssetName not in assetNamesToUpdate):
                    continue

                fromAssets = versionAssets[fromAssetName]
                for toAssetName in fromAssets:
                    if (toAssetName not in assetNamesToUpdate):
                        continue

                    self._addVersion(fromAssetName, toAssetName, version)


class ListTools():
    """
    Tools for handling with Lists
    """

    @classmethod
    def getDistinct(cls, lst: List[Any], keepOrder: bool = False) -> List[Any]:
        """
        Makes all the elements in the list unique

        Parameters
        ----------
        lst: List[Any]
            The list we are working with

        keepOrder: bool
            Whehter to keep the order of the elements in the list :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        List[Any]
            The new list with only unique values
        """

        if (keepOrder):
            return list(OrderedDict.fromkeys(lst))
        return list(set(lst))
    

    @classmethod
    def removeParts(cls, lst: List[T], partIndices: List[Tuple[int, int]], nullifyRemoval: Callable[[], N], isNull: Callable[[Union[T, N]], bool]) -> List[T]:
        """
        Removes many sub-lists from a list

        Parameters
        ----------
        lst: List[T]
            The desired list to have its parts removed

        partIndices: List[Tuple[:class:`int`, :class:`int`]]:
            The indices relating to the parts to be removed from the lists :raw-html:`<br />` :raw-html:`<br />`

            The tuples contain:

                #. The starting index of the part
                #. The ending index of the part (excluded from the actual list)

        nullifyRemoval: Callable[[], N]:
            Function for creating a null element used to replace the removed part

        isNull: Callable[[Union[T, N]], :class:`bool`]
            Function for identifying whether an element in the list is the null element

        Returns
        -------
        List[T]
            The new list with its parts removed
        """

        null = nullifyRemoval()
        for indices in partIndices:
            startInd = indices[0]
            endInd = indices[1]
            lst[startInd:endInd] =  [null] * (endInd - startInd)

        lst = list(filter(lambda element: not isNull(element), lst))
        return lst
    
    @classmethod
    def removeByInds(cls, lst: List[T], inds: Set[int]) -> List[T]:
        """
        Removes many indices from a list

        Parameters
        ----------
        lst: List[T]
            The desired list to have its parts removed

        inds: Set[:class:`int`]
            The indices to the elements in the list that needs to be removed :raw-html:`<br />` :raw-html:`<br />`

        Returns
        -------
        List[T]
            The new list with elements specified by indices removed
        """

        return [element for ind, element in enumerate(lst) if ind not in inds]


class Heading():
    """
    Class for handling information about a heading for pretty printing

    Examples
    --------

    .. code-block:: python
        :linenos:
        :emphasize-lines: 1,3

        ======= Title: Fix Raiden Boss 2 =======
        ...
        ========================================

    Parameters
    ----------
    title: :class:`str`
        The title for the heading :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ""

    sideLen: :class:`int`
        The number of characters we want one side for the border of the opening heading to have :raw-html:`<br />` :raw-html:`<br />`

        **Default**: 0

    sideChar: :class:`str`
        The type of character we want the border for the heading to have  :raw-html:`<br />` :raw-html:`<br />`

        **Default**: "="

    Attributes
    ----------
    title: :class:`str`
        The title for the heading

    sideLen: :class:`int`
        The number of characters we want one side for the border of the opening heading to have

    sideChar: :class:`str`
        The type of character we want the border for the heading to have
    """

    def __init__(self, title: str = "", sideLen: int = 0, sideChar: str = "="):
        self.title = title
        self.sideLen = sideLen
        self.sideChar = sideChar

    def copy(self):
        """
        Makes a new copy of a heading

        Returns
        -------
        :class:`Heading`
            The new copy of the heading
        """
        return Heading(title = self.title, sideLen = self.sideLen, sideChar = self.sideChar)

    def open(self) -> str:
        """
        Makes the opening heading (see line 1 of the example at :class:`Heading`)

        Returns
        -------
        :class:`str`
            The opening heading created
        """

        side = self.sideLen * self.sideChar
        return f"{side} {self.title} {side}"

    def close(self) -> str:
        """
        Makes the closing heading (see line 3 of the example at :class:`Heading`)

        Returns
        -------
        :class:`str`
            The closing heading created
        """

        return self.sideChar * (2 * (self.sideLen + 1) + len(self.title))


class Builder(Generic[BuildCls]):
    """
    Class to dynamically create a new object

    Parameters
    ----------
    cls: Type[T]
        The class for the objects to be built from

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    cls: Type[T]
        The class for the objects to be built from

    args: List[Any]
        The constant arguments used to build the object

    kwargs: Dict[str, Any]
        The constant keyword arguments used to build the object
    """
    def __init__(self, cls: Type[BuildCls], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        self._cls = cls

        if (args is None):
            args = []
        self._args = args

        if (kwargs is None):
            kwargs = {}
        self._kwargs = kwargs

    def build(self, *args, **kwargs) -> BuildCls:
        """
        Builds the object

        Parameters
        ----------
        *args
            arguments to build the object

        **kwargs
            keyword arguments to build the object

        Returns
        -------
        T
            The built objects
        """

        return self._cls(*args, *self._args, **kwargs, **self._kwargs)


class BaseIniParser():
    """
    Base class to parse a .ini file

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to parse

    Attributes
    ----------
    _modsToFix: Set[:class:`str`]
        The name of the mods that will be fixed to

    _iniFile: :class:`IniFile`
        The .ini file that will be parsed
    """

    def __init__(self, iniFile: "IniFile"):
        self._modsToFix: Set[str] = set()
        self._iniFile = iniFile

    def clear(self):
        """
        Clears any saved data
        """
        self._modsToFix.clear()

    def parse(self):
        """
        Parses the .ini file
        """
        pass


class IniParseBuilder(Builder[BaseIniParser]):
    """
    This class inherits from :class:`Builder`

    A class to help dynamically build a :class:`BaseIniParser`

    Parameters
    ----------
    cls: Type[:class:`BaseIniParser`]
        The class to construct a :class:`BaseIniFixer` 

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, cls: Type[BaseIniParser], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        super().__init__(cls, args, kwargs)

    def build(self, iniFile: "IniFile") -> BaseIniParser:
        """
        Builds the parser

        Parameters
        ----------
        iniFile: :class:`IniFile`
            The .ini file to parse

        Returns
        -------
        :class:`BaseIniParser`
            The built parser
        """

        return super().build(iniFile)


class IniKeywords(Enum):
    """
    Common keywords used in the .ini file
    """

    Hash = "hash"
    """
    The unique id for a part in the mod
    """

    Vb1 = "vb1"
    """
    Vertex buffer #1
    """

    Handling = "handling"
    """
    Handling
    """

    Draw = "draw"
    """
    Location to draw a resource
    """

    Resource = "Resource"
    """
    The starting prefix used for any `sections`_ that reference some file
    """

    Blend = "Blend"
    """
    The substring that usually occurse in the name of `section`_ to indicate that the `section`_ will call some *.Blend.buf file
    """

    Run = "run"
    """
    The subsection that will be called from a certain `section`_
    """

    MatchFirstIndex = "match_first_index"
    """
    The index location to map some resource
    """

    RemapBlend = f"Remap{Blend}"
    """
    The substring used to indicate that the `section`_ references some *.RemapBlend.buf file
    """

    RemapFix = f"RemapFix"
    """
    The substring used to indicate that the `section`_ was created by this program 
    """

    RemapTex = f"RemapTex"
    """
    The substring used to indicate that the `section`_ contains some editted/created texture *.Remap.dds file
    """

    Filename = f"filename"
    """
    The filename for some resource
    """

    HashNotFound = "HashNotFound"
    """
    The hash for a mod has not been found
    """

    IndexNotFound = "IndexNotFound"
    """
    The index for a mod has not been found
    """

    ORFixPath = r"CommandList\global\ORFix\ORFix"
    """
    The sub command call to `ORFix`_
    """


class IniBoilerPlate(Enum):
    """
    Boilerplate constants used for fixing a .ini file    

    Attributes
    ----------
    ShortModTypeNameReplaceStr: :class:`str`
        Placeholder for the shortened name of the mod to fix

    ModTypeNameReplaceStr: :class:`str`
        Placeholder for the name of the mod to fix

    Credit: :class:`str`
        The credit text used in the .ini file

    OldHeading: :class:`Heading`
        The heading used for .ini files fixed by an older version of this software

    DefaultHeading: :class:`Heading`
        The current heading used when fixing .ini files
    """

    ShortModTypeNameReplaceStr = "{{shortModTypeName}}"
    ModTypeNameReplaceStr = "{{modTypeName}}"
    Credit = f'\n; {ModTypeNameReplaceStr}remapped by NK#1321 and Albert Gold#2696. If you used it to remap your {ShortModTypeNameReplaceStr}mods pls give credit for "Nhok0169" and "Albert Gold#2696"\n; Thank nguen#2011 SilentNightSound#7430 HazrateGolabi#1364 for support'

    OldHeading = Heading(".*Boss Fix", 15, "-")
    DefaultHeading = Heading(".*Remap", 15, "-")


class IniComments(Enum):
    GIMIObjMergerPreamble = """; This is really bad!! Don't do this!
; ************************************
;
; jk, but joking aside...
;
; The goal is to display n mod objects from the mod to be remapped to the mod onto a single mod object of the remapped mod.
;   Therefore we will have n sets of resources all mapping onto a single index (and same hash).
;
; Ideally, we would want all the sections to be within a single .ini file. The naive approach would be to create n sets of sections
;   (not a single section, cuz you need to include the case of sections depending on other sections, which form a section caller/callee graph) 
;    where the sections names are all unique. However, this approach will trigger a warning on GIMI (or any GIMI like importer) of multiple sections
;   mapping to the same hash and only 1 of the mod objects will be displayed
;
; The next attempt would be to take advantage of GIMI's overlapping mod bug/feature from loading multiple mods of the same character
;   Apart from the original .ini file, there would be n-1 newly generated .ini files (total of n .ini files). Each .ini file would uniquely
;   display a single set of sections from the n sets of sections. The overlapping property from the bug/feature would allow for all the objects to be displayed.
;
; For now, we were lazy and just simply copied the original .ini file onto the generated .ini files, which results in the original mod to have overlapping copies.
;  But since the mod used in all the .ini files are exactly the same, the user would not see the overlap (they may have some performance issues depending on the size of n. But
;   usually remaps only merge 2 mod objects into a single mod object, which should not cause much of an issue)
;   We could optimize the amount of space taken up by the newly generated .ini files, by only putting the necessary sections, but that is for another day..."""


class IfPredPartType(Enum):
    """
    Enum for the possible types for an :class:`IfPredPart`
    """

    If = "if"
    """
    The part contains the staring keyword 'if'
    """

    Else = "else"
    """
    The part contains the staring keyword 'else'
    """

    Elif = "elif"
    """
    The part contains the starting keyword 'elif'
    """

    EndIf = "endif"
    """
    The part contains the staring keyword 'endif'
    """

    @classmethod
    def getType(cls, rawPredPart: str):
        """
        Retrieves the type for an :class:`IfPredPart`

        Parameters
        ----------
        rawPredPart: :class:`str`
            The predicate string for the :class:`IfPredPart`

        Returns
        -------
        Optional[:class:`IfPredPartType`]
            The type found based off 'rawPredPart'
        """

        cleanedRawPart = rawPredPart.strip().lower()

        if (cleanedRawPart.startswith(cls.If.value)):
            return cls.If
        elif (cleanedRawPart.startswith(cls.EndIf.value)):
            return cls.EndIf
        elif (cleanedRawPart.startswith(cls.Else.value)):
            return cls.Else
        elif (cleanedRawPart.startswith(cls.Elif.value)):
            return cls.Elif
        return None


class IfTemplatePart():
    """
    Base class for some part in an :class:`IfTemplates`    
    """

    def toStr(self) -> str:
        """
        Retrieves the part as a string

        Returns
        -------
        :class:`str`
            The string representation of the part        
        """

        pass


class IfPredPart(IfTemplatePart):
    """
    This class inherits from :class:`IfTemplatePart`

    Class for defining the predicate part of an :class:`IfTemplate`

    .. note::
        see :class:`IfTemplate` for more details

    Parameters
    ----------
    pred: :class:`str`
        The predicate string within the :class:`IfTemplate`

    type: :class:`IfPredPartType`
        The type of predicate encountered

    Attributes
    ----------
    pred: :class:`str`
        The predicate string within the :class:`IfTemplate`

    type: :class:`IfPredPartType`
        The type of predicate encountered
    """

    def __init__(self, pred: str, type: IfPredPartType):
        self.pred = pred
        self.type = type


    def toStr(self) -> str:
        return f"{self.pred}"


class IfContentPart(IfTemplatePart):
    """
    This class inherits from :class:`IfTemplatePart`

    Class for defining the content part of an :class:`IfTemplate`

    .. note::
        see :class:`IfTemplate` for more details

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: key in x

            Determines if 'key' exists in the content part of the :class:`IfContentPart`

        .. describe:: x[key]

            Retrieves the corresponding data value from the :class:`IfContentPart` based off 'key' :raw-html:`<br />` :raw-html:`<br />`

            * If 'key' is an :class:`int`, then will retrieve a tuple containing:

                #. The corresponding key for the `KVP`_ found
                #. The corresponding value to the found `KVP`_
                #. The occurence index for the key of the `KVP`_

            * Otherwise, will retrieve the corresponding value from :meth:`IfContentPart.src`

        .. describe:: for key, val, keyInd, orderInd in x

            Iterates over all the key/value initializations and updates within the :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:

            #. key: (:class:`str`) A particular key in the :class:`IfContentPart`
            #. val: (:class:`str`) The corresponding value to the key
            #. keyInd: (:class:`int`) The occurence index of the same key within the :class:`IfContentPart`
            #. orderInd: (:class:``int) The order index the `KVP`_ appears in the overall :class:`IfContentPart`

    Parameters
    ----------
    src: Dict[:class:`str`, List[Tuple[:class:`int`, :class:`str`]]]
        The source for the part in the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the keys in the part
        * The values are the coresponding values for the keys for all instances where the particular key got instantiated/updated. Each element in the list contains:

            #. The order index the `KVP`_ was called within the part
            #. The value of the `KVP`_

    depth: :class:`int`
        The depth the part is within the :class:`IfTemplate`

    Attributes
    ----------
    src: Dict[:class:`str`, List[Tuple[:class:`int`, :class:`str`]]]
        The source for the part in the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the keys in the part
        * The values are the coresponding values for the keys for all instances where the particular key got instantiated/updated. Each element in the list contains:
            #. The order index the `KVP`_ was called within the part
            #. The value of the `KVP`_

    depth: :class:`int`
        The depth the part is within the :class:`IfTemplate`

    _order: List[Tuple[:class:`str`, :class:`int`]]
        The order the `KVP`_s appear in the part. The elements contain:
            #. The name of the key for the `KVP`_
            #. The occurence index of the key within the part
    """

    def __init__(self, src: Dict[str, List[Tuple[int, str]]], depth: int):
        self._order: List[Tuple[str, int]] = []
        self.src = src
        self.depth = depth

    def __iter__(self):
        for key, keyInd in self._order:
            valTuple = self.src[key][keyInd]
            orderInd = valTuple[0]
            val = valTuple[1]
            result = (key, val, keyInd, orderInd)
            yield result

    def __contains__(self, key: str):
        return key in self.src

    def __getitem__(self, key: Union[str, int]) -> Union[List[Tuple[int, str]], str]:
        if (isinstance(key, int)):
            kvpRef = self._order[key]
            val = self.src[kvpRef[0]][kvpRef[1]]
            return (kvpRef[0], val, kvpRef[1])

        return self.src[key]

    @property
    def src(self):
        """
        The raw content of the part :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the keys in the content part of the :class:`IfTemplate`. Note that the same key can appear multiple times in a particular content part.
        * The values consists of:
            #. The order index the `KVP`_ appeared in the :class:`IfContentPart`
            #. The corresponding value for the key

        :getter: Retrieves the raw content of the part
        :setter: Sets the raw content for the part
        :type: Dict[:class:`str`, List[:class:`int`, :class:`str`]]
        """

        return self._src
    
    @src.setter
    def src(self, newSrc: Dict[str, List[Tuple[int, str]]]):
        self._src = newSrc
        self._setupOrder()

    def _setupOrder(self):
        self._order = []
        for key in self.src:
            values = self.src[key]
            valuesLen = len(values)
            for i in range(valuesLen):
                orderInd, _ = values[i]
                keyRef = (key, i, orderInd)
                Algo.binaryInsert(self._order, keyRef, lambda keyRef1, keyRef2: keyRef1[2] - keyRef2[2])

        self._order = list(map(lambda orderData: orderData[:-1], self._order))

    def __contains__(self, key):
        return key in self.src

    def toStr(self, linePrefix: str = "") -> str:
        """
        Retrieves the part as a string

        Parameters
        ----------
        linePrefix: :class:`str`
            The string that will prefix every line :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The string representation of the part        
        """

        result = ""
        orderLen = len(self._order)
        i = 0
        for key, val, keyInd, orderInd in self:
            result += f"{linePrefix}{key} = {val}"
            if (i < orderLen - 1):
                result += "\n"
            i += 1

        return result
    
    def getVals(self, key: str) -> List[str]:
        """
        Retrieves the corresponding values based off 'key'
        
        Parameters
        ----------
        key: :class:`str`
            The key to the values belong to

        Returns
        -------
        List[:class:`str`]
            The corresponding values found for the key
        """

        result = []

        values = None
        try:
            values = self._src[key]
        except KeyError:
            return result
        
        result = list(map(lambda valData: valData[1], values))
        return result
    
    def removeKey(self, key: str):
        """
        Removes a key from the part

        .. attention::
            The runtime of this operation is O(n), where 'n' is the \# of `KVP`_s in this part.
            If you want to remove multiple keys, please use :meth:`IfContentPart.removeKeys` which also has O(n) runtime. 
            (faster than using a for loop to run this function, which will be O(n^2) runtime)

        Parameters
        ----------
        key: :class:`str`
            The key to remove
        """

        orderIndsToRemove = set()
        values = None
        try:
            values = self.src[key]
        except KeyError:
            return
        
        for value in values:
            orderIndsToRemove.add(value[0])

        del self.src[key]
        self._order = ListTools.removeByInds(self._order, orderIndsToRemove)

        # update the order indices
        orderLen = len(self._order)
        for i in range(orderLen):
            orderData = self._order[i]
            self.src[orderData[0]][orderData[1]][0] = i

    def removeKeys(self, keys: Set[str]):
        """
        Removes multiple keys from the part

        Parameters
        ----------
        keys: Set[:class:`str`]
            The keys to remove
        """

        orderIndsToRemove = set()

        for key in keys:
            values = None
            try:
                values = self.src[key]
            except KeyError:
                continue
            
            for value in values:
                orderIndsToRemove.add(value[0])
            
            del self.src[key]

        if (not orderIndsToRemove):
            return
        
        self._order = ListTools.removeByInds(self._order, orderIndsToRemove)

        # update the order indices
        orderLen = len(self._order)
        for i in range(orderLen):
            orderData = self._order[i]
            valData = self.src[orderData[0]][orderData[1]]
            self.src[orderData[0]][orderData[1]] = (i, valData[1])

    def addKVP(self, key: str, value: str):
        """
        Adds a new `KVP`_ into the part

        Parameters
        ----------
        key: :class:`str`
            The name of the key

        value: :class:`str`
            The corresponding value to the key
        """

        try:
            self.src[key]
        except KeyError:
            self.src[key] = []
        
        valData = (len(self._order), value)
        self.src[key].append(valData)
        self._order.append((key, len(self.src[key]) - 1))

    def replaceVals(self, newVals: Dict[str, Union[str, List[str]]], addNewKVPs: bool = True):
        """
        Replaces the values in the `KVP`_s of the parts or adds in new `KVP`_s if the original key did not exist

        Parameters
        ----------
        newVals: Dict[:class:`str`, Union[:class:`str`, List[:class:`str`]]]
            The new values for the `KVP`_s in the parts :raw-html:`<br />` :raw-html:`<br />`

            The keys are the corresponding keys for the `KVP`_s and the values are the new values of the `KVP`_s

        addNewKVPs: :class:`bool`
            Whether to add new KVPs if the corresponding key in 'newVals' does not exist :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        for key in newVals:
            vals = newVals[key]

            currentVals = None
            try:
                currentVals = self.src[key]
            except KeyError:
                if (not addNewKVPs):
                    continue

                if (isinstance(vals, str)):
                    self.addKVP(key, vals)
                else:
                    for val in vals:
                        self.addKVP(key, val)

                continue

            if (isinstance(vals, str)):
                self.src[key] = list(map(lambda valData: (valData[0], vals), currentVals))
                continue

            smallerValLen = min(len(currentVals), len(vals))
            for i in range(smallerValLen):
                self.src[key][i][1] = vals[i]

    def remapKeys(self, keyRemap: Dict[str, List[str]]):
        """
        Remaps the keys in the `KVP`_s of the parts

        Parameters
        ----------
        keyRemap: Dict[:class:`str`, List[:class:`str`]]
            The remap for the keys :raw-html:`<br />` :raw-html:`<br />`

            The keys are the old names of the keys to be remapped and the values are the new names of the keys to be remapped to

            .. warning::
                Recommeded that the new names in each list to be unique. Otherwise, this function will make each list to have unique values.
        """

        occurences = defaultdict(lambda: 0)
        i = 0
        orderLen = len(self._order)
        remappedSrc = defaultdict(lambda: [])
        keysToRemove = set()
        keysToAdd = set()

        # "ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"]

        # contruct the order
        while (i < orderLen):
            keyData = self._order[i]
            key = keyData[0]
            currentKeyOccurence = keyData[1]
            keyOccurence = occurences[key]

            # update the occurence of the key
            if (currentKeyOccurence < keyOccurence and keyOccurence < len(self._src[key])):
                self._order[i] = (key, keyOccurence)
                occurences[key] += 1
            elif (currentKeyOccurence > keyOccurence):
                occurences[key] = currentKeyOccurence

            if (key not in keyRemap):
                i += 1
                continue
            else:
                keysToRemove.add(key)
            
            newKeys = keyRemap[key]
            newKeysLen = len(newKeys)
            newKeyRefs = []

            # construct the remapped keys
            for j in range(newKeysLen):
                newKey = newKeys[j]
                newKeyOccurence = occurences[newKey]
                newKeyRefs.append((newKey, newKeyOccurence))

                oldValData = self.src[key][currentKeyOccurence]
                oldVal = oldValData[1]

                remappedSrc[newKey].append((i + j, oldVal))
                keysToAdd.add(newKey)
                occurences[newKey] += 1

            self._order = self._order[:i] + newKeyRefs + self._order[i + 1:]

            newRefsLen = len(newKeyRefs)
            i += newRefsLen
            orderLen += (newRefsLen - 1)

        # remove the keys that do not appear after the remap
        keysToRemove = keysToRemove.difference(keysToAdd)
        for key in keysToRemove:
            del self.src[key]
                
        # construct the new src
        DictTools.update(self.src, remappedSrc, lambda srcVals, remappedVals: remappedVals)


# IfTemplate: Data class for the if..else template of the .ini file
class IfTemplate():
    """
    Data for storing information about a `section`_ in a .ini file

    :raw-html:`<br />`

    .. note::
        Assuming every `if/else` clause must be on its own line, we have that an :class:`IfTemplate` have a form looking similar to this:

        .. code-block:: ini
            :linenos:
            :emphasize-lines: 1,2,5,7,12,16,17

            ...(does stuff)...
            ...(does stuff)...
            if ...(bool)...
                if ...(bool)...
                    ...(does stuff)...
                else if ...(bool)...
                    ...(does stuff)...
                endif
            else ...(bool)...
                if ...(bool)...
                    if ...(bool)...
                        ...(does stuff)...
                    endif
                endif
            endif
            ...(does stuff)...
            ...(does stuff)...

        We split the above structure into parts (:class:`IfTemplatePart`) where each part is either:

        #. **An If Predicate Part (:class:`IfPredPart`)**: a single line containing the keywords "if", "else" or "endif" :raw-html:`<br />` **OR** :raw-html:`<br />`
        #. **A Content Part (:class:`IfContentPart`)**: a group of lines that *"does stuff"*

        **Note that:** an :class:`ifTemplate` does not need to contain any parts containing the keywords "if", "else" or "endif". This case covers the scenario
        when the user does not use if..else statements for a particular `section`_
        
        Based on the above assumptions, we can assume that every ``[section]`` in a .ini file contains this :class:`IfTemplate`

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for element in x

            Iterates over all the parts of the :class:`IfTemplate`, ``x``

        .. describe:: x[num]

            Retrieves the part from the :class:`IfTemplate`, ``x``, at index ``num``

        .. describe:: x[num] = newPart

            Sets the part at index ``num`` of the :class:`IfTemplate`, ``x``, to have the value of ``newPart``

    :raw-html:`<br />`

    Parameters
    ----------
    parts: List[:class:`IfTemplatePart`]
        The individual parts of how we divided an :class:`IfTemplate` described above

    name: :class:`str`
        The name of the `section`_ for this :class:`IfTemplate`

        **Default**: ``""``

    Attributes
    ----------
    parts: List[:class:`IfTemplatePart`]
        The individual parts of how we divided an :class:`IfTemplate` described above

    calledSubCommands: Dict[:class:`int`, List[:class:`str`]]
        Any other sections that this :class:`IfTemplate` references :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` in the :class:`IfTemplate` that the section is called
        * The values are the referenced sections within the :class:`IfContentPart`

    hashes: Set[:class:`str`]
        The hashes this :class:`IfTemplate` references

    indices: Set[:class:`str`]
        The indices this :class:`IfTemplate` references
    """

    def __init__(self, parts: List[IfTemplatePart], name: str = ""):
        self.name = name
        self.parts = parts

        self.calledSubCommands = {}
        self.hashes = set()
        self.indices = set()

        self.find(pred = self._hasNeededAtts, postProcessor = self._setupIfTemplateAtts)

    def _hasNeededAtts(self, ifTemplate, partIndex: int, part: IfTemplatePart) -> bool:
        return isinstance(part, IfContentPart) and (IniKeywords.Run.value in part or IniKeywords.Hash.value in part or IniKeywords.MatchFirstIndex.value in part)
    
    def _setupIfTemplateAtts(self, ifTemplate, partIndex: int, part: IfContentPart):
        if (IniKeywords.Run.value in part):
            ifTemplate.calledSubCommands[partIndex] = part[IniKeywords.Run.value]
        
        if (IniKeywords.Hash.value in part):
            ifTemplate.hashes.update(set(map(lambda valData: valData[1], part[IniKeywords.Hash.value])))

        if (IniKeywords.MatchFirstIndex.value in part):
            ifTemplate.indices.update(set(map(lambda valData: valData[1], part[IniKeywords.MatchFirstIndex.value])))

    @classmethod
    def build(cls, rawParts: List[Union[str, Dict[str, List[Tuple[int, str]]]]], name: str = ""):
        parts = []
        rawPartsLen = len(rawParts)
        depth = 0

        for i in range(rawPartsLen):
            rawPart = rawParts[i]
            part = None

            if (isinstance(rawPart, str)):
                predType = IfPredPartType.getType(rawPart)
                if (predType is None):
                    continue
                elif (predType == IfPredPartType.If):
                    depth += 1
                elif (predType == IfPredPartType.EndIf):
                    depth -= 1

                part = IfPredPart(rawPart, predType)

            elif (isinstance(rawPart, dict)):
                part = IfContentPart(rawPart, depth)

            if (part is not None):
                parts.append(part)

        return cls(parts, name = name)


    def __iter__(self):
        return self.parts.__iter__()
    
    def __getitem__(self, key: int) -> Union[str, Dict[str, Any]]:
        return self.parts[key]
    
    def __setitem__(self, key: int, value: Union[str, Dict[str, Any]]):
        self.parts[key] = value

    def add(self, part: Union[str, Dict[str, Any]]):
        """
        Adds a part to the :class:`ifTemplate`

        Parameters
        ----------
        part: Union[:class:`str`, Dict[:class:`str`, Any]]
            The part to add to the :class:`IfTemplate`
        """
        self.parts.append(part)

    # find(pred, postProcessor): Searches each part in the if template based on 'pred'
    def find(self, pred: Optional[Callable[[int, IfTemplatePart], bool]] = None, postProcessor: Optional[Callable[[int, IfTemplatePart], Any]] = None) -> Dict[int, Any]:
        """
        Searches the :class:`IfTemplate` for parts that meet a certain condition

        Parameters
        ----------
        pred: Optional[Callable[[:class:`IfTemplate`, :class:`int`, :class:`IfTemplatePart`], :class:`bool`]]
            The predicate used to filter the parts :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then this function will return all the parts :raw-html:`<br />` :raw-html:`<br />`

            The order of arguments passed into the predicate will be:

            #. The :class:`IfTemplate` that this method is calling from
            #. The index for the part in the :class:`IfTemplate`
            #. The current part of the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        postProcessor: Optional[Callable[[:class:`IfTemplate`, :class:`int`, :class:`IfTemplatePart`], Any]]
            A function that performs any post-processing on the found part that meets the required condition :raw-html:`<br />` :raw-html:`<br />`

            The order of arguments passed into the post-processor will be:

            #. The :class:`IfTemplate` that this method is calling from
            #. The index for the part in the :class:`IfTemplate`
            #. The current part of the :class:`IfTemplate` :raw-html:`<br />` :raw-html:`<br />`
        
            **Default**: ``None``

        Returns
        -------
        Dict[:class:`int`, Any]
            The filtered parts that meet the search condition :raw-html:`<br />` :raw-html:`<br />`

            The keys are the index locations of the parts and the values are the found parts
        """

        result = {}
        if (pred is None):
            pred = lambda ifTemplate, partInd, part: True

        if (postProcessor is None):
            postProcessor = lambda ifTemplate, partInd, part: part

        partsLen = len(self.parts)
        for i in range(partsLen):
            part = self.parts[i]
            if (pred(self, i, part)):
                result[i] = (postProcessor(self, i, part))

        return result
    
    def getMods(self, hashRepo: Hashes, indexRepo: Indices, version: Optional[float] = None) -> Set[str]:
        """
        Retrieves the corresponding mods the :class:`IfTemplate` will fix to

        Parameters
        ----------
        hashRepo: :class:`Hashes`
            The data source for the hashes

        indexRepo: :class:`Indices`
            The data source for the indices

        version: Optional[:class:`float`]
            What version we want to fix :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, will assume we want to fix to the latest version :raw-html:`<br />` :raw-html:`<br />`
            
             **Default**: ``None``

        Returns
        -------
        Set[:class:`str`]
            Names of all the types of mods the :class:`IfTemplate` will fix to
        """

        result = set()

        for hash in self.hashes:
            replacments = hashRepo.replace(hash, version = version)
            result = result.union(set(replacments.keys()))

        for index in self.indices:
            replacments = indexRepo.replace(index, version = version)
            result = result.union(set(replacments.keys()))

        return result


class IniSectionGraph():
    """
    Class for constructing a directed subgraph for how the `sections`_ in the .ini file are ran

    :raw-html:`<br />`

    .. note::
        * The nodes are the `sections`_ of the .ini file
        * The directed edges are the command calls from the `sections`_ , where the source of the edge is the caller and the sink of the edge is the callee

    Parameters
    ----------
    sections: Set[:class:`str`]
        Names of the desired `sections`_ we want our subgraph to have from the `sections`_ of the .ini file

    allSections: Dict[:class:`str`, :class:`IfTemplate`]
        All the `sections`_ for the .ini file

        :raw-html:`<br />`

        .. note::
            You can think of this as the `adjacency list`_ for the directed graph of all `sections`_ in the .ini file

    remapNameFunc: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
        Function to get the corresponding remap names for the section names :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will not get the remap names for the sections :raw-html:`<br />` :raw-html:`<br />`

        The parameters for the function are:

            #. Name of the `section`_
            #. Name fo the type of mod to fix
        
        **Default**: ``False``

    modsToFix: Optional[Set[:class:`str`]]
        The names of the mods that will be fixed by the .ini file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    remapNameFunc: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
        Function to get the corresponding remap names for the section names :raw-html:`<br />` :raw-html:`<br />`

        The parameters for the function are:

            #. Name of the `section`_
            #. Name fo the type of mod to fix
    """

    def __init__(self, targetSections: Union[Set[str], List[str]], allSections: Dict[str, IfTemplate], 
                 remapNameFunc: Optional[Callable[[str, str], str]] = None, modsToFix: Optional[Set[str]] = None):
        self._modsToFix = modsToFix
        if (modsToFix is None):
            self._modsToFix = {}
        
        self._setTargetSections(targetSections)
        self._sections: Dict[str, IfTemplate] = {}
        self._allSections = allSections
        self._remapNames: Dict[str, Dict[str, str]] = {}
        self._runSequence: List[Tuple[str, IfTemplate]] = []
        self.remapNameFunc = remapNameFunc

        self.build()

    @property
    def targetSections(self):
        """
        Names of the desired `sections`_ we want our subgraph to have from the `sections`_ of the .ini file

        :getter: The names of the desired `sections`_ we want in the subgraph
        :setter: Constructs a new subgraph based on the new desired `sections`_ we want
        :type: List[:class:`str`]
        """

        return self._targetSections
    
    def _setTargetSections(self, newTargetSections: Union[Set[str], List[str]]):
        self._targetSections = ListTools.getDistinct(newTargetSections, keepOrder = True)
    
    @targetSections.setter
    def targetSections(self, newTargetSections: Union[Set[str], List[str]]):
        self._setTargetSections(newTargetSections)
        self.build()

    @property
    def sections(self):
        """
        The `sections`_ that are part of the contructed subgraph based on the desired sections specified at :attr:`IniSectionGraph.targetSections`

        :raw-html:`<br />`

        .. note::
            You can think of this as the `adjacency list`_ for the subgraph

        :getter: All the `sections`_ for the subgraph
        :type: Dict[:class:`str`, :class:`IfTemplate`]
        """

        return self._sections
    
    @property
    def allSections(self):
        """
        All the `sections`_ of the .ini file

        :raw-html:`<br />`

        .. note::
            You can think of this as the `adjacency list`_ for the directed graph of all `sections`_ in the .ini file

        :getter: All the `sections`_ for the .ini file
        :setter: Constructs a new subgraph based on the new `sections`_ for the .ini file
        :type: Dict[:class:`str`, :class:`IfTemplate`]
        """

        return self._allSections
    
    @allSections.setter
    def allSections(self, newAllSections: Dict[str, IfTemplate]):
        self._allSections = newAllSections
        self.build()

    @property
    def remapNames(self):
        """
        The corresponding names for the `sections`_ that the fix will make :raw-html:`<br />` :raw-html:`<br />`

        * The outer key is the name of the original `section`_
        * The inner key is the name for the type of mod to fix
        * The inner value is the corresponding name for the `section`_ and mod type

        :getter: All the corresponding names for the `sections`_
        :type: Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]
        """

        return self._remapNames
    
    @property
    def runSequence(self):
        """
        The order the `sections`_ will be ran

        :getter: Retrieves the order the `sections`_ will be ran
        :type: List[Tuple[:class:`str`, :class:`IfTemplate`]]
        """

        return self._runSequence
    
    @property
    def modsToFix(self):
        """
        The names of the mods that will be fixed by the .ini file

        :getter: Retrieves the names of the mods to fix
        :type: Set[:class:`str`]
        """

        return self._modsToFix

    def build(self, newTargetSections: Optional[Union[Set[str], List[str]]] = None, newAllSections: Optional[Dict[str, IfTemplate]] = None,
              newModsToFix: Optional[Set[str]] = None):
        """
        Performs the initialization for rebuilding the subgraph

        Parameters
        ----------
        newTargetSections: Optional[Set[:class:`str`], List[:class:`str`]]
            The new desired `sections`_ we want in our subgraph :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newAllSections: Optional[Dict[:class:`str`, :class:`IfTemplate`]]
            The new `sections`_ for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newModsToFix: Optional[Set[:class:`str`]]
            The new desired names of the mods that we want to fix for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (newTargetSections is not None):
            self._setTargetSections(newTargetSections)

        if (newAllSections is not None):
            self._allSections = newAllSections

        self.construct()
        if (self.remapNameFunc is not None):
            self.getRemapBlendNames(newModsToFix = newModsToFix)
        else:
            self._remapNames = {}


    def getSection(self, sectionName: str, raiseException: bool = True) -> Optional[IfTemplate]:
        """
        Retrieves the :class:`IfTemplate` for a certain `section`_

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_

        raiseException: :class:`bool`
            Whether to raise an exception when the section's :class:`IfTemplate` is not found

        Raises
        ------
        :class:`KeyError`
            If the :class:`IfTemplate` for the `section`_ is not found and ``raiseException`` is set to ``True``

        Returns
        -------
        Optional[:class:`IfTemplate`]
            The corresponding :class:`IfTemplate` for the `section`_
        """
        try:
            ifTemplate = self._allSections[sectionName]
        except Exception as e:
            if (raiseException):
                raise KeyError(f"The section by the name '{sectionName}' does not exist") from e
            else:
                return None
        else:
            return ifTemplate

    def _dfsExplore(self, section: IfTemplate, visited: Dict[str, IfTemplate], runSequence: List[Tuple[str, IfTemplate]]):
        """
        The typical recursive implementation of `DFS`_ for exploring a particular `section`_ (node)

        Parameters
        ----------
        section: :class:`IfTemplate`
            The `section`_ that is currently being explored
        
        visited: Dict[:class:`str`, :class:`ifTemplate`]
            The `sections`_ that have already been visited

        runSequence: List[Tuple[:class:`str`, :class:`IfTemplate`]]
            The order the `sections`_ will be ran
        """

        calledSubCommands = section.calledSubCommands
        for partInd in calledSubCommands:
            subSections = calledSubCommands[partInd]

            for subSectionData in subSections:
                subSection = subSectionData[1]
                if (subSection not in visited):

                    # we assume the .ini file has correct syntax and does not reference some
                    #   command that does not exist. It is not within this project's scope to help the
                    #   person fix their own mistakes in the .ini file. Assume that an incorrect referenced
                    #   command refers to some global command not in the file. So this command will be a sink in the
                    #   command call graph and a leaf in the DFS tree 
                    neighbourSection = self.getSection(subSection, raiseException = False)
                    if (neighbourSection is None):
                        continue

                    visited[subSection] = neighbourSection
                    
                    runSequence.append((subSection, neighbourSection))
                    self._dfsExplore(neighbourSection, visited, runSequence)

    def construct(self) -> Dict[str, IfTemplate]:
        """
        Constructs the subgraph for the `sections`_ using `DFS`_

        Returns
        -------
        Dict[:class:`str`, :class:`IfTemplate`]
            The `sections` that are part of the subgraph
        """

        visited = {}
        runSequence = []
        sections = {}

        for sectionName in self._targetSections:
            ifTemplate = self.getSection(sectionName)
            sections[sectionName] = ifTemplate

        # perform the main DFS algorithm
        for sectionName in sections:
            section = sections[sectionName]

            if (sectionName not in visited):
                visited[sectionName] = section
                runSequence.append((sectionName, section))
                self._dfsExplore(section, visited, runSequence)

        self._sections = visited
        self._runSequence = runSequence
        return self._sections

    def getRemapBlendNames(self, newModsToFix: Optional[Set[str]] = None) -> Dict[str, Dict[str, str]]:
        """
        Retrieves the corresponding remap names of the sections made by this fix

        Parameters
        ----------
        newModsToFix: Optional[Set[:class:`str`]]
            The new desired names of the mods that we want to fix for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[:class:`str`, :class:`str`]
            The new names for the `sections`_ with the 'FixRemap' keyword added
        """

        result = {}
        if (newModsToFix is not None):
            self._modsToFix = newModsToFix

        if (not self._modsToFix):
            self._remapNames = result
            return result

        for sectionName in self._sections:
            for modName in self._modsToFix:
                try:
                    result[sectionName]
                except KeyError:
                    result[sectionName] = {}

                result[sectionName][modName] = self.remapNameFunc(sectionName, modName)

        self._remapNames = result
        return result
    
    def getCommonMods(self, hashRepo: Hashes, indexRepo: Indices, version: Optional[float] = None) -> Set[str]:
        """
        Retrieves the common mods to fix to based off all the :class:`IfTemplate`s in the graph

        Parameters
        ----------
        hashRepo: :class:`Hashes`
            The data source for all the hashes

        indexRepo: :class:`Indices`
            The data source for all the indices

        version: Optional[:class:`float`]
            The version we want to fix to :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will assume we want to fix to the latest version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Set[:class:`str`]
            The common mods to fix to
        """

        result = set()

        for sectionName in self._sections:
            ifTemplate = self._sections[sectionName]
            ifTemplateMods = ifTemplate.getMods(hashRepo, indexRepo, version = version)

            if (not result):
                result = ifTemplateMods
            elif (ifTemplateMods):
                result = result.intersection(ifTemplateMods)

        return result


class FilePrefixes(Enum):
    OldBackupFilePrefix = "DISABLED_BossFixBackup_"
    BackupFilePrefix = "DISABLED_RemapBackup_"
    DuplicateFilePrefix = "DISABLED_RSDup_"


class FilePathConsts():
    DefaultPath = os.getcwd()
    CurrentDir = "."

    @classmethod
    def getPath(cls, path: Optional[str]) -> str:
        if (path is None):
            return cls.DefaultPath
        return path


class FileEncodings(Enum):
    UTF8 = "utf-8"
    Latin1 = "latin1"


IniFileEncoding = FileEncodings.UTF8.value
ReadEncodings = [IniFileEncoding, FileEncodings.Latin1.value]


class FilePath():
    """
    Class for storing info about a file path

    Parameters
    ----------
    path: :class:`str`
        The file path
    """

    def __init__(self, path: str):
        self._folder = ""
        self._base = ""
        self._baseName = ""
        self.path = path

    @property
    def path(self):
        """
        The file path

        :getter: Retrieves the path
        :setter: Sets a new path
        :type: :class:`str`
        """
        return self._path
    
    @path.setter
    def path(self, newPath: str):
        self._path = newPath
        self._folder = os.path.dirname(newPath)
        self._base = os.path.basename(newPath)
        self._baseName = os.path.splitext(self._base)[0]

    @property
    def folder(self):
        """
        The parent folder for the path

        :getter: Retrieves the parent folder name
        :setter: Sets the new parent folder name
        :type: :class:`str`
        """
        return self._folder
    
    @folder.setter
    def folder(self, newFolder: str):
        self._folder = newFolder
        self._path = os.path.join(self._folder, self._base)
    
    @property
    def base(self):
        """
        The base for the file path (includes file extension)

        :getter: Retrieves the base
        :setter: Sets the new base for the file path
        :type: :class:`str`
        """
        return self._base
    
    @base.setter
    def base(self, newBase: str):
        self._base = newBase
        self._path = os.path.join(self._folder, self._base)
        self._baseName = os.path.splitext(self._base)[0]

    @property
    def baseName(self):
        """
        The basename for the file path without any file extensions

        :getter: Retrieves the basename
        :setter: Sets the new basename for the file path
        :type: :class:`str`
        """
        return self._baseName
    
    @baseName.setter
    def baseName(self, newBaseName: str):
        self._baseName = newBaseName
        oldBaseName, ext = os.path.splitext(self._base)
        self._base = f"{self._baseName}{ext}"
        self._path = os.path.join(self._folder, self._base)


class Error(Exception):
    """
    The base exception used by this module

    Parameters
    ----------
    message: :class:`str`
        the error message to print out
    """

    def __init__(self, message: str):
        super().__init__(f"ERROR: {message}")


class FileException(Error):
    """
    This Class inherits from :class:`Error`

    Exceptions relating to files

    Parameters
    ----------
    message: :class:`str`
        The error message to print out

    path: Optional[:class:`str`]
        The path where the error for the file occured. If this value is ``None``, then the path
        will be the current directory where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, message: str, path: Optional[str] = None):
        path = FilePathConsts.getPath(path)

        if (path != FilePathConsts.DefaultPath):
            message += f" at {path}"

        super().__init__(message)


class MissingFileException(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when a certain type of file is missing from a folder

    Parameters
    ----------
    fileType: :class:`str`
        The type of file searching in the folder :raw-html:`<br />` :raw-html:`<br />`

        **Default**: "file"

    path: :class:`str`
        The path to the folder that is being searched. If this value is ``None``, then the path
        will be the current directory where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    fileType: :class:`str`
        The type of file searching in the folder
    """
    def __init__(self, fileType: str = FileTypes.Default.value, path: Optional[str] = None):
        path = FilePathConsts.getPath(path)
        message = f"Unable to find {fileType}. Ensure it is in the folder"
        self.fileType = fileType
        super().__init__(message, path = path)


class DuplicateFileException(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when there are multiple files of the same type in a folder

    Parameters
    ----------
    files: List[:class:`str`]
        The files that triggered the exception

    fileType: :class:`str`
        The name for the type of files :raw-html:`<br />` :raw-html:`<br />`

        **Default**: "file"

    path: Optional[:class:`str`]
        The path to the folder where the files are located If this value is ``None``, then the path
        will be the current directory where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    files: List[:class:`str`]
        The files that triggered the exception

    fileType: :class:`str`
        The name for the type of files

        **Default**: ``None``
    """

    def __init__(self, files: List[str], fileType: str = FileTypes.Default.value, path: Optional[str] = None):
        path = FilePathConsts.getPath(path)
        self.files = files
        self.fileType = fileType
        message = f"Ensure only one {fileType} exists"
        super().__init__(message, path = path)


class FileService():
    """
    Tools for handling with files and folders :raw-html:`<br />` :raw-html:`<br />`
    """

    @classmethod
    def getFilesAndDirs(cls, path: Optional[str] = None, recursive: bool = False) -> List[List[str]]:
        """
        Retrieves the files and folders contained in a certain folder

        Parameters
        ----------
        path: Optional[:class:`str`]
            The path to the target folder we are working with. If this argument is ``None``, then will use the current directory of where this module is loaded
            :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        recursive: :class:`bool`
            Whether to recursively check all the folders from our target folder :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        [List[:class:`str`], List[:class:`str`]]
            The files and directories within the folder. The order for the result is:

            #. files
            #. folders
        """
        path = cls.getPath(path)
        files = []
        dirs = []

        pathItems = []
        
        if (recursive):
            for root, currentDirs, currentFiles in os.walk(path, topdown = True):
                for dir in currentDirs:
                    dirs.append(os.path.join(root, dir))

                for file in currentFiles:
                    files.append(os.path.join(root, file))

            return [files, dirs]
        
        pathItems = os.listdir(path)
        for itemPath in pathItems:
            fullPath = os.path.join(path, itemPath)
            if (os.path.isfile(fullPath)):
                files.append(fullPath)
            else:
                dirs.append(fullPath)

        return [files, dirs]

    # filters and partitions the files based on the different filters specified
    @classmethod
    def getFiles(cls, path: Optional[str] = None, filters: Optional[List[Callable[[str], bool]]] = None, files: Optional[List[str]] = None) -> Union[List[str], List[List[str]]]:
        """
        Retrieves many different types of files within a folder

        .. note::
            Only retrieves files that are the direct children of the folder (will not retrieve files nested in a folder within the folder we are searching)

        Parameters
        ----------
        path: Optional[:class:`str`]
            The path to the target folder we are working with. If this value is set to ``None``, then will use the current directory of where this module is loaded
            :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        filters: Optional[List[Callable[[:class:`str`], :class:`bool`]]]
            Different filter functions for each type of file we are trying to get. If this values is either ``None`` or ``[]``, then will default to a filter to get all the files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        files: Optional[List[:class:`str`]]
            The files contained in the target folder

            If this value is set to ``None``, then the function will search for the files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Union[List[:class:`str`], List[List[:class:`str`]]]
            The files partitioned into the different types specified by the filters

            If 'filters' only has 1 element, then the function returns List[:class:`str`]
            Otherwise, will return List[List[:class:`str`]]
        """

        path = cls.getPath(path)
        result = []

        if (filters is None):
            filters = []

        if (not filters):
            filters.append(lambda itemPath: True)

        filtersLen = len(filters)
        usePathFiles = False
        if (files is None):
            files = os.listdir(path)
            usePathFiles = True

        for i in range(filtersLen):
            result.append([])
        
        for itemPath in files:
            for filterInd in range(filtersLen):
                pathFilter = filters[filterInd]
                if (not pathFilter(itemPath) or (usePathFiles and not os.path.isfile(os.path.join(path, itemPath)))):
                    continue

                fullPath = os.path.join(path, itemPath)

                result[filterInd].append(fullPath)

        if (filtersLen == 1):
            return result[0]
        
        return result
    
    # retrieves only a single file for each filetype specified by the filters
    @classmethod
    def getSingleFiles(cls, path: Optional[str] = None, filters: Optional[Dict[str, Callable[[str], bool]]] = None, files: Optional[List[str]] = None, optional: bool = False) -> Union[Optional[str], List[str], List[Optional[str]]]:
        """
        Retrieves exactly 1 of each type of file in a folder

        Parameters
        ----------
        path: Optional[:class:`str`]
            The path to the target folder we are searching. :raw-html:`<br />` :raw-html:`<br />`
            
            If this value is set to ``None``, then will use the current directory of where this module is loaded :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        filters: Optional[Dict[str, Callable[[:class:`str`], :class:`bool`]]]
            Different filter functions for each type of file we are trying to get. If this value is ``None`` or ``{}``, then will default to use a filter to get all files

            The keys are the names for the file type :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        files: Optional[List[:class:`str`]]
            The files contained in the target folder

            If this value is set to ``None``, then the function will search for the files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        optional: :class:`bool`
            Whether we want to send an exception if there is not exactly 1 file for a certain type of file :raw-html:`<br />` :raw-html:`<br />`

            #. If this value is ``False`` and there are no files for a certain type of file, then will raise a :class:`MissingFileException`
            #. If this value is ``False`` and there are more than 1 file for a certain type of file, then will raise a :class:`DuplicateFileException`
            #. If this value is ``True`` and there are no files for a certain type of file, then the file for that type of file will be ``None``
            #. If this value is ``True`` and there are more than 1 file for a certain type of file, then will retrieve the first file for that type of file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Raises
        ------
        :class:`MissingFileException`
            if ``optional`` is set to ``False`` and there are not files for a certain type of file

        :class:`DuplicateFileException`
            if ``optional`` is set to ``False`` and there are more than 1 file for a certain type of file

        Returns
        -------
        Union[Optional[:class:`str`], List[:class:`str`], List[Optional[:class:`str`]]]
            The files partitioned for each type of file

            * If ``filters`` only contains 1 element and ``optional`` is ``False``, then will return :class:`str`
            * If ``filters`` contains more than 1 element and ``optional`` is ``False`, then will return List[:class:`str`]
            * If ``filters`` only contains 1 element and ``optional`` is ``True``, then will return Optional[:class:`str`]
            * Otherwise, returns List[Optional[:class:`str`]]
        """
        path = cls.getPath(path)
        if (filters is None):
            filters = {}

        if (not filters):
            filters[FileTypes.Default.value] = lambda itemPath: True
        
        filesPerFileTypes = cls.getFiles(path = path, filters = list(filters.values()), files = files)
        filtersLen = len(filters)

        onlyOneFilter = filtersLen == 1
        if (onlyOneFilter):
            filesPerFileTypes = [filesPerFileTypes]

        result = []
        i = 0
        for fileType in filters:
            fileTypeFiles = filesPerFileTypes[i]
            filesLen = len(fileTypeFiles)

            if (not optional and not filesLen):
                raise MissingFileException(fileType = fileType, path = path)
            elif (not optional and filesLen > 1):
                raise DuplicateFileException(fileTypeFiles, fileType = fileType, path = path)
            
            if (fileTypeFiles):
                result.append(fileTypeFiles[0])
            else:
                result.append(None)
            i += 1

        if (onlyOneFilter):
            return result[0]
        
        return result
    
    @classmethod
    def rename(cls, oldFile: str, newFile: str):
        """
        Renames a file

        .. warning::
            If the new name for the file already exists, then the function deletes
            the file with the new name and renames the target file with the new name

        Parameters
        ----------
        oldFile: :class:`str`
            file path to the target file we are working with

        newFile: :class:`str`
            new file path for the target file 
        """
        if (oldFile == newFile):
            return

        try:
            os.rename(oldFile, newFile)
        except FileExistsError:
            os.remove(newFile)
            os.rename(oldFile, newFile)

    @classmethod
    def changeExt(cls, file: str, newExt: str) -> str:
        """
        Changes the extension for a file

        Parameters
        ----------
        file: :class:`str`
            The file path to the file we are working with

        newExt: :class:`str`
            The name of the new extension for the file (without the dot at front)

        Returns
        -------
        :class:`str`
            the new file path with the extension changed
        """

        dotPos = file.rfind(".")

        if (not newExt.startswith(".")):
            newExt = f".{newExt}"

        if (dotPos != -1):
            file = file[:dotPos] + newExt

        return file

    @classmethod
    def disableFile(cls, file: str, filePrefix: str = FilePrefixes.BackupFilePrefix.value) -> str:
        """
        Marks a file as 'DISABLED' and changes the file to a .txt file

        Parameters
        ----------
        file: :class:`str`
            The file path to the file we are working with

        filePrefix: :class:`str`
            Prefix name we want to add in front of the file name :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "DISABLED_BossFixBackup\_"

        Returns
        -------
        :class:`str`
            The new name of the file
        """

        baseName = os.path.basename(file)
        baseName = FileService.changeExt(baseName, FileExt.Txt.value)

        backupFile = os.path.join(os.path.dirname(file), filePrefix + baseName)
        FileService.rename(file, backupFile)
        return backupFile

    @classmethod
    def copyFile(cls, src: str, dest: str):
        """
        Copies a file from ``src`` to ``dest``

        Parameters
        ----------
        src: :class:`str`
            The file path to the file to be copied

        dest: :class:`str`
            The new file path for the copied file
        """

        shutil.copy2(src, dest)

    @classmethod
    def parseOSPath(cls, path: str):
        """
        Retrieves a normalized file path from a string

        Parameters
        ----------
        path: :class:`str`
            The string containing some sort of file path
        """

        result = ntpath.normpath(path)
        result = cls.ntPathToPosix(result)
        return result

    @classmethod
    def ntPathToPosix(cls, path: str) -> str:
        """
        Converts a file path from the `ntpath <https://opensource.apple.com/source/python/python-3/python/Lib/ntpath.py.auto.html>`_ library to a file path for the `os <https://docs.python.org/3/library/os.html>`_ library

        .. note::
            The character for the folder paths (``/`` or ``\\``) used in both libraries may be different depending on the OS

        Parameters
        ----------
        path: :class:`str`
            The file path we are working that is generated from the 'ntpath' library

        Returns
        -------
        :class:`str`
            The file path generated by the 'os' library
        """

        return path.replace(ntpath.sep, os.sep)
    
    @classmethod
    def absPathOfRelPath(cls, dstPath: str, relFolder: str) -> str:
        """
        Retrieves the absolute path of the relative path of a file with respect to a certain folder

        Parameters
        ----------
        dstPath: :class:`str`
            The target file path we are working with

        relFolder: :class:`str`
            The folder that the target file path is relative to

        Returns
        -------
        :class:`str`
            The absolute path for the target file
        """

        relFolder = os.path.abspath(relFolder)
        result = dstPath
        if (not os.path.isabs(result)):
            result = os.path.join(relFolder, result)

        return cls.parseOSPath(result)
    
    @classmethod
    def getRelPath(cls, path: str, start: str) -> str:
        """
        Tries to get the relative path of a file/folder relative to another folder, if possible.

        If it is not possible to get the relative path, will return back the original file path

        .. note::
            An example where it would not be possible to get the relative path would be:
            
            * If the file is located in one mount (eg. C:/ drive) and the folder is located in another mount (eg. D:/ drive)

        Parameters
        ----------
        path: :class:`str`
            The path to the target file/folder we are working with

        start: :class:`str`
            The path that the target file/folder is relative to

        Returns
        -------
        :class:`str`
            Either the relative path or the original path if not possible to get the relative paths
        """

        result = path
        try:
            result = os.path.relpath(path, start)

        # if the path is in another mount than 'start'
        except ValueError:
            pass

        return cls.parseOSPath(result)
    
    # read(file, fileCode, postProcessor): Tries to read a file using different encodings
    @classmethod
    def read(cls, file: str, fileCode: str, postProcessor: Callable[[TextIoWrapper], Any]) -> Any:
        """
        Tries to read a file using different file encodings

        Will interact with the file using the following order of encodings:

        #. utf-8 
        #. latin1

        Parameters
        ----------
        file: :class:`str`
            The file we are trying to read from

        fileCode: :class:`str`
            What `file mode <https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files>`_ to interact with the file (eg. r, rb, r+, etc...)

        postProcessor: Callable[[`TextIoWrapper`_], Any]
            A function used to process the file pointer of the opened file

        Returns
        -------
        Any
            The result after processing the file pointer of the opened file
        """

        error = None
        for encoding in ReadEncodings:
            try:
                with open(file, fileCode, encoding = encoding) as f:
                    return postProcessor(f)
            except UnicodeDecodeError as e:
                error = e

        if (error is not None):
            raise UnicodeDecodeError(f"Cannot decode the file using any of the following encodings: {ReadEncodings}")
        
    @classmethod
    def readBinary(cls, src: Union[str, bytes]) -> bytes:
        """
        Reads a binary file

        Parameters
        ----------
        src: Union[:class:`str`, :class:`bytes`]
            The source to read from

        Returns
        -------
        :class:`bytes`
            The read bytes
        """

        result = None
        if (isinstance(src, str)):
            with open(src, "rb") as f:
                result = f.read()
        else:
            result = src

        return result
    
    @classmethod
    def writeBinary(cls, file: str, data: bytes):
        """
        Writes data into a binary file

        Parameters
        ----------
        file: :class:`str`
            The file to write into

        data: :class:`bytes`
            The data to write
        """

        with open(file, "wb") as f:
            f.write(data)

    @classmethod
    def getPath(cls, path: Optional[str]) -> str:
        return FilePathConsts.getPath(path)


# Needed data model to inject into the .ini file
class IniResourceModel():
    """
    Contains data for fixing a particular resource in a .ini file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for fixedPath, fixedFullPath, origPath, origFullPath in x

            Iterates over all the fixed paths to some resource within a :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:
            #. fixedPath: (:class:`str`) The path name of the fixed file
            #. fixedFullPath: (:class:`str`) The full path name to the fixed file 
            #. origPath: (Optional[:class:`str`]) The path to the orignal file, if available
            #. origFullPath: (Optional[:class:`str`]) The full path name to the original file, if available

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    fixedPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the Blend.buf file appears in the :class:`IfTemplate` for some resource
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    origPaths: Optional[Dict[:class:`int`, List[:class:`str`]]]
        The file paths for the resource :raw-html:`<br />` :raw-html:`<br />`
        
        * The keys are the indices to the :class:`IfContentPart` that the Blend.buf file appears in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    fixedPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the resource files appear in the :class:`IfTemplate` for some resource
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    origPaths: Optional[Dict[:class:`int`, List[:class:`str`]]]
        The file paths to the files for the resource :raw-html:`<br />` :raw-html:`<br />`
        
        * The keys are the indices to the :class:`IfContentPart` that the files appear in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`

    fullPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The absolute paths to the fixed RemapBlend.buf files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the files appear in the :class:`IfTemplate` for some resource
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    origFullPaths: Dict[:class:`int`, List[:class:`str`]]
        The absolute paths to the files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the indices to the :class:`IfContentPart` that the resource files appear in the :class:`IfTemplate` for some resource
        * The values are the file paths within the :class:`IfContentPart`
    """

    def __init__(self, iniFolderPath: str, fixedPaths: Dict[int, Dict[str, List[str]]], origPaths: Optional[Dict[int, List[str]]] = None):
        self.fixedPaths = fixedPaths
        self.origPaths = origPaths
        self.iniFolderPath = iniFolderPath

        self.fullPaths = {}
        self.origFullPaths = {}

        # retrieve the absolute paths
        for partIndex, partPaths in self.fixedPaths.items():
            try:
                self.fullPaths[partIndex]
            except KeyError:
                self.fullPaths[partIndex] = {}

            for modName, paths in partPaths.items():
                self.fullPaths[partIndex][modName] = list(map(lambda path: FileService.absPathOfRelPath(path, iniFolderPath), paths))

        if (self.origPaths is not None):
            for partIndex in self.origPaths:
                paths = self.origPaths[partIndex]
                self.origFullPaths[partIndex] = list(map(lambda path: FileService.absPathOfRelPath(path, iniFolderPath), paths))


    def __iter__(self):
        for ifTemplateInd in self.fixedPaths:
            modPaths = self.fixedPaths[ifTemplateInd]

            for modName in modPaths:
                partPaths = modPaths[modName]
                partPathsLen = len(partPaths)

                for i in range(partPathsLen):
                    fixedPath = self.fixedPaths[ifTemplateInd][modName][i]
                    fullPath = self.fullPaths[ifTemplateInd][modName][i]
                    origPath = None
                    origFullPath = None

                    if (self.origPaths is not None):
                        try:
                            origPath = self.origPaths[ifTemplateInd][i]
                            origFullPath = self.origFullPaths[ifTemplateInd][i]
                        except KeyError:
                            pass

                    yield (fixedPath, fullPath, origPath, origFullPath)

    def clear(self):
        """
        Clears out all the path data stored
        """

        self.fixedPaths.clear()
        self.fullPaths.clear()
        self.origFullPaths.clear()

        if (self.origPaths is not None):
            self.origPaths.clear()


class GIMIParser(BaseIniParser):
    """
    This class inherits from :class:`BaseIniParser`

    Parses a .ini file used by a GIMI related importer

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to parse

    Attributes
    ----------
    blendCommandsGraph: :class:`IniSectionGraph`
        All the `sections`_ that use some ``[Resource.*Blend.*]`` section.

    nonBlendHashIndexCommandsGraph: :class:`IniSectionGraph`
        All the `sections`_ that are not used by the ``[Resource.*Blend.*]`` sections and contains the target hashes/indices that need to be replaced

    resourceCommandsGraph: :class:`IniSectionGraph`
        All the related `sections`_ to the ``[Resource.*Blend.*]`` sections that are used by `sections`_ related to the ``[TextureOverride.*Blend.*]`` sections.
        The keys are the name of the `sections`_.
    """

    def __init__(self, iniFile: "IniFile"):
        super().__init__(iniFile)
        self.blendCommandsGraph = IniSectionGraph(set(), {})
        self.nonBlendHashIndexCommandsGraph = IniSectionGraph(set(), {})
        self.resourceCommandsGraph = IniSectionGraph(set(), {})

    def clear(self):
        super().clear()
        self.blendCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.nonBlendHashIndexCommandsGraph.build(newTargetSections = set(), newAllSections = {})
        self.resourceCommandsGraph.build(newTargetSections = set(), newAllSections = {})

    # _getCommonMods(): Retrieves the common mods that need to be fixed between all target graphs
    #   that are used for the fix
    def _getCommonMods(self) -> Set[str]:
        modType = self._iniFile.type
        if (modType is None):
            return set()
        
        result = set()
        hashes = modType.hashes
        indices = modType.indices

        graphs = [self.blendCommandsGraph, self.nonBlendHashIndexCommandsGraph, self.resourceCommandsGraph]
        for graph in graphs:
            commonMods = graph.getCommonMods(hashes, indices, version = self._iniFile.version)
            if (not result):
                result = commonMods
            elif (commonMods):
                result = result.intersection(commonMods)

        return result
    
    def _setToFix(self) -> Set[str]:
        """
        Sets the names for the types of mods that will used in the fix

        Returns
        -------
        Set[:class:`str`]
            The names of the mods that will be used in the fix        
        """

        commonMods = self._getCommonMods()
        toFix = commonMods
        iniModsToFix = self._iniFile.modsToFix
        if (iniModsToFix):
            toFix = toFix.intersection(iniModsToFix)

        type = self._iniFile.availableType

        if (not toFix and type is not None):
            self._modsToFix = type.getModsToFix()
        elif (not toFix):
            self._modsToFix = commonMods
        else:
            self._modsToFix = toFix

        return self._modsToFix
    
    # _makeRemapNames(): Makes the required names used for the fix
    def _makeRemapNames(self):
        self.blendCommandsGraph.getRemapBlendNames(self._modsToFix)
        self.nonBlendHashIndexCommandsGraph.getRemapBlendNames(self._modsToFix)
        self.resourceCommandsGraph.getRemapBlendNames(self._modsToFix)

    def _makeRemapModels(self, resourceGraph: IniSectionGraph, getFixedFile: Optional[Callable[[str], str]] = None) -> Dict[str, IniResourceModel]:
        """
        Creates all the data needed for fixing the ``[Resource.*Blend.*]`` `sections`_ in the .ini file

        Parameters
        ----------
        resourceGraph: :class:`IniSectionGraph`
            The graph of `sections`_ for the resources

        getFixedFile: Optional[Callable[[:class:`str`], :class:`str`]]
            The function for transforming the file path of a found .*Blend.buf file into a .*RemapBlend.buf file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedBlendFile` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[:class:`str`, :class:`IniResourceModel`]
            The data for fixing the resource `sections`_

            The keys are the original names for the resource `sections`_ and the values are the required data for fixing the `sections`_
        """

        resourceCommands = resourceGraph.sections
        for resourceKey in resourceCommands:
            resourceIftemplate = resourceCommands[resourceKey]
            remapBlendModel = self._iniFile.makeResourceModel(resourceIftemplate, toFix = self._modsToFix, getFixedFile = getFixedFile)
            self._iniFile.remapBlendModels[resourceKey] = remapBlendModel

        return self._iniFile.remapBlendModels

    def parse(self):
        blendResources = set()
        self.blendCommandsGraph.remapNameFunc = self._iniFile.getRemapBlendName
        self.nonBlendHashIndexCommandsGraph.remapNameFunc = self._iniFile.getRemapFixName
        self.resourceCommandsGraph.remapNameFunc = self._iniFile.getRemapBlendResourceName

        # build the blend commands DFS forest
        subCommands = { self._iniFile._textureOverrideBlendRoot }
        self.blendCommandsGraph.build(newTargetSections = subCommands, newAllSections = self._iniFile.sectionIfTemplates)

        # build the DFS forest for the other sections that contain target hashes/indices that are not part of the blend commands
        hashIndexSections = self._iniFile.getTargetHashAndIndexSections(set(self.blendCommandsGraph.sections.keys()))
        self.nonBlendHashIndexCommandsGraph.build(newTargetSections = hashIndexSections, newAllSections= self._iniFile.sectionIfTemplates)

        # keep track of all the needed blend dependencies
        self._iniFile.getResources(self.blendCommandsGraph, lambda part: IniKeywords.Vb1.value in part, lambda part: set(map(lambda resourceData: resourceData[1], part[IniKeywords.Vb1.value])),
                                   lambda resource, part: blendResources.update(resource))

        # sort the resources
        resourceCommandLst = list(map(lambda resourceName: (resourceName, self._iniFile.getMergedResourceIndex(resourceName)), blendResources))
        resourceCommandLst.sort(key = cmp_to_key(self._iniFile.compareResources))
        resourceCommandLst = list(map(lambda resourceTuple: resourceTuple[0], resourceCommandLst))

        # keep track of all the subcommands that the resources call
        self.resourceCommandsGraph.build(newTargetSections = resourceCommandLst, newAllSections = self._iniFile.sectionIfTemplates)

        # get the required files that need fixing
        self._setToFix()
        self._makeRemapNames()
        self._makeRemapModels(self.resourceCommandsGraph)


class NoModType(Error):
    """
    This Class inherits from :class:`Error`

    Exception when trying to fix a mod of some unidentified mod type

    Parameters
    ----------
    type: :class:`str`
        The name for the type of mod specified 
    """

    def __init__(self):
        super().__init__(f"No mod type specified when fixing the .ini file")


class BaseIniFixer():
    """
    Base class to fix a .ini file

    Parameters
    ----------
    parser: :class:`BaseIniParser`
        The associated parser to retrieve data for the fix

    Attributes
    ----------
    _parser: :class:`BaseIniParser`
        The associated parser to retrieve data for the fix

    _iniFile: :class:`IniFile`
        The .ini file that will be fixed
    """

    def __init__(self, parser: BaseIniParser):
        self._parser = parser
        self._iniFile = parser._iniFile

    # _getAssetReplacement(assset, assetRepoAttName, notFoundStr): Retrieves the replacement for 'asset'
    def _getAssetReplacement(self, asset: str, assetRepoAttName: str, modName: str, notFoundVal: Any = None) -> Union[str, Any]:
        """
        Retrieves the replacement for 'asset'

        Parameters
        ----------
        asset: :class:`str`
            The asset to be replaced

        assetRepoAttName: :class:`str`
            The name of the :class:`ModIdAssets` repo in :meth:`IniFile.availableType`

        modName: :class:`str`
            The name of the mod we want the replacement for

        notFoundVal: Any
            The value to be returns if the replacement is not found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Union[:class:`str`, Any]
            The found replacement asset or the value from 'notFoundVal' if the replacement was not found
        """

        result = ""
        type = self._iniFile.availableType

        if (type is not None):
            assetRepo = getattr(type, assetRepoAttName)
            result = assetRepo.replace(asset, version = self._iniFile.version, toAssets = modName)
        else:
            raise NoModType()

        if (result is None):
            return notFoundVal
        return result

    def _getAsset(self, assetType: str, assetRepoAttName: str, modName: str, notFoundVal: Any = None) -> Union[str, Any]:
        """
        Retrieves the corresponding asset

        Parameters
        ----------
        assetType: :class:`str`
            The name for the type of asset to retrieve

        assetRepoAttName: :class:`str`
            The name of the :class:`ModIdAssets` repo in :meth:`IniFile.availableType`

        modName: :class:`str`
            The name of the mod we want the asset for

        notFoundVal: Any
            The value to be returned if the replacement is not found :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Union[:class:`str`, Any]
            The found asset or the value from 'notFoundVal' if the asset was not found
        """

        result = ""
        type = self._iniFile.availableType

        if (type is not None):
            assetRepo = getattr(type, assetRepoAttName)

            try:
                result = assetRepo.get(modName, assetType, version = self._iniFile.version)
            except:
                result = notFoundVal
        else:
            raise NoModType()

        return result

    # _getHashReplacement(hash): Retrieves the hash replacement for 'hash'
    def _getHashReplacement(self, hash: str, modName: str) -> str:
        """
        Retrieves the replacement for 'hash'

        Parameters
        ----------
        hash: :class:`str`
            The hash to be replaced

        modName: :class:`str`
            The name of the mod we want the replacement for

        Returns
        -------
        :class:`str`
            The corresponding replacement for the hash or "HashNotFound" if there are not replacements
        """

        return self._getAssetReplacement(hash, "hashes", modName, notFoundVal = IniKeywords.HashNotFound.value)
    
    # _getIndexReplacement(index): Retrieves the index replacement for 'index'
    def _getIndexReplacement(self, index: str, modName: str) -> str:
        """
        Retrieves the replacement for 'index'

        Parameters
        ----------
        index: :class:`str`
            The index to be replaced

        modName: :class:`str`
            The name of the mod we want the replacement for

        Returns
        -------
        :class:`str`
            The corresponding replacement for the index or "IndexNotFound" if there are not replacements
        """

        return self._getAssetReplacement(index, "indices", modName, notFoundVal = IniKeywords.IndexNotFound.value)
    
    def _getHash(self, hashType: str, modName: str) -> str:
        """
        Retrieves the corresponding hash

        Parameters 
        ----------
        hashType: :class:`str`
            The name for the type of hash to retrieve

        modName: :class:`str`
            The name for the type of mod to get the hash from

        Returns
        -------
        :class:`str`
            The found hash or "HashNotFound" if the corresponding hash is not found        
        """

        return self._getAsset(hashType, "hashes", modName, notFoundVal = IniKeywords.HashNotFound.value)
    
    def _getIndex(self, indexType: str, modName: str) -> str:
        """
        Retrieves the corresponding index

        Parameters 
        ----------
        indexType: :class:`str`
            The name for the type of index to retrieve

        modName: :class:`str`
            The name for the type of mod to get the index from

        Returns
        -------
        :class:`str`
            The found index or "IndexNotFound" if the corresponding index is not found     
        """

        return self._getAsset(indexType, "indices", modName, notFoundVal = IniKeywords.IndexNotFound.value)

    # _getRemapName(sectionName, modName, sectionGraph, remapNameFunc): Retrieves the required remap name for the fix
    def _getRemapName(self, sectionName: str, modName: str, sectionGraph: Optional[IniSectionGraph] = None, remapNameFunc: Optional[Callable[[str, str], str]] = None) -> str:
        error = False
        if (sectionGraph is None):
            error = True

        if (not error):
            try:
                return sectionGraph.remapNames[sectionName][modName]
            except KeyError:
                error = True

        if (sectionName not in self._iniFile.sectionIfTemplates):
            return sectionName

        if (remapNameFunc is None):
            remapNameFunc = self._iniFile.getRemapBlendName

        result = remapNameFunc(sectionName, modName)
        try:
            sectionGraph.remapNames[sectionName]
        except KeyError:
            sectionGraph.remapNames[sectionName] = {}

        sectionGraph.remapNames[sectionName][modName] = result
        return result

    # fills the if..else template in the .ini for each section
    def fillIfTemplate(self, modName: str, sectionName: str, ifTemplate: IfTemplate, fillFunc: Callable[[str, str, IfContentPart, int, int, str], str], origSectionName: Optional[str] = None) -> str:
        """
        Creates a new :class:`IfTemplate` for an existing `section`_ in the .ini file

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name of the `section`_

        ifTemplate: :class:`IfTemplate`
            The :class:`IfTemplate` of the orginal `section`_

        fillFunc: Callable[[:class:`str`, :class:`str`, :class:`IfContentPart`, :class:`int`, :class:`str`, :class:`str`], :class:`str`]]
            The function to create a new **content part** for the new :class:`IfTemplate`
            :raw-html:`<br />` :raw-html:`<br />`

            .. tip::
                For more info about an 'IfTemplate', see :class:`IfTemplate`

            :raw-html:`<br />`
            The parameter order for the function is:

            #. The name for the type of mod to fix to
            #. The new section name
            #. The corresponding **content part** in the original :class:`IfTemplate`
            #. The index for the content part in the original :class:`IfTemplate`
            #. The string to prefix every line in the **content part** of the :class:`IfTemplate`
            #. The original name of the section

        origSectionName: Optional[:class:`str`]
            The original name of the section.

            If this argument is set to ``None``, then will assume this argument has the same value as the argument for ``sectionName`` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The text for the newly created :class:`IfTemplate`
        """

        addFix = f"[{sectionName}]\n"
        partIndex = 0
        linePrefix = ""

        if (origSectionName is None):
            origSectionName = sectionName

        for part in ifTemplate:
            # adding in the if..else statements
            if (isinstance(part, IfPredPart)):
                addFix += part.pred
                
                linePrefix = re.match(r"^[( |\t)]*", part.pred)
                if (linePrefix):
                    linePrefix = linePrefix.group(0)
                    linePrefixLen = len(linePrefix)

                    linePrefix = part.pred[:linePrefixLen]

                    if (part.type != IfPredPartType.EndIf):
                        linePrefix += "\t"
                partIndex += 1
                continue
            
            # add in the content within the if..else statements
            addFix += fillFunc(modName, sectionName, part, partIndex, linePrefix, origSectionName)

            partIndex += 1
            
        return addFix

    def getFix(self, fixStr: str = "") -> str:
        """
        Retrieves the text to fix the .ini file
        """
        pass

    # _fix(keepBackup, fixOnly, update, withBoilerPlate, withSrc): Internal function to fix the .ini file
    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, withBoilerPlate: bool = True, withSrc: bool = True) -> Union[str, List[str]]:
        return self._iniFile._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, withBoilerPlate = withBoilerPlate, withSrc = withSrc)

    def fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False) -> Union[str, List[str]]:
        """
        Fixes the .ini file

        Parameters
        ----------
        keepBackup: :class:`bool`
            Whether to keep backups for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether to only fix the .ini file without undoing any fixes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        update: :class:`bool`
            Whether to also update the source text in the :class:`IniFile` object with the latest fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Union[:class:`str`, List[:class:`str`]]
            The new content of the .ini file which includes the fix and the new content of any other newly created .ini files related to fixing the particular .ini file
        """

        return self._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update)


class IniFixBuilder(Builder[BaseIniFixer]):
    """
    This class inherits from :class:`Builder`

    Class to dynamically build a :class:`BaseIniFixer` to fix .ini files

    Parameters
    ----------
    cls: Type[:class:`BaseIniFixer`]
        The class to construct a :class:`BaseIniFixer` 

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, cls: Type[BaseIniFixer], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        super().__init__(cls, args, kwargs)

    def build(self, parser: BaseIniParser) -> BaseIniFixer:
        """
        Builds the fixer

        Parameters
        ----------
        parser: :class:`BaseIniParser`
            The corresponding parser for the .ini file

        Returns
        -------
        :class:`BaseIniFixer`
            The built fixer
        """

        return super().build(parser)


class GIMIFixer(BaseIniFixer):
    """
    This class inherits from :class:`BaseIniFixer`

    Fixes a .ini file used by a GIMI related importer

    Parameters
    ----------
    parser: :class:`GIMIParser`
        The associated parser to retrieve data for the fix
    """

    def __init__(self, parser: GIMIParser):
        super().__init__(parser)


    def _fillTextureOverrideRemapBlend(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix related to the ``[TextureOverride.*Blend.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideBlend] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, _, _ in part:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommandName = self._getRemapName(varValue, modName, sectionGraph = self._parser.blendCommandsGraph)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommandName}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # filling in the hash
            elif (varName == IniKeywords.Hash.value):
                hash = self._getHashReplacement(varValue, modName)
                addFix += f"{linePrefix}{IniKeywords.Hash.value} = {hash}\n"

            # filling in the vb1 resource
            elif (varName == IniKeywords.Vb1.value):
                blendName = varValue
                remapBlendName = self._getRemapName(blendName, modName, sectionGraph = self._parser.resourceCommandsGraph, remapNameFunc = self._iniFile.getRemapBlendResourceName)
                fixStr = f'{IniKeywords.Vb1.value} = {remapBlendName}'
                addFix += f"{linePrefix}{fixStr}\n"

            # filling in the handling
            elif (varName == IniKeywords.Handling.value):
                fixStr = f'{IniKeywords.Handling.value} = skip'
                addFix += f"{linePrefix}{fixStr}\n"

            # filling in the draw value
            elif (varName == IniKeywords.Draw.value):
                fixStr = f'{IniKeywords.Draw.value} = {varValue}'
                addFix += f"{linePrefix}{fixStr}\n"

            # filling in the indices
            elif (varName == IniKeywords.MatchFirstIndex.value):
                index = self._getIndexReplacement(varValue, modName)
                addFix += f"{linePrefix}{IniKeywords.MatchFirstIndex.value} = {index}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"
                
        return addFix
    
    def _fillNonBlendSections(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str) -> str:
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix that are not related to the ``[TextureOverride.*Blend.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideBlend] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, _, _ in part:
            # filling in the hash
            if (varName == IniKeywords.Hash.value):
                newHash = self._getHashReplacement(varValue, modName)
                addFix += f"{linePrefix}{IniKeywords.Hash.value} = {newHash}\n"

            # filling in the subcommand
            elif (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(varValue, modName, sectionGraph = self._parser.nonBlendHashIndexCommandsGraph, remapNameFunc = self._iniFile.getRemapFixName)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # filling in the index
            elif (varName == IniKeywords.MatchFirstIndex.value):
                newIndex = self._getIndexReplacement(varValue, modName)
                addFix += f"{linePrefix}{IniKeywords.MatchFirstIndex.value} = {newIndex}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    

    # fill the attributes for the sections related to the resources
    def _fillRemapResource(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new `sections`_ created by this fix related to the ``[Resource.*Blend.*]`` `sections`_

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the `section`_

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original ``[Resource.*Blend.*]`` `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, keyInd, _ in part:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(varValue, modName, sectionGraph = self._parser.resourceCommandsGraph, remapNameFunc = self._iniFile.getRemapBlendResourceName)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # add in the type of file
            elif (varName == "type"):
                addFix += f"{linePrefix}type = Buffer\n"

            # add in the stride for the file
            elif (varName == "stride"):
                addFix += f"{linePrefix}stride = 32\n"

            # add in the file
            elif (varName == "filename"):
                remapModel = self._iniFile.remapBlendModels[origSectionName]
                fixedBlendFile = remapModel.fixedPaths[partIndex][modName][keyInd]
                addFix += f"{linePrefix}filename = {fixedBlendFile}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    

    # _fixBlendCommands(modName, fix): Get the fix string for all the texture override blend sections
    def _fixBlendCommands(self, modName: str, fix: str = ""):
        blendCommandTuples = self._parser.blendCommandsGraph.runSequence
        for commandTuple in blendCommandTuples:
            section = commandTuple[0]
            ifTemplate = commandTuple[1]
            commandName = self._getRemapName(section, modName, sectionGraph = self._parser.blendCommandsGraph)
            fix += self.fillIfTemplate(modName, commandName, ifTemplate, self._fillTextureOverrideRemapBlend)
            fix += "\n"

        return fix
    
    # _fixNonBlendHashIndexCommands(modName, fix): get the fix string for non-blend sections
    def _fixNonBlendHashIndexCommands(self, modName: str, fix: str = ""):
        nonBlendCommandTuples = self._parser.nonBlendHashIndexCommandsGraph.runSequence
        for commandTuple in nonBlendCommandTuples:
            section = commandTuple[0]
            ifTemplate = commandTuple[1]
            commandName = self._getRemapName(section, modName, sectionGraph = self._parser.nonBlendHashIndexCommandsGraph)
            fix += self.fillIfTemplate(modName, commandName, ifTemplate, self._fillNonBlendSections)
            fix += "\n"

        return fix
    
    # _fixResourceCommands(modName, fix): get the fix string for the resources
    def _fixResourceCommands(self, modName: str, fix: str = ""):
        resourceCommandTuples = self._parser.resourceCommandsGraph.runSequence
        resourceCommandsLen = len(resourceCommandTuples)
        for i in range(resourceCommandsLen):
            commandTuple = resourceCommandTuples[i]
            section = commandTuple[0]
            ifTemplate = commandTuple[1]

            resourceName = self._getRemapName(section, modName, sectionGraph = self._parser.resourceCommandsGraph, remapNameFunc = self._iniFile.getRemapBlendResourceName)
            fix += self.fillIfTemplate(modName, resourceName, ifTemplate, self._fillRemapResource, origSectionName = section)

            if (i < resourceCommandsLen - 1):
                fix += "\n"

        return fix

    def fixMod(self, modName: str, fix: str = "") -> str:
        """
        Generates the newly added code in the .ini file for the fix of a single type of mod

        .. note::
            eg.
                If we are making the fix from ``Jean`` -> ``JeanCN`` and ``JeanSeaBreeze``,
                The code below will only make the fix for ``JeanCN``

            .. code-block::

                fixMod("JeanCN")


        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to fix

        fix: :class:`str`
            Any existing text we want the result of the fix to add onto :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ""

        Returns
        -------
        :class:`str`
            The text for the newly generated code in the .ini file
        """

        hasNonBlendSections = bool(self._parser.nonBlendHashIndexCommandsGraph.sections)
        hasResources = bool(self._iniFile.remapBlendModels)

        if (self._parser.blendCommandsGraph.sections or hasResources or hasNonBlendSections):
            fix += "\n"

        fix = self._fixBlendCommands(modName, fix = fix)
        if (hasNonBlendSections):
            fix += "\n"

        fix = self._fixNonBlendHashIndexCommands(modName, fix = fix)
        if (hasResources):
            fix += "\n"

        fix = self._fixResourceCommands(modName, fix = fix)
        return fix

    def getFix(self, fixStr: str = ""):
        heading = Heading("", sideLen = 5, sideChar = "*")
        sortedModsToFix = list(self._parser._modsToFix)
        sortedModsToFix.sort()

        for modName in sortedModsToFix:
            heading.title = modName
            currentFix = self.fixMod(modName)

            if (currentFix):
                fixStr += f"\n\n; {heading.open()}{currentFix}\n; {heading.close()}"

        return fixStr


class TextTools():
    @classmethod
    def removeParts(cls, txt: str, partIndices: List[Tuple[int, int]]) -> str:
        """
        Remove multiple substrings from a text based off the indices of the substrings

        Parameters
        ----------
        txt: :class:`str`
            The target txt to have the substrings removed

        partIndices: List[Tuple[:class:`int`, :class:`int`]]
            The indices for the substrings to be removed :raw-html:`<br />` :raw-html:`<br />`

            The tuples contain the following data:

                #. The start index for the substring
                #. The ending index for the substring

        Returns 
        -------
        :class:`str`
            The new string with the substrings removed
        """

        chars = list(txt)
        chars = ListTools.removeParts(chars, partIndices, lambda: 0, lambda element: element == 0)
        result = "".join(chars)
        return result


    @classmethod
    def removeLines(cls, txtLines: List[str], partIndices: List[Tuple[int, int]]) -> List[str]:
        """
        Removes multiple sub-lists of lines from a list of text lines

        Parameters
        ----------
        txtLines: List[:class:`str`]
            The lines of text to have its lines removed

        partIndices: List[Tuple[:class:`int`, :class:`int`]]
            The indices for the list of lines to be removed :raw-html:`<br />` :raw-html:`<br />`

            The tuples contain the following data:

                #. The start index for the list of lines
                #. The ending index for the list of lines

        Returns 
        -------
        List[:class:`str`]
            The new lines of text with the removed lines
        """

        result = ListTools.removeParts(txtLines, partIndices, lambda: 0, lambda element: element == 0)
        return result
    
    @classmethod
    def getTextLines(cls, txt: str) -> List[str]:
        """
        Retrieves the lines of text, split by the newline character, similar to how python's `readlines`_ function works

        Parameters
        ----------
        txt: :class:`str`
            The target text to be split

        Returns
        -------
        List[:class:`str`]
            The lines of text that were split
        """

        txtLines = txt.split("\n")

        if (txt):
            txtLinesLen = len(txtLines)
            for i in range(txtLinesLen):
                if (i < txtLinesLen - 1):
                    txtLines[i] += "\n"
        else:
            txtLines = []

        return txtLines
    
    @classmethod
    def capitalize(cls, txt: str) -> str:
        """
        Capitalize only the beginning letter of 'txt'

        Parameters
        ----------
        txt: :class:`str`
            The text to be capitalized

        Returns
        -------
        :class:`str`
            The new text with its first letter capitalized
        """

        if (not txt):
            return txt
        elif (len(txt) == 1):
            return txt.upper()
        
        return txt[0].upper() + txt[1:]



class BaseTexEditor():
    """
    Base class to edit some .dds file
    """

    def fix(self, texFile: "TextureFile", fixedTexFile: str):
        """
        Edits the texture file

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture .dds file to be modified

        fixedTexFile: :class:`str`
            The name of the fixed texture file
        """
        pass


class BaseIniRemover():
    """
    Base class to remove fixes from a .ini file

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to remove the fix from

    Attributes
    ----------
    iniFile: :class:`IniFile`
        The .ini file that will be parsed
    """

    def __init__(self, iniFile: "IniFile"):
        self.iniFile = iniFile

    @staticmethod
    def _readLines(func):
        """
        Decorator to read all the lines in the .ini file first before running a certain function

        All the file lines will be saved in :attr:`IniFile._fileLines`

        Examples
        --------
        .. code-block:: python
            :linenos:

            @_readLines
            def printLines(self):
                for line in self.iniFile.fileLines:
                    print(f"LINE: {line}")
        """

        def readLinesWrapper(self, *args, **kwargs):
            if (not self.iniFile._fileLinesRead):
                self.iniFile.readFileLines()
            return func(self, *args, **kwargs)
        return readLinesWrapper

    def remove(self, parse: bool = False) -> str:
        """
        Removes the fix from the .ini file

        Parameters
        ----------
        parse: :class:`bool`
            Whether to also parse for the .*RemapBlend.buf files that need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new content of the .ini file
        """
        pass


class IniRemover(BaseIniRemover):
    """
    This class inherits from :class:`BaseIniRemover`

    Class for the basic removal of the fixes from .ini files
    
    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to remove the fix from
    """

    _fixRemovalPattern = re.compile(f"(; {IniBoilerPlate.OldHeading.value.open()}((.|\n)*?); {IniBoilerPlate.OldHeading.value.close()[:-2]}(-)*)|(; {IniBoilerPlate.DefaultHeading.value.open()}((.|\n)*?); {IniBoilerPlate.DefaultHeading.value.close()[:-2]}(-)*)")
    _removalPattern = re.compile(f"^\s*\[.*(" + IniKeywords.RemapBlend.value + "|" + IniKeywords.RemapFix.value + "|" + IniKeywords.RemapTex.value + r").*\]")
    _sectionRemovalPattern = re.compile(f".*(" + IniKeywords.RemapBlend.value + "|" + IniKeywords.RemapFix.value + "|" + IniKeywords.RemapTex.value + r").*")
    _remapTexRemovalPattern = re.compile(IniKeywords.Resource.value + f".*" + IniKeywords.RemapTex.value + r".*")

    def __init__(self, iniFile: "IniFile"):
        super().__init__(iniFile)

    #_makeRemovalRemapBlendModels(sectionNames): Retrieves the data needed for removing Blend.buf files from the .ini file
    def _makeRemovalRemapBlendModels(self, sectionNames: Set[str]):
        for sectionName in sectionNames:
            ifTemplate = None
            try:
                ifTemplate = self.iniFile.sectionIfTemplates[sectionName]
            except KeyError:
                continue

            self.iniFile.remapBlendModels[sectionName] = self.iniFile.makeResourceModel(ifTemplate, toFix = {""}, getFixedFile = lambda origFile, modName: origFile)

    # _makeRemovalRemapTexModels(sectionNames): Retrieves the data needed for removing RemapTex.dds files from the .ini file
    def _makeRemovalRemapTexModels(self, sectionNames: Set[str]):
        for sectionName in sectionNames:
            ifTemplate = None
            try:
                ifTemplate = self.iniFile.sectionIfTemplates[sectionName]
            except KeyError:
                continue
            
            self.iniFile.texAddModels[sectionName] = {}
            self.iniFile.texAddModels[sectionName][""] = self.iniFile.makeTexModel(ifTemplate, {""}, BaseTexEditor(), getFixedFile = lambda origFile, modName: origFile)

    # _getRemovalBlendResource(sectionsToRemove): Retrieves the names of the Blend.buf resource sections to remove
    def _getRemovalBlendResource(self, sectionsToRemove: Set[str]) -> Set[str]:
        result = set()
        allSections = self.iniFile.getIfTemplates()
        removalSectionGraph = IniSectionGraph(sectionsToRemove, allSections)
        self.iniFile.getResources(removalSectionGraph, lambda part: IniKeywords.Vb1.value in part, lambda part: part.getVals(IniKeywords.Vb1.value),
                                  lambda resource, part: result.update(set(resource)))

        result = set(filter(lambda section: re.match(self._sectionRemovalPattern, section), result))
        return result
    
    # _getRemovalTexResource(sectionToRemove): Retrieves the names of the texture resource sections to remove
    def _getRemovalTexResource(self, sectionsToRemove: Set[str]) -> Set[str]:
        return set(filter(lambda section: re.match(self._remapTexRemovalPattern, section), sectionsToRemove))

    @BaseIniRemover._readLines
    def _removeScriptFix(self, parse: bool = False) -> str:
        """
        Removes the dedicated section of the code in the .ini file that this script has made

        Parameters
        ----------
        parse: :class:`bool`
            Whether to keep track of the Blend.buf files that also need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file
        """

        if (not parse):
            self.iniFile._fileTxt = re.sub(self._fixRemovalPattern, "", self.iniFile._fileTxt)
        else:
            removedSectionsIndices = []
            txtLinesToRemove = []

            # retrieve the indices the dedicated section is located
            rangesToRemove = [match.span() for match in re.finditer(self._fixRemovalPattern, self.iniFile._fileTxt)]
            for range in rangesToRemove:
                start = range[0]
                end = range[1]
                txtLines = TextTools.getTextLines(self.iniFile._fileTxt[start : end])

                removedSectionsIndices.append(range)
                txtLinesToRemove += txtLines

            # retrieve the names of the sections the dedicated sections reference
            sectionNames = set()
            for line in txtLinesToRemove:
                if (re.match(self.iniFile._sectionPattern, line)):
                    sectionName = self.iniFile._getSectionName(line)
                    sectionNames.add(sectionName)

            resourceSections = self._getRemovalBlendResource(sectionNames)
            texSections = self._getRemovalTexResource(sectionNames)

            # get the Blend.buf / RemapTex.dds files that need to be removed
            self._makeRemovalRemapBlendModels(resourceSections)
            self._makeRemovalRemapTexModels(texSections)
            
            # remove the dedicated section
            self.iniFile._fileTxt = TextTools.removeParts(self.iniFile._fileTxt, removedSectionsIndices)

        self.iniFile.fileTxt = self.iniFile._fileTxt.strip()
        result = self.iniFile.write()

        self.iniFile.clearRead()
        self.iniFile._isFixed = False
        return result

    @BaseIniRemover._readLines
    def _removeFixSections(self, parse: bool = False) -> str:
        """
        Removes the [.*RemapBlend.*] sections of the .ini file that this script has made

        Parameters
        ----------
        parse: :class:`bool`
            Whether to keep track of the Blend.buf files that also need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file
        """

        if (not parse):
            self.iniFile.removeSectionOptions(self._removalPattern)
        else:
            sectionsToRemove = self.iniFile.getSectionOptions(self._removalPattern, postProcessor = self.iniFile._removeSection)

            sectionNames = set()
            removedSectionIndices = []

            # get the indices and sections to remove
            for sectionName in sectionsToRemove:
                sectionRanges = sectionsToRemove[sectionName]
                sectionNames.add(sectionName)

                for range in sectionRanges:
                    removedSectionIndices.append(range)

            resourceSections = self._getRemovalBlendResource(sectionNames)
            texSections = self._getRemovalTexResource(sectionNames)

            self._makeRemovalRemapBlendModels(resourceSections)
            self._makeRemovalRemapTexModels(texSections)

            self.iniFile.fileLines = TextTools.removeLines(self.iniFile.fileLines, removedSectionIndices)

        result = self.iniFile.write()

        self.iniFile.clearRead()
        self.iniFile._isFixed = False
        return result

    def remove(self, parse: bool = False) -> str:
        """
        Removes the fix from the .ini file

        Parameters
        ----------
        parse: :class:`bool`
            Whether to also parse for the .*RemapBlend.buf files that need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new content of the .ini file
        """

        if (not self.iniFile.isModIni):
            parse = False

        self._removeScriptFix(parse = parse)    
        result = self._removeFixSections(parse = parse)
        return result


class FlyweightBuilder(Builder[BuildCls]):
    """
    This class inherits from :class:`Builder`

    A flyweight factory for building the same reusable objects (based off `flyweight design pattern`_)
    """

    def __init__(self, cls: Type[BuildCls], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None):
        super().__init__(cls, args, kwargs)
        self._cache = {}

    def build(self, args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None, id: Optional[Hashable] = None, cache: bool = True) -> BuildCls:
        """
        Builds the object

        Parameters
        ----------
        args: Optional[List[Any]]
            arguments to build the object :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        kwargs: Optional[Dict[str, Any]]
            keyword arguments to build the object :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        id: Optional[Hashable]
            The id for the repeating states to be built by the object :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will auto-generate an id :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        cache: :class:`bool`
            Whether to cache the built object

            .. note::
                If this value is set to ``False``, then this function behaves the same as :meth:`Builder.build`

            **Default**: ``True``

        Returns
        -------
        T
            The built objects
        """

        if (args is None):
            args = []

        if (kwargs is None):
            kwargs = {}

        if (not cache):
            return super().build(*args, **kwargs)

        if (id is None):
            id = str(uuid.uuid4())

        result = None
        try:
            result = self._cache[id]
        except KeyError:
            result = super().build(*args, **kwargs)
            self._cache[id] = result

        return result


class IniRemoveBuilder(FlyweightBuilder[BaseIniRemover]):
    """
    This class inherits from :class:`FlyweightBuilder`

    A class to help dynamically build a :class:`BaseIniRemover`

    Parameters
    ----------
    cls: Type[:class:`BaseIniRemover`]
        The class to construct a :class:`BaseIniRemover` 

    args: Optional[List[Any]]
        The constant arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    kwargs: Optional[Dict[str, Any]]
        The constant keyword arguments used to build the object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    cache: :class:`bool`
        Whether to cache the built object :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    cache: :class:`bool`
        Whether to cache the built object
    """

    def __init__(self, cls: Type[BaseIniRemover], args: Optional[List[Any]] = None, kwargs: Optional[Dict[str, Any]] = None, cache: bool = True):
        super().__init__(cls, args, kwargs)
        self.cache = cache

    def build(self, iniFile: "IniFile") -> BaseIniRemover:
        """
        Builds the remover

        Parameters
        ----------
        iniFile: :class:`IniFile`
            The .ini file to parse

        Returns
        -------
        :class:`BaseIniRemover`
            The built remover
        """

        id = self._cls.__name__
        result = super().build(args = [iniFile], id = id, cache = self.cache)
        result.iniFile = iniFile
        return result


GlobalIniRemoveBuilder = IniRemoveBuilder(IniRemover)

class ModType():
    """
    Class for defining a generic type of mod

    Parameters
    ----------
    name: :class:`str`
        The default name for the type of mod

    check: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
        The specific check used to identify the .ini file belongs to the specific type of mod when checking arbitrary line in a .ini file :raw-html:`<br />` :raw-html:`<br />`

        #. If this argument is a string, then will check if a line in the .ini file equals to this argument
        #. If this argument is a regex pattern, then will check if a line in the .ini file matches this regex pattern
        #. If this argument is a function, then will check if a line in the .ini file will make the function for this argument return `True`

    hashes: Optional[:class:`Hashes`]
        The hashes related to the mod and its fix :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will create a new, empty :class:`Hashes` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    indices: Optional[:class:`Indices`]
        The indices related to the mod and its fix :raw-html:`<br />` :raw-html:`<br />`

        If this ``None``, then will create a new, emtpy :class:`Indices` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    aliases: Optional[List[:class:`str`]]
        Other alternative names for the type of mod :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    vgRemaps: Optional[:class:`VGRemaps`]
        Maps the blend indices from the vertex group of one mod to another mod :raw-html:`<br />`

        If this value is ``None``, then will create a new, empty :class:`VGRemaps` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    iniParseBuilder: Optional[:class:`IniParseBuilder`]
        The builder to build the parser used for .ini files :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then by default this attribute will be set to **IniParseBuilder(:class:`GIMIParser`)** :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    iniFixBuilder: Optional[:class:`IniFixBuilder`]
        The builder to build the fixer used for .ini files :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then by default this attribute will be set to **IniFixBuilder(:class:`GIMIFixer`)** :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    iniRemoveBuilder: Optional[:class:`IniRemoveBuilder`]
        The builder to build the remover used for .ini files :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then by default this attribute will be set to **IniRemoveBuilder(:class:`IniRemover`)** :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    name: :class:`str`
        The default name for the type of mod

    check: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
        The specific check used to identify the .ini file belongs to the specific type of mod when checking arbitrary line in a .ini file

    hashes: :class:`Hashes`
        The hashes related to the mod and its fix

    indices: :class:`Indices`
        The indices related to the mod and its fix

    vgRemaps: :class:`VGRemaps`
        The repository that stores the mapping for remapping vertex group blend indices of the mod to the vertex group blend indices of another mod

    aliases: Optional[List[:class:`str`]]
        Other alternative names for the type of mod

    iniParseBuilder: :class:`IniParseBuilder`
        The builder to build the parser used for .ini files

    iniFixBuilder: :class:`IniFixBuilder`
        the builder to build the fixer used for .ini files

    iniRemoveBuilder: :class:`IniRemoveBuilder`
        the builder to build the remover used for .ini files
    """

    def __init__(self, name: str, check: Union[str, Pattern, Callable[[str], bool]], hashes: Optional[Hashes], indices: Optional[Indices] = None, 
                 aliases: Optional[List[str]] = None, vgRemaps: Optional[VGRemaps] = None, iniParseBuilder: Optional[IniParseBuilder] = None,
                 iniFixBuilder: Optional[IniFixBuilder] = None, iniRemoveBuilder: Optional[IniRemoveBuilder] = None):
        self.name = name
        if (hashes is None):
            hashes = Hashes()

        if (indices is None):
            indices = Indices()

        self.hashes = hashes
        self.indices = indices

        self.check = check
        if (isinstance(check, str)):
            self._check = lambda line: line == check
        elif (callable(check)):
            self._check = check
        else:
            self._check = lambda line: bool(check.search(line))
        
        if (aliases is None):
            aliases = []
        self.aliases = ListTools.getDistinct(aliases)
        
        self._maxVgIndex = None
        if (vgRemaps is None):
            vgRemaps = VGRemaps()

        self.vgRemaps = vgRemaps

        if (iniParseBuilder is None):
            iniParseBuilder = IniParseBuilder(GIMIParser)

        if (iniFixBuilder is None):
            iniFixBuilder = IniFixBuilder(GIMIFixer)

        if (iniRemoveBuilder is None):
            iniRemoveBuilder = GlobalIniRemoveBuilder

        self.iniParseBuilder = iniParseBuilder
        self.iniFixBuilder = iniFixBuilder
        self.iniRemoveBuilder = iniRemoveBuilder

    def isName(self, name: str) -> bool:
        """
        Determines whether a certain name matches with the names defined for this type of mod

        Parameters
        ----------
        name: :class:`str`
            The name being searched

        Returns
        -------
        :class:`bool`
            Whether the searched name matches with the names for this type of mod
        """

        name = name.lower()
        if (self.name.lower() == name):
            return True
        
        for alias in self.aliases:
            if (alias.lower() == name):
                return True

        return False
    
    def isType(self, iniLine: str) -> bool:
        """
        Determines whether a line in the .ini file correponds with this mod type

        Parameters
        ----------
        iniLine: :class:`str`
            An arbitrary line in a .ini file

        Returns
        -------
        :class:`bool`
            Whether the line in the .ini file corresponds with this type of mod
        """

        return self._check(iniLine)
    

    def getModsToFix(self) -> Set[str]:
        """
        Retrieves the names of the mods this mod type will fix to

        Returns
        -------
        Set[:class:`str`]
            The names of the mods to fix to
        """

        result = set()
        result = result.union(self.hashes.fixTo)
        result = result.union(self.indices.fixTo)
        result = result.union(self.vgRemaps.fixTo)
        return result
    
    def getVGRemap(self, modName: str, version: Optional[float] = None) -> VGRemap:
        """
        Retrieves the corresponding Vertex Group Remap

        .. attention::
            This function assumes that the specified map :attr:`ModType.vgRemaps` (:attr:`VGRemaps.map`) contains :attr:`ModType.name` (the name of this mod type) as a mod to map from

        Parameters
        ----------
        modName: :class:`str`
            The name of the mod to map to

        version: Optional[:class:`float`]
            The specific game version we want for the remap :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will get the latest version of the remap :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns 
        -------
        :class:`VGRemap`
            The corresponding remap
        """

        return self.vgRemaps.get(self.name, modName, version = version)

    def getHelpStr(self) -> str:
        modTypeHeading = Heading(self.name, 8, "-")

        currentHelpStr = f"{modTypeHeading.open()}"
        currentHelpStr += f"\n\nname: {self.name}"
        
        if (self.aliases):
            sortedAliases = sorted(self.aliases)
            aliasStr = ", ".join(sortedAliases)
            currentHelpStr += f"\naliases: {aliasStr}"

        if (isinstance(self.check, str)):
            currentHelpStr += f"\ndescription: check if the .ini file contains the section named, '{self.check}'"
        elif (not callable(self.check)):
            currentHelpStr += f"\ndescription: check if the .ini file contains a section matching the regex, {self.check.pattern}"

        currentHelpStr += f"\n\n{modTypeHeading.close()}"
        return currentHelpStr
    
    def fixIni(self, iniFile: "IniFile", keepBackup: bool = True, fixOnly: bool = False):
        """
        Fixes the .ini file associated to this type of mod

        Parameters
        ----------
        iniFile: :class:`IniFile`
            The .ini file to fix

        keepBackup: :class:`bool`
            Whether to keep backups for the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether to only fix the .ini file without undoing any fixes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        iniModType = iniFile.availableType
        if (iniModType is not None and iniModType.name == self.name):
            iniFile.fix(keepBackup = keepBackup, fixOnly = fixOnly)


class ColourConsts(Enum):
    """
    Constants about colours
    """

    MinColourValue = 0
    """
    Minimum bound for a colour channel
    """

    MaxColourValue = 255
    """
    Maximum bound for a colour channel
    """

    MinColourDegree = 0
    """
    Minimum degrees for some HSV/HSL images    
    """

    MaxColourDegree = 360
    """
    Maximum degrees for some HSV/HSL images    
    """


class Colour():
    """
    Class to store data for a colour

    Parameters
    ----------
    red: :class:`int`
        The red channel for the colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    green: :class:`int`
        The green channel for the colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    blue: :class:`int`
        The blue channel for the colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``

    alpha: :class:`int`
        The transparency (alpha) channel for the colour with a range from 0-255. 0 = transparent, 255 = opaque :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``255``
    """

    def __init__(self, red: int = ColourConsts.MaxColourValue.value, green: int = ColourConsts.MaxColourValue.value, blue: int = ColourConsts.MaxColourValue.value, alpha: int = ColourConsts.MaxColourValue.value):
        self.red = self.boundColourChannel(red)
        self.green = self.boundColourChannel(green)
        self.blue = self.boundColourChannel(blue)
        self.alpha = self.boundColourChannel(alpha)

    @classmethod
    def boundColourChannel(self, val: int, min: int = ColourConsts.MinColourValue.value, max: int = ColourConsts.MaxColourValue.value):
        """
        Makes a colour channel to be in between the minimum and maximum value

        Parameters
        ----------
        val: :class:`int`
            The value of the channel

        min: :class:`int`
            The minimum bound for the colour channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``0``

        max: :class:`int`
            The maximum bound for the colour channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``0``
        """

        if (val > max):
            val = max
        elif (val < min):
            val = min
        return val
    
    def fromTuple(self, colourTuple: Tuple[int, int, int, int]):
        """
        Updates the colour based off 'colourTuple'

        Parameters
        ----------
        colourTuple: Tuple[:class:`int`, :class:`int`, :class:`int`, :class:`int`]
            The raw values for the colour in RGBA format
        """

        self.red = colourTuple[0]
        self.green = colourTuple[1]
        self.blue = colourTuple[2]
        self.alpha = colourTuple[3]
    
    def getTuple(self) -> Tuple[int, int, int, int]:
        """
        Retrieves the tuple representation of the colour in RGBA format

        Returns
        -------
        Tuple[:class:`int`, :class:`int`, :class:`int`, :class:`int`]
            The colour tuple containing the following colour channel values indicated by the order below: :raw-html:`<br />` :raw-html:`<br />`

            #. Red
            #. Green
            #. Blue
            #. Alpha            
        """

        return (self.red, self.green, self.blue, self.alpha)
    
    def getId(self) -> str:
        """
        Retrieves a unique id for the colour

        Returns
        -------
        :class:`str`
            The id for the colour        
        """

        return f"{self.red}{self.green}{self.blue}{self.alpha}"

    def copy(self, colour, withAlpha: bool = True):
        """
        Copies the colour value from 'colour'

        Parameters
        ----------
        colour: :class:`Colour`
            The colour to copy from

        withAlpha: :class:`bool`
            Whether to also copy the alpha channel :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``
        """

        self.red = colour.red
        self.green = colour.green
        self.blue = colour.blue

        if (withAlpha):
            self.alpha = colour.alpha
    
    def match(self, colour):
        """
        Whether 'colour' matches this colour

        Parameters
        ----------
        colour: :class:`Colour`
            The colour to check

        Returns
        -------
        :class:`bool`
            Whether the colour matches this colour
        """

        return (colour.red == self.red and colour.green == self.green and
                colour.blue == self.blue and colour.alpha == self.alpha)


class ColourRange():
    """
    Class to store data for a colour

    Parameters
    ----------
    min: :class:`Colour`
        The minimum range for the RGBA values

    max: :class:`Colour`
        The maximum range for the RGBA values
    """

    def __init__(self, min: Colour, max: Colour):
        self.min = min
        self.max = max
    
    def match(self, colour: Colour) -> bool:
        """
        Whether 'colour' is within the colour range

        Parameters
        ----------
        colour: :class:`Colour`
            The colour to check

        Returns
        -------
        :class:`bool`
            Whether the colour is within the colour range
        """
        
        return (self.min.red <= colour.red and colour.red <= self.max.red and
                self.min.green <= colour.green and colour.green <= self.max.green and
                self.min.blue <= colour.blue and colour.blue <= self.max.blue and
                self.min.alpha <= colour.alpha and colour.alpha <= self.max.alpha)


class Colours(Enum):
    """
    Some common colours used

    Attributes
    ----------
    White: :class:`Colour`(255, 255, 255, 255)
        white

    LightMapGreenMin: :class:`Colour`(0, 125, 0, 0)
        Minimum range for the green colour usually in the LightMap.dds

    LightMapGreenMax: :class:`Colour`(50, 150, 50, 255)
        Maximum range for the green colour usually in the LightMap.dds

    NormalMapYellow: :class:`Colour`(128, 128, 0, 255)
        The yellow that usually appears in the NormalMap.dds
    """

    White = Colour(ColourConsts.MaxColourValue.value, ColourConsts.MaxColourValue.value, ColourConsts.MaxColourValue.value)
    LightMapGreenMin = Colour(0, 125, 0, 0)
    LightMapGreenMax = Colour(50, 150, 50, ColourConsts.MaxColourValue.value)
    NormalMapYellow = Colour(128, 128, 0)

class ColourRanges(Enum):
    """
    Some common colour ranges used

    Attributes
    ----------
    LightMapGreen: :class:`ColourRange`(:attr:`Colours.LightMapGreenMin`, :attr:`Colours.LightMapGreenMax`)
        The colour range for the green usually present in LightMap.dds
    """
    LightMapGreen = ColourRange(Colours.LightMapGreenMin.value, Colours.LightMapGreenMax.value)


class ModTypeBuilder():
    """
    Class to create a new :class:`ModType` for different mods
    """
    pass


class IniTexModel(IniResourceModel):
    """
    This class inherits from :class:`IniResourceModel`

    Contains data for editting some texture files in a .ini file

    :raw-html:`<br />`

    .. container:: operations

        **Supported Operations:**

        .. describe:: for fixedPath, fixedFullPath, origPath, origFullPath in x

            Iterates over all the fixed paths to some texture within a :class:`IfContentPart`, ``x`` :raw-html:`<br />` :raw-html:`<br />`

            The tuples to iterate over are as follows:
            #. fixedPath: (:class:`str`) The path name of the fixed file
            #. fixedFullPath: (:class:`str`) The full path name to the fixed file 
            #. origPath: (Optional[:class:`str`]) The path to the orignal file, if available
            #. origFullPath: (Optional[:class:`str`]) The full path name to the original file, if available

    Parameters
    ----------
    iniFolderPath: :class:`str`
        The folder path to where the .ini file of the resource is located

    fixedPaths: Dict[:class:`int`, Dict[:class:`str`, List[:class:`str`]]]
        The file paths to the fixed files for the resource :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the .dds files appears in the :class:`IfTemplate` for some texture
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the file paths within the :class:`IfContentPart`

    texEdits: Dict[:class:`int`, Dict[:class:`str`, List[:class:`BaseTexEditor`]]]
        The texture editors used to edit the texture :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the indices to the :class:`IfContentPart` that the .dds files appears in the :class:`IfTemplate` for some texture
        * The inner keys are the names for the type of mod to fix to
        * The inner values are the different texture editors used to the .dds files

    origPaths: Optional[Dict[:class:`int`, List[:class:`str`]]]
        The file paths for the resource :raw-html:`<br />` :raw-html:`<br />`
        
        * The keys are the indices to the :class:`IfContentPart` that the .dds files appears in the :class:`IfTemplate` for some texture
        * The values are the file paths within the :class:`IfContentPart`

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """

    def __init__(self, iniFolderPath: str, fixedPaths: Dict[int, Dict[str, List[str]]], texEdits: Dict[int, Dict[str, List[BaseTexEditor]]], 
                 origPaths: Optional[Dict[int, List[str]]] = None):
        super().__init__(iniFolderPath, fixedPaths, origPaths = origPaths)
        self.texEdits = texEdits

    def clear(self):
        super().clear()
        self.texEdits.clear()


class GIMIObjParser(GIMIParser):
    """
    This class inherits from :class:`GIMIParser`

    Parses a .ini file used by a GIMI related importer and parses section's related to a specific mod object (head, body, dress, etc...)

    .. note::
        For the specific names of the objects for a particular mod, please refer to `GIMI Assets`_

    Parameters
    ----------
    iniFile: :class:`IniFile`
        The .ini file to parse

    objs: Set[:class:`str`]
        The specific mod objects to keep track of

    texEdits: Optional[Dict[:class:`str`, Dict[:class:`str`, Dict[:class:`str`, :class:`BaseTexEditor`]]]]
        texture resource `sections`_ that require to be editted

        * The outer keys ares the name of the mod object the texture resource belongs in
        * The second outer keys are the name of the register the texture resource belongs in
        * The inner keys are the names of the type of texture files that are editted
        * The inner value is the editor for changing the texture files

        .. note::
            The new names of the texture files to be editted should be all unique

        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    objGraphs: Dict[:class:`str`, :class:`IniSectionGraph`]
        The different `sections`_ related to each mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects and the values are the graphs related to each object

    texGraphs: Dict[:class:`str`, Dict[:class:`str`, :class:`IniSectionGraph`]]
        The different `sections`_ related to the textures to be editted :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod object
        * The inner keys are the name of the register within the mod object
        * The inner value are the graphs for each register specified

    _objSearchPatterns: Dict[:class:`str`, `Pattern`]
        The Regex patterns used to find the roots of the `sections`_ related to each mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects and the values are the Regex patterns

    _objRootSections: Dict[:class:`str`, Set[:class:`str`]]
        The root `sections`_ for each mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects and the values are the names of the `sections`_

    texEditRegs: Dict[:class:`str`, Tuple[:class:`str`, :class:`str`]]
        The corresponding register for a particular texture resource to be editted :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the names of the type of texture resource to edit
        * The values contains info about the corresponding register for the texture. The tuple contains:
            #. The name of the mod object the texture resource belongs to
            #. The name of the register that holds the texture
    """

    def __init__(self, iniFile: "IniFile", objs: Set[str], texEdits: Optional[Dict[str, Dict[str, Dict[str, BaseTexEditor]]]] = None):
        super().__init__(iniFile)
        self.objGraphs: Dict[str, IniSectionGraph] = {}
        self.texGraphs: Dict[str, Dict[str, IniSectionGraph]] = {}
        self._objSearchPatterns: Dict[str, Pattern] = {}
        self._objRootSections: Dict[str, Set[str]] = {}
        self.texEditRegs: Dict[str, Tuple[str, str]] = {}
        self._objs = objs
        self.texEdits = {} if texEdits is None else texEdits
        self._objs = copy.deepcopy(self._objs)

    @property
    def objs(self):
        """
        The specific mod objects to keep track of

        :getter: Returns the names of the mod objects
        :setter: Sets the new names for the mod objects to keep track of
        :type: Set[:class:`str`]
        """

        return self._objs
    
    @objs.setter
    def objs(self, newObjs: Set[str]):
        self._objs = copy.deepcopy(newObjs)
        self._objs = self._objs.union(set(self.texEdits.keys()))
        self.clear()

    @property
    def texEdits(self):
        """
        texture resource `sections`_ that require to be editted

        * The outer keys ares the name of the mod object the texture resource belongs in
        * The second outer keys are the name of the register the texture resource belongs in
        * The inner keys are the names of the type of texture files that are editted
        * The inner value is the editor for changing the texture files

        :getter: Returns the specific registers to have their textures editted
        :setter: Sets the new registers to have their textures editted
        :type: Dict[:class:`str`, Dict[:class:`str`, Dict[:class:`str`, :class:`BaseTexEditor`]]]
        """

        return self._texEdits

    def _getTexEditRegs(self, result: Dict[str, Tuple[str, str]], keys: Dict[str, str], values: Dict[str, Union[BaseTexEditor, Dict[str, BaseTexEditor], Dict[str, Dict[str, BaseTexEditor]]]]):
        result[keys["tex"]] = (keys["modObj"], keys["reg"])
    
    @texEdits.setter
    def texEdits(self, newTexEdits: Dict[str, Dict[str, Dict[str, BaseTexEditor]]]):
        self._texEdits = newTexEdits
        self.texEditRegs = {}
        DictTools.forDict(self._texEdits, ["modObj", "reg", "tex"], lambda keys, values: self._getTexEditRegs(self.texEditRegs, keys, values))

        self._objs = self._objs.union(set(self.texEdits.keys()))
        self.clear()

    def _makeTexModels(self, texName: str, texGraph: IniSectionGraph, texEditor: BaseTexEditor, getFixedFile: Optional[Callable[[str], str]] = None) -> Dict[str, Dict[str, IniTexModel]]:
        """
        Creates all the data needed for fixing the ``[Resource.*]`` `sections`_ related to texture files in the .ini file

        Parameters
        ----------
        texName: :class:`str`
            The name for the type of texture file to edit

        texGraph: :class:`IniSectionGraph`
            The graph of `sections`_ for the particular type of textures

        getFixedFile: Optional[Callable[[:class:`str`], :class:`str`]]
            The function for transforming the file path of a found from the texture .dds file into a .*RemapFix.dds file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedTexFile` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[:class:`str`, Dict[:class:`str`, :class:`IniTexModel`]]
            The data for fixing the resource `sections`_

            * The outer keys are the names for the particular type of texture files
            * The inner keys are the names for the resrouce `sections`_
            * The values are the required data for fixing the `sections`_
        """

        if (getFixedFile is None):
            getFixedFile = self._iniFile.getFixedTexFile

        texComands = texGraph.sections
        for sectionName in texComands:
            texIfTemplate = texComands[sectionName]
            texModel =  self._iniFile.makeTexModel(texIfTemplate, self._modsToFix, texEditor, getFixedFile = getFixedFile) 

            try:
                self._iniFile.texEditModels[texName]
            except KeyError:
                self._iniFile.texEditModels[texName] = {}

            self._iniFile.texEditModels[texName][sectionName] = texModel

        return self._iniFile.texEditModels

    def clear(self):
        super().clear()

        # reset the search patterns
        self._objSearchPatterns.clear()
        for obj in self._objs:
            capitalizedObj = TextTools.capitalize(obj.lower())
            self._objSearchPatterns[obj] = re.compile(r"^TextureOverride.*" + capitalizedObj + "$")

        # reset the graphs for the objects
        self.objGraphs.clear()
        for obj in self._objs:
            self.objGraphs[obj] = IniSectionGraph(set(), {})

        # reset the roots of each section
        self._objRootSections.clear()
        for obj in self._objs:
            self._objRootSections[obj] = set()

        # reset the graphs for each texture resource
        self.texGraphs.clear()
        for obj in self._texEdits:
            objRegs = self._texEdits[obj]
            self.texGraphs[obj] = {}

            for reg in objRegs:
                self.texGraphs[obj][reg] = IniSectionGraph(set(), {})
    
    # _getCurrentObjResources(part, objRegNames): Retrieves the desired resources from the registers
    #   specified at 'objRegNames' from 'part'
    def _getCurrentObjResources(self, part: IfContentPart, objRegNames: Set[str]) -> Dict[str, str]:
        result = DictTools.filter(part.src, lambda partKey, partVal: partKey in objRegNames)
        for reg in result:
            result[reg] = set(map(lambda valData: valData[1], result[reg]))
        return result

    def parse(self):
        super().parse()

        # retrieve the roots for each object
        for section in self._iniFile.sectionIfTemplates:
            for objName in self._objSearchPatterns:
                pattern = self._objSearchPatterns[objName]
                if (pattern.match(section)):
                    self._objRootSections[objName].add(section)
                    break

        # get the sections for each object
        for objName in self.objGraphs:
            objGraph = self.objGraphs[objName]
            objGraph.build(newTargetSections = self._objRootSections[objName], newAllSections = self._iniFile.sectionIfTemplates)

        # get the sections for each texture to be editted
        for objName in self._texEdits:
            objRegNames = set(self._texEdits[objName].keys())
            objGraph = self.objGraphs[objName]
            objResources = {}

            self._iniFile.getResources(objGraph, lambda part: set(part.src.keys()).intersection(objRegNames), 
                                       lambda part: self._getCurrentObjResources(part, objRegNames),
                                       lambda resource, part: DictTools.update(objResources, resource, 
                                                                               combineDuplicate = lambda val1, val2: val1.union(val2)))
            
            # build the graphs for each register
            for reg in objResources:
                objResources[reg] = set(objResources[reg])
                texGraph = self.texGraphs[objName][reg]
                texGraph.build(newTargetSections = objResources[reg], newAllSections = self._iniFile.sectionIfTemplates)

                # build the models for each texture type
                texEditors = self._texEdits[objName][reg]
                for texName in texEditors:
                    self._makeTexModels(texName, texGraph, texEditors[texName])

    # _getTexItem(texName, texItems): Retrieves the corresponding item from 'texItems' based off 'texName'
    def _getTexItem(self, texName: str, texItems: Dict[str, Dict[str, Any]]) -> Optional[Any]:
        texKeys = None
        try:
            texKeys = self.texEditRegs[texName]
        except KeyError:
            return None
        
        try:
            return texItems[texKeys[0]][texKeys[1]]
        except KeyError:
            return None

    def getTexEditor(self, texName: str) -> Optional[BaseTexEditor]:
        """
        Retrieves the corresponding :class:`BaseTexEditor` based on 'texName'

        Parameters
        ----------
        texName: :class:`str`
            The name to the type of texture file to be editted

        Returns
        -------
        Optional[:class:`BaseTexEditor`]
            The found texture editor
        """

        texEditors = self._getTexItem(texName, self._texEdits)
        if (texEditors is None):
            return None
        
        try:
            return texEditors[texName]
        except KeyError:
            return None

    def getTexGraph(self, texName: str) -> Optional[IniSectionGraph]:
        """
        Retrieves the corresponding :class:`IniSectionGraph` based on 'texName'

        Parameters
        ----------
        texName: :class:`str`
            The name to the type of texture file to be editted

        Returns
        -------
        Optional[:class:`IniSectionGraph`]
            The found section graph
        """

        texGraphKeys = None
        try:
            texGraphKeys = self.texEditRegs[texName]
        except KeyError:
            return None
        
        try:
            return self.texGraphs[texGraphKeys[0]][texGraphKeys[1]]
        except KeyError:
            return None
        
    def getTexGraphs(self, texNames: List[str]) -> List[IniSectionGraph]:
        """
        Retrieves the corresponding `section`_ graphs based on 'texNames'

        Parameters
        ----------
        texNames: List[:class:`str`]
            The names to the type of texture files to be editted

        Returns
        -------
        List[:class:`IniSectionGraph`]
            The found `section`_ graphs
        """

        result = []
        texNames = ListTools.getDistinct(texNames, keepOrder = True)

        for texName in texNames:
            currentResult = self.getTexGraph(texName)
            if (currentResult is not None):
                result.append(currentResult)

        return result


class BaseRegEditFilter():
    """
    Base class for editting registers within an :class:`IfContentPart`
    """

    def clear(self):
        """
        Clears any saved state within this class
        """

        pass

    def edit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        """
        Edits the registers for the current :class:`IfContentPart`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers

        Returns 
        -------
        :class:`IfContentPart`
            The resultant part of the :class:`IfTemplate` that got its registers editted
        """

        self.clear()


class RegEditFilter(BaseRegEditFilter):
    """
    This class inherits from :class:`BaseRegEditFilter`

    class for editting registers within an :class:`IfContentPart`
    """

    def clear(self):
        """
        Clears any saved state within this class
        """

        pass

    def edit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        """
        Edits the registers for the current :class:`IfContentPart`. Includes boilerplate of clearing all saved states and handling texture adds/edits

        .. note::
            If you are inheriting this class, you probably want to override the :meth:`RegEditFilter._editReg` method instead

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers

        Returns 
        -------
        :class:`IfContentPart`
            The resultant part of the :class:`IfTemplate` that got its registers editted
        """

        self.clear()
        result = self._editReg(part, modType, fixModName, obj, sectionName, fixer)
        self.handleTexAdd(part, modType, fixModName, obj, sectionName, fixer)
        self.handleTexEdit(part, modType, fixModName, obj, sectionName, fixer)
        return result

    def _editReg(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        """
        The main function to edit the registers for the current :class:`IfContentPart`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers

        Returns 
        -------
        :class:`IfContentPart`
            The resultant part of the :class:`IfTemplate` that got its registers editted
        """

        pass

    def handleTexAdd(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        """
        Does any post-processing on the added textures of the corresponding :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers
        """

        pass

    def handleTexEdit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        """
        Does any post-processing on the added textures of the corresponding :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        part: :class:`IfContentPart`
            The part of the :class:`IfTemplate` that is being editted

        modType: :class:`ModType`
            The type of mod that is being fix from

        fixModName: :class:`str`
            The name of the mod to fix to

        obj: :class:`str`
            The name of the mod object being fixed

        fixer: :class:`GIMIObjReplaceFixer`
            The fixer that is editting the registers
        """

        pass


class ImgFormats(Enum):
    """
    Different formats for an image
    """

    RGB = "RGB"
    """
    RGB (red, green blue) image
    """

    RGBA = "RGBA"
    """
    RGBA (red, green, blue) image
    """

    HSV = "HSV"
    """
    HSV (hue, saturation, value) image
    """


class PackageManager():
    """
    Class to handle external packages for the library at runtime
    """

    def __init__(self):
        self._packages: Dict[str, ModuleType] = {}

    def load(self, module: str, installName: Optional[str] = None, save: bool = True) -> ModuleType:
        """
        Imports an external package

        Parameters
        ----------
        module: :class:`str`
            The name of the module to import

        install: Optional[:class:`str`]
            The name of the installation for the package when using `pip`_ to download from `pypi`_ :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then assume that the name of the installation is the same as the name of the package :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        save: :class:`bool`
            Whether to save the installed package into this class

        Returns
        -------
        `Module`_
            The module to the external package
        """

        if (installName is None):
            installName = module

        try:
            return importlib.import_module(module)
        except ModuleNotFoundError:
            pip.main(['install', '-U', installName])

        result = importlib.import_module(module)
        if (save):
            self._packages[module] = result
        
        return result
    
    def get(self, module: str, installName: Optional[str] = None):
        """
        Retrieves an external package

        Parameters
        ----------
        module: :class:`str`
            The name of the package to import

        install: Optional[:class:`str`]
            The name of the installation for the package when using `pip`_ to download from `pypi`_ :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then assume that the name of the installation is the same as the name of the package :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        `Module`_
            The module to the external package
        """

        result = None
        try:
            result = self._packages[module]
        except KeyError:
            result = self.load(module, installName = installName)

        return result
    
Packager = PackageManager()


# our model objects in MVC
class Model():
    """
    Generic class used for any data models in the fix

    Parameters
    ----------
    logger: Optional[:class:`Logger`]
        The logger used to print messages to the console :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    logger: Optional[:class:`Logger`]
        The logger used to print messages to the console
    """
    def __init__(self, logger: Optional["Logger"] = None):
        self.logger = logger

    def print(self, funcName: str, *args, **kwargs):
        """
        Prints out output

        Parameters
        ----------
        funcName: :class:`str`
            The name of the function in the logger for printing out the output

        \*args: List[:class:`str`]
            Arguments to pass to the function in the logger

        \*\*kwargs: Dict[:class:`str`, Any]
            Keyword arguments to pass to the function in the logger

        Returns
        -------
        :class:`Any`
            The return value from running the corresponding function in the logger 
        """

        if (self.logger is not None):
            func = getattr(self.logger, funcName)
            return func(*args, **kwargs)


class File(Model):
    """
    Base class for a file
    """

    def read(self) -> Any:
        """
        Reads the data within a file        
        """
        pass


class TextureFile(File):
    """
    This Class inherits from :class:`File`

    Used for handling .dds files

    Attributes
    ----------
    img: Optional[`PIL.Image`_]
        The associated image file for the texture
    """

    def __init__(self, src: str):
        self.src = src
        self.img = None

    def open(self, format: str = ImgFormats.RGBA.value) -> Image:
        """
        Opens the texture file

        Parameters
        ----------
        format: :class:`str`
            What format the image of the texture file should be opened as :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "RGBA"

        Returns
        -------
        `PIL.Image`
            The image for the texture file
        """

        if (not os.path.exists(self.src)):
            self.img = None
            return None

        Image = Packager.get("PIL.Image", "pillow")

        self.img = Image.open(self.src)
        self.img = self.img.convert(format)
        return self.img

    def read(self, format: str = ImgFormats.RGBA.value, flush: bool = False) -> Optional[List[List[Tuple[int, int, int, int]]]]:
        """
        Reads the pixels of the texture .dds file, if the file exists

        Parameters
        ----------
        format: :class:`str`
            What format to open the texture file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "RGBA"

        flush: :class:`bool`
            Whether to reopen the texture file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Optional[`PIL.PixelAccess`_]
            The pixels for the texture file with RGBA channels
        """

        if (flush or self.img is None):
            self.open(format = format)

        if (self.img is None):
            return None

        return self.img.load()
    
    def save(self, img: Optional[Image] = None):
        """
        Saves the pixels defined at 'img' to the texture .dds file

        Parameters
        ----------
        img: Optional[`PIL.Image`]
            the new image to set for the texture file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (img is not None):
            self.img = img
        self.img.save(self.src, 'DDS')


class TexCreator(BaseTexEditor):
    """
    This class inherits from :class:`BaseTexEditor`

    Creates a brand new .dds file if the file doe not exist
    """

    def __init__(self, width: int, height: int, colour: Optional[Colour] = None):
        self.width = width
        self.height = height
        self.colour = Colours.White.value if (colour is None) else colour

    def fix(self, texFile: "TextureFile", fixedTexFile: str):
        if (os.path.isfile(texFile.src)):
            return
        
        Image = Packager.get("PIL.Image", "pillow")

        img = Image.new(mode = ImgFormats.RGBA.value, size=(self.width, self.height), color = self.colour.getTuple())
        texFile.src = fixedTexFile
        texFile.save(img = img)


class RegTexAdd(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for adding new texture .dds files to a :class:`IfContentPart`

    Parameters
    ----------
    textures: Optional[Dict[:class:`str`, Dict[:class:`str`, Tuple[:class:`str`, :class:`TexCreator`, :class:`bool`]]]]
        New texture .dds files to be created :raw-html:`<br />` :raw-html:`<br />`

        * The outer key are the names of the mod object
        * The inner keys are the names of the register
        * The inner values contanis:
            #. The name of the type of texture file
            #. The object that will create the new texture file

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ("EmptyNormalMap", :class:`TexCreator`(4096, 1024))}, "body": {"ps-t3": ("NewLightMap", :class:`TexCreator`(1024, 1024, :class:`Colour`(0, 128, 0, 255))), "ps-t0": ("DummyShadowRamp", :class:`Colour`())}}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    mustAdd: :class:`bool`
        Whether the texture files will still be created for a particular :class:`IfContentPart` even if the corresponding register for the texture file does not exist within that particular :class:`IfContentPart`

    Attributes
    ----------
    textures: Dict[:class:`str`, Dict[:class:`str`, Tuple[:class:`str`, :class:`TexCreator`]]]
        New texture .dds files to be created :raw-html:`<br />` :raw-html:`<br />`

        * The outer key are the names of the mod object
        * The inner keys are the names of the register
        * The inner values contanis:
            #. The name of the type of texture file
            #. The object that will create the new texture file

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ("EmptyNormalMap", :class:`TexCreator`(4096, 1024))}, "body": {"ps-t3": ("NewLightMap", :class:`TexCreator`(1024, 1024, :class:`Colour`(0, 128, 0, 255))), "ps-t0": ("DummySshadowRamp", :class:`Colour`())}}``

    mustAdd: :class:`bool`
        Whether the texture files will still be created for a particular :class:`IfContentPart` even if the corresponding register for the texture file does not exist within that particular :class:`IfContentPart`

    _regAddVals: Optional[Dict[:class:`str`, :class:`str`]]
        The texture additions to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the name of the registers and the values are the `section`_ names for the textures
    """

    def __init__(self, textures: Optional[Dict[str, Dict[str, Tuple[str, TexCreator]]]] = None, mustAdd: bool = True):
        self.textures = {} if (textures is None) else textures
        self.mustAdd = mustAdd
        self._regAddVals: Optional[Dict[str, str]] = None

    def clear(self):
        self._regAddVals = None
    
    def _editReg(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        texAdds = None
        try:
            texAdds = self.textures[obj]
        except KeyError:
            return part

        self._regAddVals = {}
        for reg in texAdds:
            texAddData = texAdds[reg]
            texTypeName = texAddData[0]

            name = None
            try:
                fixer._texAddRemapNames[texTypeName]
            except KeyError:
                fixer._texAddRemapNames[texTypeName] = {}

            try:
                name = fixer._texAddRemapNames[texTypeName][obj]
            except KeyError:
                name = fixer.getTexResourceRemapFixName(texTypeName, modType.name, fixModName, obj)
                fixer._texAddRemapNames[texTypeName][obj] = name

            self._regAddVals[reg] = name

        part.replaceVals(self._regAddVals, addNewKVPs = self.mustAdd)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regAddVals is not None):
            fixer._currentTexAddsRegs.update(set(self._regAddVals.keys()))
    
    def handleTexEdit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regAddVals is not None):
            fixer._currentTexEditRegs = fixer._currentTexEditRegs.difference(set(self._regAddVals.keys()))


class GIMIObjReplaceFixer(GIMIFixer):
    """
    This class inherits from :class:`GIMIFixer`

    Base class to fix a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap are replaced by other mod objectss

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    regEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. Filters are executed based on the order specified in the list.

    Attributes
    ----------
    regEditOldObj: :class:`bool`
        Whether the register editting attributes such as :meth:`GIMIObjReplaceFixer.regRemap` or :meth:`GIMIObjReplaceFixer.regRemove` have their mod objects
        reference the original mod objects of the mod to be fixed or the new mod objects of the fixed mods
    """

    def __init__(self, parser: GIMIObjParser, regEditFilters: Optional[List[BaseRegEditFilter]] = None, regEditOldObj: bool = True):
        super().__init__(parser)
        self._texInds: Dict[str, Dict[str, int]] = {}
        self._texEditRemapNames: Dict[str, str] = {}
        self._texAddRemapNames: Dict[str, Dict[str, str]] = {}
        self.regEditOldObj = regEditOldObj

        self.addedTextures: Dict[str, Dict[str, Tuple[str, TexCreator]]] = {}
        self.regEditFilters = [] if (regEditFilters is None) else regEditFilters

        self._currentTexAddsRegs: Set[str] = set()
        self._currentTexEditRegs: Set[str] = set()
        self._currentRegTexEdits: Dict[str, Tuple[str, str]] = {}

        self._referencedTexEditSections: Dict[str, Set[str]] = {}
        self._referencedTexAdds: Set[str] = set()


    @property
    def regEditFilters(self):
        """
        Filters used to edit the registers of a certain :class:`IfContentPart`. Filters are executed based on the order specified in the list.

        :getter: Retrieves all the sequence of filters
        :setter: Sets the new sequence of filters
        :type: List[:class:`BaseRegEditFilter`]
        """
        
        return self._regEditFilters
    
    @regEditFilters.setter
    def regEditFilters(self, newRegEditFilters: List[BaseRegEditFilter]):
        self._regEditFilters = newRegEditFilters

        for filter in self._regEditFilters:
            if (isinstance(filter, RegTexAdd)):
                self.addedTextures = DictTools.combine(self.addedTextures, filter.textures, 
                                                       lambda srcObjTextures, currentObjTextures: DictTools.combine(srcObjTextures, currentObjTextures, 
                                                                                                                    lambda srcTexData, currentTexData: currentTexData))
    def clear(self):
        """
        Clears all the saved states
        """

        self._texInds = {}
        self._texEditRemapNames = {}
        self._texAddRemapNames = {}

        self._currentTexAddsRegs = set()
        self._currentTexEditRegs = set()
        self._currentRegTexEdits = {}

        self._referencedTexEditSections = {}
        self._referencedTexAdds = set()

    def getObjRemapFixName(self, name: str, modName: str, objName: str, newObjName: str) -> str:
        """
        Retrieves the new name of the `section`_ for a new mod object

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to be fixed

        objName: :class:`str`
            The name of the original mod object for the `section`_

        newObjName: :class:`str`
            The name of the new mod object for the `section`_

        Returns
        -------
        :class:`str`
            The new name for the `section`_
        """

        name = name[:-len(objName)] + TextTools.capitalize(newObjName.lower())
        return self._iniFile.getRemapFixName(name, modName = modName)
    
    def getTexResourceRemapFixName(self, texTypeName: str, oldModName: str, newModName: str, objName: str, addInd: bool = False) -> str:
        """
        Retrieves the new name of the `section`_ for a texture resource that is created/editted

        Parameters
        ----------
        texTypeName: :class:`str`
            The name of the type of texture file

        oldModName: :class:`str`
            The name of the mod to fix from

        newModName: :class:`str`
            The name of the mod to fix to

        objName: :class:`str`
            The mod object the texture resource refereces

        addInd: :class:`bool`
            Whether to add a unique numbered index to the end of the name to distingusih the name
            from other previously created names of the same texture type :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new name for the `section`_
        """

        nameParts = [oldModName, objName, texTypeName]
        nameParts = list(map(lambda namePart: TextTools.capitalize(namePart), nameParts))
        nameParts = "".join(nameParts)

        result = self._iniFile.getRemapTexResourceName(nameParts, modName = newModName)

        if (not addInd):
            return result
        
        # retrieve the occurence index of the type of texture resource
        texInd = 0
        try:
            self._texInds[texTypeName]
        except KeyError:
            self._texInds[texTypeName] = {}

        try:
            texInd = self._texInds[texTypeName][objName]
        except KeyError:
            self._texInds[texTypeName][objName] = 0

        self._texInds[texTypeName][objName] += 1
        return f"{result}{texInd}"

    def getObjHashType(self):
        return "ib"
    
    def editRegisters(self, modName: str, part: IfContentPart, obj: str, sectionName: str):
        """
        Edits the registers for a :class:`IfContentPart`

        .. note::
            For details on steps of how the registers are editted, see :class:`GIMIObjReplaceFixer`

        Parameters
        ----------
        modName: :class:`str`
            The name of the mod

        part: :class:`IfContentPart`
            The part that is being editted

        obj: :class:`str`
            The name of the mod object for the corresponding part

        sectionName: :class:`str`
            The name of the `section`_ the part belongs to
        """

        modType = self._iniFile.availableType
        if (modType is None):
            return
        
        self._currentRegTexEdits = {}
        self._currentTexAddsRegs = set()
        self._currentTexEditRegs = set()

        for filter in self._regEditFilters:
            part = filter.edit(part, modType, modName, obj, sectionName, self)

        texAdds = None
        try:
            texAdds = self.addedTextures[obj]
        except KeyError:
            pass

        # get the referenced texture add resources
        if (texAdds is not None):
            for reg in texAdds:
                if (reg not in self._currentTexAddsRegs):
                    continue
                
                texAddData = texAdds[reg]
                texName = texAddData[0]
                self._referencedTexAdds.add(texName)

        # get the referenced texture edit resources
        for reg in self._currentTexEditRegs:
            texEditData = None
            try:
                texEditData = self._currentRegTexEdits[reg]
            except KeyError:
                continue
            
            texName = texEditData[0]
            texEditSection = texEditData[1]

            texEditSections = None
            try:
                texEditSections = self._referencedTexEditSections[texName]
            except KeyError:
                texEditSections = set()
                self._referencedTexEditSections[texName] = texEditSections

            texEditSections.add(texEditSection)
        
    
    def fillObjNonBlendSection(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, origSectionName: str, objName: str, newObjName: str):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new sections created by this fix that are not related to the ``[TextureOverride.*Blend.*]`` `sections`_
        of some mod object, where the original `section` comes from a different mod object

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the section

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original [TextureOverrideBlend] `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        objName: :class:`str`
            The name of the original mod object

        newObjName: :class:`str`
            The name of the mod object to fix to

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""
        regEditObj = objName if (self.regEditOldObj) else newObjName

        newPart = copy.deepcopy(part)
        self.editRegisters(modName, newPart, regEditObj, sectionName)

        for varName, varValue, _, _ in newPart:
            # filling in the hash
            if (varName == IniKeywords.Hash.value):
                hashType = self.getObjHashType()
                newHash = self._getHash(hashType, modName)
                addFix += f"{linePrefix}{IniKeywords.Hash.value} = {newHash}\n"

            # filling in the subcommand
            elif (varName == IniKeywords.Run.value and varValue != IniKeywords.ORFixPath.value):
                subCommand = self.getObjRemapFixName(varValue, modName, objName, newObjName)
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # filling in the index
            elif (varName == IniKeywords.MatchFirstIndex.value):
                newIndex = self._getIndex(newObjName.lower(), modName)
                addFix += f"{linePrefix}{IniKeywords.MatchFirstIndex.value} = {newIndex}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    
    # fill the attributes for the sections related to the resources
    def _fillTexResource(self, modName: str, sectionName: str, part: IfContentPart, partIndex: int, linePrefix: str, 
                         origSectionName: str, texName: str, oldModName: str, modObjName: str, texGraph: IniSectionGraph):
        """
        Creates the **content part** of an :class:`IfTemplate` for the new `sections`_ created by this fix related to the ``[Resource.*]`` `sections`_
        of a texture file

        .. tip::
            For more info about an 'IfTemplate', see :class:`IfTemplate`

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name for the `section`_

        part: :class:`IfContentPart`
            The content part of the :class:`IfTemplate` of the original ``[Resource.*Blend.*]`` `section`_

        partIndex: :class:`int`
            The index of where the content part appears in the :class:`IfTemplate` of the original `section`_

        linePrefix: :class:`str`
            The text to prefix every line of the created content part

        origSectionName: :class:`str`
            The name of the original `section`_

        texName: :class:`str`
            The name of the type of texture file

        oldModName: :class:`str`
            The name of the type of mod to fix froms

        modObjName: :class:`str`
            The name of the type of mod object associated to the `section`_

        texGraph: :class:`IniSectionGraph`
            The graph where the `section`_ belongs to

        Returns
        -------
        :class:`str`
            The created content part
        """

        addFix = ""

        for varName, varValue, keyInd, _ in part:
            # filling in the subcommand
            if (varName == IniKeywords.Run.value):
                subCommand = self._getRemapName(sectionName, modName, sectionGraph = texGraph, remapNameFunc = lambda sectionName, modName: self.getTexResourceRemapFixName(texName, oldModName, modName, modObjName))
                subCommandStr = f"{IniKeywords.Run.value} = {subCommand}"
                addFix += f"{linePrefix}{subCommandStr}\n"

            # add in the file
            elif (varName == "filename"):
                texModel = self._iniFile.texEditModels[texName][origSectionName]
                fixedTexFile = texModel.fixedPaths[partIndex][modName][keyInd]
                addFix += f"{linePrefix}filename = {fixedTexFile}\n"

            else:
                addFix += f"{linePrefix}{varName} = {varValue}\n"

        return addFix
    
    def _getTexEditFile(self, file: str, texInd: int, modName: str = "") -> str:
        """
        Makes the file path for an editted texture

        Parameters
        ----------
        texFile: :class:`str`
            The file path to the original .dds file

        texInd: :class:`int`
            The index for the type of texture being editted

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapTex.dds file
        """

        texFolder = os.path.dirname(file)
        texName = os.path.basename(file)
        texName = texName.rsplit(".", 1)[0]

        return os.path.join(texFolder, f"{self._iniFile.getRemapTexName(texName, modName = modName)}{texInd}{FileExt.DDS.value}")
    
    # _fixEdittedTextures(modName, fix): get the fix string for editted textures
    def _fixEdittedTextures(self, modName: str, fix: str = ""):
        self._iniFile.texEditModels.clear()

        # rebuild all the models and the section graphs
        texInd = 0
        for texName in self._referencedTexEditSections:
            referencedSections = list(self._referencedTexEditSections[texName])
            referencedSections.sort()

            texGraph = self._parser.getTexGraph(texName)
            if (texGraph is None):
                texInd += 1
                continue

            texGraph.build(newTargetSections = referencedSections)
            texEditor = self._parser.getTexEditor(texName)
            if (texEditor is None):
                texInd += 1
                continue

            self._parser._makeTexModels(texName, texGraph, texEditor, getFixedFile = lambda file, modName: self._getTexEditFile(file, texInd, modName = modName))
            texInd += 1

        texEditInd = 0
        referencedTexEditLen = len(self._referencedTexEditSections)
        modType = self._iniFile.availableType

        # fix the sections
        for texName in self._referencedTexEditSections:
            texGraph = self._parser.getTexGraph(texName)
            if (texGraph is None):
                continue

            texCommandTuples = texGraph.runSequence
            texCommandsLen = len(texCommandTuples)
            modObjName = self._parser.texEditRegs[texName][0]

            for i in range(texCommandsLen):
                commandTuple = texCommandTuples[i]
                section = commandTuple[0]
                ifTemplate = commandTuple[1]

                resourceName = ""
                try:
                    resourceName = self._texEditRemapNames[section]
                except KeyError:
                    resourceName = self._getRemapName(section, modName, sectionGraph = texGraph, remapNameFunc = lambda sectionName, modName: self.getTexResourceRemapFixName(texName, modType.name, modName, modObjName, addInd = True))

                fix += self.fillIfTemplate(modName, resourceName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: self._fillTexResource(modName, sectionName, part, partIndex, linePrefix, origSectionName, texName, modType.name, modObjName, texGraph), origSectionName = section)

                if (i < texCommandsLen - 1):
                    fix += "\n"

            if (texEditInd < referencedTexEditLen - 1):
                fix += "\n"

            texEditInd += 1

        return fix
    
    # _makeTexAddResourceIfTemplate(texName, modName, oldModName, modObj): Creates the IfTemplate for an added texture
    def _makeTexAddResourceIfTemplate(self, texName: str, modName: str, oldModName: str, modObj: str) -> IfTemplate:
        sectionName = ""
        try: 
            self._texAddRemapNames[texName]
        except KeyError:
            self._texAddRemapNames[texName] = {}

        try:
            sectionName = self._texAddRemapNames[texName][modObj]
        except KeyError:
            sectionName = self.getTexResourceRemapFixName(texName, oldModName, modName, modObj)
            self._texAddRemapNames[texName][modObj] = sectionName

        filePartName = sectionName
        if (sectionName.startswith(IniKeywords.Resource.value)):
            filePartName = filePartName[len(IniKeywords.Resource.value):]

        filename = f"{self._iniFile.getRemapTexName(filePartName, modName = modName)}{FileExt.DDS.value}"

        return IfTemplate([
            IfContentPart({"filename": [(0, filename)]}, 0)
        ], name = sectionName)

    # _fixAddedTextures(modName, fix): get the fix string for added textures
    def _fixAddedTextures(self, modName: str, fix: str = "") -> str:
        modType = self._iniFile.availableType

        # retrieve the added textures
        for modObj in self.addedTextures:
            objAddedTexs = self.addedTextures[modObj]

            # create the needed model and add the new resource
            for reg in objAddedTexs:
                texData = objAddedTexs[reg]
                texName = texData[0]
                texEditor = texData[1]

                if (texName not in self._referencedTexAdds):
                    continue

                ifTemplate = self._makeTexAddResourceIfTemplate(texName, modName, modType.name, modObj)
                sectionName = ifTemplate.name
                texModel = self._iniFile.makeTexModel(ifTemplate, self._parser._modsToFix, texEditor, getFixedFile = lambda file, modName: file)

                try:
                    self._iniFile.texAddModels[texName]
                except KeyError:
                    self._iniFile.texAddModels[texName] = {}

                self._iniFile.texAddModels[texName][modObj] = texModel

                fix += self.fillIfTemplate(modName, sectionName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: f"{part.toStr(linePrefix = linePrefix)}\n")
                fix += "\n"

        if (fix and fix[-1] == "\n"):
            fix = fix[:-1]

        return fix
    
    def fixMod(self, modName: str, fix: str = "") -> str:
        self._texEditRemapNames = {}
        self._referencedTexEditSections = {}

        fix = super().fixMod(modName, fix = fix)

        if (self._referencedTexAdds):
            fix += "\n"

        fix = self._fixAddedTextures(modName, fix = fix)

        if (not self._referencedTexAdds and self._referencedTexEditSections):
            fix += "\n"

        if (self._referencedTexEditSections):
            fix += "\n"

        fix = self._fixEdittedTextures(modName, fix = fix)

        if (fix and fix[-1] != "\n"):
            fix += "\n"
        return fix


class RegRemap(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for remapping the register keys for some :class:`IfContentPart`

    Parameters
    ----------
    remap: Optional[Dict[:class:`str`, Dict[:class:`str`, List[:class:`str`]]]]
        Defines how the register values in the parts of an :class:`IfTemplate` are mapped to a new register in the remapped mod for particular mod objects :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod object to have their registers remapped
        * The inner keys are the names of the registers that hold the register values to be remapped
        * The inner values are the new names of the registers that will hold the register values

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ["new_ps-t2", "new_ps-t3"]}, "body": {"ps-t3": [ps-t0"], "ps-t0": [], "ps-t1": ["ps-t8"]}}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    remap: Dict[:class:`str`, Dict[:class:`str`, List[:class:`str`]]]
        Defines how the register values in the parts of an :class:`IfTemplate` are mapped to a new register in the remapped mod for particular mod objects :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the name of the mod objects to have its registers remapped
        * The inner keys are the names of the registers that hold the register values to be remapped
        * The inner values are the new names of the registers that will hold the register values

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": ["new_ps-t2", "new_ps-t3"]}, "body": {"ps-t3": [ps-t0"], "ps-t0": [], "ps-t1": ["ps-t8"]}}``

    _regRemap: Optional[Dict[:class:`str`, List[:class:`str`]]]
        The register remap to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the registers and the values are the newly mapped registers
    """

    def __init__(self, remap: Optional[Dict[str, Dict[str, List[str]]]] = None):
        self.remap = {} if (remap is None) else remap
        self._regRemap: Optional[Dict[str, List[str]]] = None

    def clear(self):
        self._regRemap = None
    
    def _editReg(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        try:
            self._regRemap = self.remap[obj]
        except KeyError:
            return part

        part.remapKeys(self._regRemap)
        return part
    
    def _handleTex(self, currentTexRegs: Set[str]):
        """
        Does post-processing on the current tracked texture registers, 'currentTexRegs'

        Parameters
        ----------
        currentTexRegs: Set[:class:`str`]

        """

        if (self._regRemap is None):
            return

        for reg in self._regRemap:
            if (reg not in currentTexRegs):
                continue
            currentTexRegs.update(set(self._regRemap[reg]))
    
    def handleTexAdd(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        self._handleTex(fixer._currentTexAddsRegs)
    
    def handleTexEdit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        self._handleTex(fixer._currentTexEditRegs)


class RegNewVals(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for assigning new values to specific registers for some :class:`IfContentPart`

    Parameters
    ----------
    vals: Optional[Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]]
        Defines which registers will have their values changed :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the new mod objects where the registers are found
        * The inner keys are the new names of the registers to have their values changed
        * The inner values are the new changed values for the register

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1": "newVal"}, "body": {"ps-t3": "newVal2", "ps-t0": "newVal3"}}`` :raw-html:`<br />` :raw-html:`<br />`


        **Default**: ``None``

    Attributes
    ----------
    vals: Dict[:class:`str`, Dict[:class:`str`, :class:`str`]]
       Defines which registers will have their values changed :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names of the new mod objects where the registers are found
        * The inner keys are the new names of the registers to have their values changed
        * The inner values are the new changed values for the register

    _regUpdates: Optional[Dict[:class:`str`, :class:`str`]]
        The value updates to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the registers and the values are the corresponding values to the registers
    """

    def __init__(self, vals: Optional[Dict[str, Dict[str, str]]] = None):
        self.vals = {} if (vals is None) else vals
        self._regUpdates: Optional[Dict[str, str]] = None

    def clear(self):
        self._regUpdates = None
    
    def _editReg(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        try:
            self._regUpdates = self.vals[obj]
        except KeyError:
            return part

        part.replaceVals(self._regUpdates, addNewKVPs = False)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regUpdates is not None):
            fixer._currentTexAddsRegs = fixer._currentTexAddsRegs.difference(set(self._regUpdates.keys()))

    def handleTexEdit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regUpdates is not None):
            fixer._currentTexEditRegs = fixer._currentTexEditRegs.difference(set(self._regUpdates.keys()))


class RegRemove(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for removing keys from a :class:`IfContentPart`

    Parameters
    ----------
    remove: Optional[Dict[:class:`str`, Set[:class:`str`]]]
        Defines whether some register assignments should be removed from the `sections`_ from the mod objects :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects to have their registers removed and the values are the names of the register to be removed :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1", "ps-t2"}, "body": {"ps-t3", "ps-t0"}}`` :raw-html:`<br />` :raw-html:`<br />`s

        **Default**: ``None``

    Attributes
    ----------
    remove: Dict[:class:`str`, Set[:class:`str`]]
        Defines whether some register assignments should be removed from the `sections`_ of the remapped mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects to have their registers removed and the values are the names of the register to be removed :raw-html:`<br />` :raw-html:`<br />`

        eg. :raw-html:`<br />`
        ``{"head": {"ps-t1", "ps-t2"}, "body": {"ps-t3", "ps-t0"}}``

    _regRemove: Optional[Set[:class:`str`]]
        The register removal to do on the current :class:`IfContentPart` being parsed
    """

    def __init__(self, remove: Optional[Dict[str, Set[str]]] = None):
        self.remove = {} if (remove is None) else remove
        self._regRemove: Optional[Set[str]] = None

    def clear(self):
        self._regRemove = None
    
    def _editReg(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        try:
            self._regRemove = self.remove[obj]
        except KeyError:
            return part

        part.removeKeys(self._regRemove)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regRemove is not None):
            fixer._currentTexAddsRegs = fixer._currentTexAddsRegs.difference(self._regRemove)
    
    def handleTexEdit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regRemove is not None):
            fixer._currentTexEditRegs = fixer._currentTexEditRegs.difference(self._regRemove)


class RegTexEdit(RegEditFilter):
    """
    This class inherits from :class:`RegEditFilter`

    Class for editting texture .dds files to a :class:`IfContentPart`

    Parameters
    ----------
    textures: Optional[Dict[:class:`str`, List[:class:`str`]]]
        Texture .dds files to be editted from existing textures files :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the type of texture files of the mod object
        * The values are the name of the registers to hold the editted textures

        eg. :raw-html:`<br />`
        ``{"NormalMap": ["ps-t1", "r13", "ps-t0"], "ShinyMetalMap": ["ps-t2"]}`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _regEditVals: Optional[Dict[:class:`str`, :class:`str`]]
        The texture edits to do on the current :class:`IfContentPart` being parsed :raw-html:`<br />` :raw-html:`<br />`

        The keys are the name of the registers and the values are the `section`_ names for the textures
    """

    def __init__(self, textures: Optional[Dict[str, List[str]]] = None):
        self.textures = {} if (textures is None) else textures
        self._regEditVals: Dict[str, str] = None

    @property
    def textures(self) -> Dict[str, List[str]]:
        """
        Texture .dds files to be editted from existing textures files :raw-html:`<br />` :raw-html:`<br />`

        * The keys are the name of the type of texture files of the mod object
        * The values are the name of the registers to hold the editted textures

        eg. :raw-html:`<br />`
        ``{"NormalMap": ["ps-t1", "r13", "ps-t0"], "ShinyMetalMap": ["ps-t2"]}``

        :getter: Retrieves the texture .dds files to be editted by register
        :setter: Sets the textures to be editted
        :type: Dict[:class:`str`, List[:class:`str`]]
        """

        return self._textures
    
    @textures.setter
    def textures(self, newTextures: Dict[str, List[str]]):
        self._textures = {}

        for texName in newTextures:
            self._textures[texName] = ListTools.getDistinct(newTextures[texName], keepOrder = True)

    def clear(self):
        self._regEditVals = None

    # _addTexEditCalledResources(part, result, regTexEditResult, oldSection, objName, reg, texTypeName, oldModName, newModeName, fixer): 
    #   Adds in the new editted resources section name into 'result'
    def _addTexEditCalledResources(self, part: IfContentPart, result: Dict[str, str], objName: str, reg: str, texTypeName: str, 
                                   oldModName: str, newModName: str, fixer: "GIMIObjReplaceFixer"):
        if (reg not in part):
            return

        # get the new registers for the editted resource
        texNewRegs = None
        try:
            texNewRegs = self.textures[texTypeName]
        except KeyError:
            return
        
        # get the current referenced resource by the editted texture
        currentRegVals = ListTools.getDistinct(part.getVals(reg), keepOrder = True)
        if (not currentRegVals):
            return
        currentRegResource = currentRegVals[-1]
        
        # get the name for the editted texture resource section
        texRemapFixName = None
        try:
            texRemapFixName = fixer._texEditRemapNames[currentRegResource]
        except KeyError:
            texRemapFixName = fixer.getTexResourceRemapFixName(texTypeName, oldModName, newModName, objName, addInd = True)
            fixer._texEditRemapNames[currentRegResource] = texRemapFixName

        for newReg in texNewRegs:
            result[newReg] = texRemapFixName
            fixer._currentRegTexEdits[newReg] = (texTypeName, currentRegResource)
    
    def _editReg(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer") -> IfContentPart:
        texEdits = None
        try:
            texEdits = fixer._parser.texEdits[obj]
        except KeyError:
            return part

        self._regEditVals = {}
        DictTools.forDict(texEdits, ["reg", "texName"], 
                          lambda keys, values: self._addTexEditCalledResources(part, self._regEditVals, obj, keys["reg"], keys["texName"], modType.name, fixModName, fixer))
        part.replaceVals(self._regEditVals, addNewKVPs = True)
        return part
    
    def handleTexAdd(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        return
    
    def handleTexEdit(self, part: IfContentPart, modType: ModType, fixModName: str, obj: str, sectionName: str, fixer: "GIMIObjReplaceFixer"):
        if (self._regEditVals is not None):
            fixer._currentTexEditRegs.update(set(self._regEditVals.keys()))


class GIMIObjSplitFixer(GIMIObjReplaceFixer):
    """
    This class inherits from :class:`GIMIObjReplaceFixer`

    Fixes a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap
    are split into multiple mod objects in remapped mod

        
    eg.

    .. code-block::

        KeqingOpulent's "body" is split into Keqing's "body" and "dress"

        KeqingOpulent             Keqing
       ===============       =================
       *** objects ***       **** objects ****
           body  -------+------>   body
           head         |          head
                        +------>   dress    

    .. note::
        For the order of how the registers are fixed, please see :class:`GIMIObjReplaceFixer`

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    objs: Dict[:class:`str`, List[:class:`str`]]
        The mod objects that will be split into multiple new mod objects :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mod objects to be split and the values are the names of the new mod objects the original mod object will be split into :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            The dictionary keys should align with the defined object names at :meth:`GIMIObjParser.objs` for your parser

        :raw-html:`<br />`

        .. warning::
            If multiple mod objects split into the same object, then the resultant .ini file will contain duplicate `sections`_ for that particular mod object

            eg. :raw-html:`<br />`
            ``{"body": ["dress", "extra"], "head": ["face", "extra"]}``

    regEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. Filters are executed based on the order specified in the list.
    """

    def __init__(self, parser: GIMIObjParser, objs: Dict[str, List[str]], regEditFilters: Optional[List[BaseRegEditFilter]] = None):
        super().__init__(parser, regEditFilters = regEditFilters, regEditOldObj = False)
        self.objs = objs


    @property
    def objs(self) -> Dict[str, List[str]]:
        """
        The mods objects that will be split to multiple other mod objects :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the objects in the mod to be remapped and the values are the split objects of the remapped mod

        :getter: Retrieves the mods objects
        :setter: Sets the new objects
        :type: Dict[:class:`str`, List[:class:`str`]]
        """

        return self._objs
    
    @objs.setter
    def objs(self, newObjs: Dict[str, List[str]]):
        self._objs = {}
        for toFixObj in newObjs:
            fixedObjs = newObjs[toFixObj]
            newToFixObj = toFixObj.lower()
            self._objs[newToFixObj] = []

            for fixedObj in fixedObjs:
                newFixedObj = fixedObj.lower()
                self._objs[newToFixObj].append(newFixedObj)

            self._objs[newToFixObj] = ListTools.getDistinct(self._objs[newToFixObj], keepOrder = True)

        # add in the objects that will have their registers editted
        regEditObjs = set()
        for filter in self.regEditFilters:
            if (isinstance(filter, RegRemap)):
                regEditObjs.update(set(filter.remap.keys()))
            elif (isinstance(filter, RegRemove)):
                regEditObjs.update(set(filter.remove.keys()))
            elif (isinstance(filter, RegNewVals)):
                regEditObjs.update(set(filter.vals.keys()))
            elif (isinstance(filter, RegTexAdd)):
                regEditObjs.update(set(filter.textures.keys()))

        regEditObjs = regEditObjs.difference(set(self._objs.keys()))
        for obj in regEditObjs:
            cleanedObj = obj.lower()
            self._objs[cleanedObj] = [cleanedObj]


    def _fixNonBlendHashIndexCommands(self, modName: str, fix: str = ""):
        fixerObjsToFix = set(self.objs.keys())
        objsToFix = list(self._parser.objs.intersection(fixerObjsToFix))
        objsToFix.sort()
        sectionsToIgnore = set()

        # get which section to ignore
        for objToFix in objsToFix:
            objGraph = self._parser.objGraphs[objToFix]
            sectionsToIgnore = sectionsToIgnore.union(objGraph.sections)

        nonBlendCommandTuples = self._parser.nonBlendHashIndexCommandsGraph.runSequence
        for commandTuple in nonBlendCommandTuples:
            section = commandTuple[0]
            ifTemplate = commandTuple[1]

            if (section in sectionsToIgnore):
                continue

            commandName = self._getRemapName(section, modName, sectionGraph = self._parser.nonBlendHashIndexCommandsGraph)
            fix += self.fillIfTemplate(modName, commandName, ifTemplate, self._fillNonBlendSections)
            fix += "\n"

        # retrieve the fix for all the split mod objects
        for objToFix in objsToFix:
            fixedObjs = self.objs[objToFix]
            objGraph = self._parser.objGraphs[objToFix]

            if (not objGraph.sections):
                continue
            
            objGraphTuples = objGraph.runSequence
            for commandTuple in objGraphTuples:
                section = commandTuple[0]
                ifTemplate = commandTuple[1]

                for fixedObj in fixedObjs:
                    commandName = self.getObjRemapFixName(section, modName, objToFix, fixedObj)
                    fix += self.fillIfTemplate(modName, commandName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: self.fillObjNonBlendSection(modName, sectionName, part, partIndex, linePrefix, origSectionName, objToFix, fixedObj))
                    fix += "\n"

        # fix for objects with 
        return fix  


class FileSuffixes(Enum):
    RemapFixCopy = "RemapFix"


class GIMIObjMergeFixer(GIMIObjReplaceFixer):
    """
    This class inherits from :class:`GIMIObjReplaceFixer`

    Fixes a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap are merged to a single mod object

    eg. 

    .. code-block::

        Keqing's "body" and "dress" are merged into KeqingOpulent's "body"

           Keqing             KeqingOpulent
       ===============       =================
       *** objects ***       **** objects ****
           body      -----+---->   body
           head           |        head
           dress     -----+  

    .. note::
        This class takes advantage of GIMI's bug/feature of overlapping mods from loading multiple mods of the same character by creating different variations of the original .ini file

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    objs: Dict[:class:`str`, List[:class:`str`]]
        The mod objects to be merged to a single mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the merged objects and the values are the names of the mod objects to be merged :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            The dictionary values should align with the defined object names at :meth:`GIMIObjParser.objs` for your parser

    copyPreamble: :class:`str`
        Any text we want to put before the text of the newly generated .ini file variations :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``""``

    Attributes
    ----------
    _targetObjs: Dict[:class:`str`, :class:`str`]
        Which original mod objects to show for each merged mod object in the current .ini file :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the original mod objects to display on the current .ini file and the values are the names of the merged objects.

    copyPreamble: :class:`str`
        Any text we want to put before the text of the newly generated .ini file variations
    """

    def __init__(self, parser: GIMIObjParser, objs: Dict[str, List[str]], copyPreamble: str = ""):
        super().__init__(parser)
        self._targetObjs: Dict[str, str] = {}
        self._maxObjsToMergeLen = 0
        self._sectionsToIgnore: Set[str] = set()
        self.objs = objs

        self.copyPreamble = copyPreamble

    @property
    def objs(self):
        """
        The mod objects to be merged to a single mod object :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the merged objects and the values are the names of the mod objects to be merged

        :getter: Retrieves the mod objects to be merged
        :setter: Set the new mod objects to be merged
        :type: Dict[:class:`str`, List[:class:`str`]]
        """

        return self._objs
    
    @objs.setter
    def objs(self, newObjs: Dict[str, List[str]]):
        self._objs = {}

        for mergedObj in newObjs:
            objsToMerge = newObjs[mergedObj]
            self._objs[mergedObj] = objsToMerge
            self._maxObjsToMergeLen = max(self._maxObjsToMergeLen, len(objsToMerge))


    def _fixNonBlendHashIndexCommands(self, modName: str, fix: str = ""):
        nonBlendCommandTuples = self._parser.nonBlendHashIndexCommandsGraph.runSequence
        for commandTuple in nonBlendCommandTuples:
            section = commandTuple[0]
            ifTemplate = commandTuple[1]

            if (section in self._sectionsToIgnore):
                continue

            commandName = self._getRemapName(section, modName, sectionGraph = self._parser.nonBlendHashIndexCommandsGraph)
            fix += self.fillIfTemplate(modName, commandName, ifTemplate, self._fillNonBlendSections)
            fix += "\n"

        # retrieve the fix for all the merged mod objects
        for objToFix in self._targetObjs:
            fixedObj = self._targetObjs[objToFix]
            objGraph = self._parser.objGraphs[objToFix]

            if (not objGraph.sections):
                continue
            
            objGraphTuples = objGraph.runSequence
            for commandTuple in objGraphTuples:
                section = commandTuple[0]
                ifTemplate = commandTuple[1]
                commandName = self.getObjRemapFixName(section, modName, objToFix, fixedObj)
                fix += self.fillIfTemplate(modName, commandName, ifTemplate, lambda modName, sectionName, part, partIndex, linePrefix, origSectionName: self.fillObjNonBlendSection(modName, sectionName, part, partIndex, linePrefix, origSectionName, objToFix, fixedObj))
                fix += "\n"

        return fix

    
    # _getCurrentTargetObjs(ind): Retrieves the current mod objects to show in the current .ini file for each merged mod object
    def _getCurrentTargetObjs(self, ind: int):
        self._targetObjs = {}
        for mergedObj in self._objs:
            objsToMerge = self._objs[mergedObj]
            if (ind <= len(objsToMerge) - 1):
                objToMerge = objsToMerge[ind]
                self._targetObjs[objToMerge] = mergedObj

    # _getIgnoredSections(): Retrieves which sections to ignore when performing the normal part of the fix
    def _getIgnoredSections(self):
        objsToFix = copy.deepcopy(self._parser.objs)
        ignoredObjs = set()
        self._sectionsToIgnore = set()

        # get which section to ignore
        for mergedObj in self._objs:
            objsToFix = self._objs[mergedObj]

            for objToFix in objsToFix:
                if (objToFix in ignoredObjs):
                    continue

                ignoredObjs.add(objToFix)
                objGraph = None
                try:
                    objGraph = self._parser.objGraphs[objToFix]
                except:
                    continue

                self._sectionsToIgnore = self._sectionsToIgnore.union(objGraph.sections)


    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, withBoilerPlate: bool = True, withSrc: bool = True) -> Union[str, List[str]]:
        result = []
        iniFilePath = self._iniFile.filePath
        iniBaseName = iniFilePath.baseName
        self._getIgnoredSections()

        for i in range(self._maxObjsToMergeLen):
            self._getCurrentTargetObjs(i)
            if (i > 0 and iniFilePath is not None):
                iniFilePath.baseName = f"{iniBaseName}{FileSuffixes.RemapFixCopy.value}{i}"

            currentResult = super()._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, withBoilerPlate = withBoilerPlate, withSrc = withSrc)

            if (i > 0 and withSrc and self.copyPreamble != ""):
                currentResult = f"{self.copyPreamble}\n\n{currentResult}"

            self._iniFile.write(txt = currentResult)
            result.append(currentResult)

        iniFilePath.baseName = iniBaseName
        if (len(result) == 1):
            result = result[0]

        return result


class GIMIObjRegEditFixer(GIMIObjSplitFixer):
    """
    This class inherits from :class:`GIMIObjSplitFixer`

    Fixes a .ini file used by a GIMI related importer where particular mod objects (head, body, dress, etc...) in the mod to remap
    needs to have their registers remapped or removed

    .. note::
        For the order of how the registers are fixed, please see :class:`GIMIObjReplaceFixer`

    Parameters
    ----------
    parser: :class:`GIMIObjParser`
        The associated parser to retrieve data for the fix

    regEditFilters: Optional[List[:class:`BaseRegEditFilter`]]
        Filters used to edit the registers of a certain :class:`IfContentPart`. Filters are executed based on the order specified in the list.
    """

    def __init__(self, parser: GIMIObjParser, regEditFilters: Optional[List[BaseRegEditFilter]] = None):
        super().__init__(parser, {}, regEditFilters = regEditFilters)

        parserObjs = sorted(self._parser.objs)
        for obj in parserObjs:
            if (obj not in self.objs):
                self.objs[obj] = [obj] 


class MultiModFixer(BaseIniFixer):
    """
    This class inherits from :class:`BaseIniFixer`

    Fixes a .ini file where each mod to fix requires a different :class:`BaseIniFixer` strategy

    Parameters
    ----------
    parser: :class:`BaseIniParser`
        The associated parser to retrieve data for the fix

    fixBuilders: Dict[:class:`str`, :class:`IniFixBuilder`]
        The different builders to dynamcally construct the :class:`BaseIniFixer` used for each mod to fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mods to fix and the values are the different :class:`IniFixBuilder` used to construct the :class:`BaseIniFixer` to fix the mod

    Attributes
    ----------
    _fixBuilders: Dict[:class:`str`, :class:`IniFixBuilder`]
        The different builders to dynamcally construct the :class:`BaseIniFixer` used for each mod to fix :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mods to fix and the values are the different :class:`IniFixBuilder` used to construct the :class:`BaseIniFixer` to fix the mod

    _fixers: Dict[:class:`str`, :class:`BaseIniFixer`]
        The different fixers to fix each type of mod :raw-html:`<br />` :raw-html:`<br />`

        The keys are the names of the mods to fix and the values are the fixers to fix the mod
    """

    def __init__(self, parser: BaseIniParser, fixBuilders: Dict[str, "IniFixBuilder"]):
        super().__init__(parser)
        self._fixBuilders = fixBuilders
        self._fixers: Dict[str, BaseIniFixer] = {}
        self.buildFixers()

    def buildFixers(self):
        """
        Rebuilds the :class:`BaseIniFixer` used for each mod
        """

        self._fixers = {}
        for modToFix in self._fixBuilders:
            self._fixers[modToFix] = self._fixBuilders[modToFix].build(self._parser)

    # _mergeFix(resultFix, currentFix): Merges the current fix results into the resultant fix
    def _mergeFix(self, resultFix: List[str], currentFix: List[str]):
        resultFixLen = len(resultFix)
        currentFixLen = len(currentFix)
        minFixLen = min(resultFixLen, currentFixLen)

        for i in range(minFixLen):
            resultFix[i] += currentFix[i]

        if (currentFixLen > resultFixLen):
            resultFix.append(currentFix[i])

    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, withBoilerPlate: bool = True) -> Union[str, List[str]]:
        modsToFix = self._parser._modsToFix.intersection(set(self._fixers.keys()))
        sortedModsToFix = list(modsToFix)
        sortedModsToFix.sort()

        iniFilePath = self._iniFile.file
        self._iniFile.file = None
        result = [""]

        # retrieve the results for each fixer
        for modToFix in sortedModsToFix:
            self._parser._modsToFix = {modToFix}
            fixer = self._fixers[modToFix]
            self._iniFile._iniFixer = fixer
            currentResult = fixer._fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update, withBoilerPlate = False, withSrc = False)
            self._iniFile._isFixed = False

            if (isinstance(currentResult, str)):
                result[0] += currentResult
            else:
                self._mergeFix(result, currentResult)

        self._parser._modsToFix = modsToFix
        self._iniFile.file = iniFilePath

        resultLen = len(result)
        iniFilePath = self._iniFile.filePath
        iniBaseName = iniFilePath.baseName

        # add the boilerplate
        for i in range(resultLen):
            if (withBoilerPlate):
                result[i] = f"\n\n{self._iniFile.addFixBoilerPlate(fix = result[i])}"

            if (iniFilePath is not None and i > 0):
                iniFilePath.baseName = f"{iniBaseName}{FileSuffixes.RemapFixCopy.value}{i}"

            result[i] = self._iniFile.injectAddition(result[i], beforeOriginal = False, keepBackup = keepBackup, fixOnly = fixOnly, update = update)
            self._iniFile._isFixed = False

        self._iniFile._isFixed = True
        iniFilePath.baseName = iniBaseName
        if (resultLen == 1):
            result = result[0]
        
        return result


class BasePixelFilter():
    """
    Base class for transforming a pixel in a texture file
    """

    def transform(self, pixel: Colour):
        """
        Applies a Transformation to 'pixel'

        Parameters
        ----------
        pixel: :class:`Colour`
            The pixel to be editted
        """

        pass


class BaseTexFilter():
    """
    Base class for transforming a texture file
    """

    def transform(self, texFile: "TextureFile"):
        """
        Applies a Transformation to 'texFile'

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture to be editteds
        """

        pass


class TexEditor(BaseTexEditor):
    """
    This class inherits from :class:`BaseTexEditor`

    Class for editing a texture file

    Parameters
    ----------
    pixelFilters: Optional[List[Union[:class:`BasePixelFilter`, Callable[[:class:`Colour`], Any]]]]
        The filters to edit a single pixel in the texture file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    preProcessor: Optional[List[Union[:class:`BaseTexFilter`, Callable[[:class:`TextureFile`], Any]]]]
        The pre-processors that transform the loaded image before the individual pixels are editted by :attr:`TexEditor.pixelFilters` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    postProcessor: Optional[List[Union[:class:`BaseTexFilter`, Callable[[:class:`TextureFile`], Any]]]]
        The post-processors that transform the loaded image after the individual pixels are editted by :attr:`TexEditor.pixelFilters` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    pixelFilters: List[Union[:class:`BasePixelFilter`, Callable[[:class:`Colour`], :class:`Colour`]]]
        The filters to edit a single pixel in the texture file

    preProcessors: List[Union[:class:`BaseTexFilter`, Callable[[:class:`TextureFile`], Any]]]
        The pre-processors that transform the loaded image before the individual pixels are editted by :attr:`TexEditor.pixelFilters`

    postProcessors: List[Union[:class:`BaseTexFilter`, Callable[[:class:`TextureFile`], Any]]]
        The post-processors that transform the loaded image after the individual pixels are editted by :attr:`TexEditor.pixelFilters`
    """

    def __init__(self, pixelFilters: Optional[List[Union[BasePixelFilter, Callable[[Colour], Colour]]]] = None,
                 preProcessors: Optional[List[Union[BaseTexFilter, Callable[[TextureFile], Any]]]] = None,
                 postProcessors: Optional[List[Union[BaseTexFilter, Callable[[TextureFile], Any]]]] = None):
        super().__init__()
        self.pixelFilters = [] if (pixelFilters is None) else pixelFilters
        self.preProcessors = [] if (preProcessors is None) else preProcessors
        self.postProcessors = [] if (postProcessors is None) else postProcessors

    def fix(self, texFile: TextureFile, fixedTexFile: str):
        texFile.open()
        if (texFile.img is None):
            return

        if (self.preProcessors):
            for preProcessor in self.preProcessors:
                preProcessor(texFile)

        if (self.pixelFilters):
            pixels = texFile.read()
            pixelColour = Colour()

            for y in range(texFile.img.size[1]):
                for x in range(texFile.img.size[0]):
                    pixel = pixels[x, y]
                    pixelColour.fromTuple(pixel)

                    for filter in self.pixelFilters:
                        if (isinstance(filter, BasePixelFilter)):
                            filter.transform(pixelColour)
                        else:
                            filter(pixelColour)

                    pixels[x, y] = pixelColour.getTuple()

        if (self.postProcessors):
            for postProcessor in self.postProcessors:
                postProcessor(texFile)

        texFile.src = fixedTexFile
        texFile.save()

    @classmethod
    def adjustBrightness(self, texFile: TextureFile, brightness: float):
        """
        Adjust the brightness of the texture

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture file to be editted

        brightness: :class:`float`
            The brightness to adjust the texture. :raw-html:`<br />` :raw-html:`<br />`

            0 => make the image black
            1 => original brightness of the image
            >1 => make the image brighter
        """

        ImageEnhance = Packager.get("PIL.ImageEnhance", "pillow")
        
        enhancer = ImageEnhance.Brightness(texFile.img)
        texFile.img = enhancer.enhance(brightness)

    @classmethod
    def adjustTranparency(self, texFile: TextureFile, alpha: int):
        """
        Adjust the transparency of the texture

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture file to be editted

        alpha: :class:`int`
            The value for the alpha (transparency) channel of each pixel. Range from 0 - 255. :raw-html:`<br />` :raw-html:`<br />`

            0 => Transparent
            255 => Opaque
        """

        texFile.img.putalpha(alpha)

    @classmethod
    def adjustSaturation(self, texFile: TextureFile, saturation: float):
        """
        Adjust the saturation of the texture

        Parameters
        ----------
        texFile: :class:`TextureFile`
            The texture file to be editted

        brightness: :class:`float`
            The brightness to adjust the texture. :raw-html:`<br />` :raw-html:`<br />`

            0 => make the image black and white
            1 => original saturation of the image
            >1 => make the image really saturated like a TV
        """

        ImageEnhance = Packager.get("PIL.ImageEnhance", "pillow")

        enhancer = ImageEnhance.Color(texFile.img)
        texFile.img = enhancer.enhance(saturation)


class ColourReplace(BasePixelFilter):
    """
    This class inherits from :class:`BasePixelFilter`

    Replaces a coloured pixel

    Paramaters
    ----------
    replaceColour: :class:`Colour`
        The colour to fill in

    colourToReplace: Optional[Union[:class:`Colour`, :class:`ColourRange`]]
        The colour to find to be replaced. If this value is ``None``, then will always replace the colour of the pixel :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    replaceAlpha: :class:`bool`
        Whether to also replace the alpha channel of the original colour :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    replaceColour: :class:`Colour`
        The colour to fill in

    colourToReplace: Optional[Union[:class:`Colour`, :class:`ColourRange`]]
        The colour to find to be replaced. If this value is ``None``, then will always replace the colour of the pixel

    replaceAlpha: :class:`bool`
        Whether to also replace the alpha channel of the original colour
    """

    def __init__(self, replaceColour: Colour, colourToReplace: Optional[Union[Colour, ColourRange]] = None, replaceAlpha: bool = True):
        self.colourToReplace = colourToReplace
        self.replaceColour = replaceColour
        self.replaceAlpha = replaceAlpha

    def transform(self, pixel: Colour):
        if (self.colourToReplace is None or self.colourToReplace.match(pixel)):
            pixel.copy(self.replaceColour, withAlpha = self.replaceAlpha)


class HighlightShadow(BasePixelFilter):
    """
    This class inherits from :class:`BasePixelFilter`

    A filter that approximates the adjustment of the shadow/hightlight of an image

    .. note::
        Reference: `Highlight Shadow Approximation Reference`_

    Parameters
    ----------
    highlight: :class:`float`
        The amount of highlight to apply to the pixel. Range from -1 to 1, and 0 = no change :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``0``

    Attributes
    ----------
    highlight: :class:`float`
        The amount of shadow to apply to the pixel. Range from -1 to 1, and 0 = no change
    """
    def __init__(self, highlight: float = 0, shadow: float = 0):
        self.highlight = highlight
        self.shadow = shadow

    def transform(self, pixel: Colour):
        lumR = 0.299
        lumG = 0.587
        lumB = 0.114

        normRed = pixel.red / ColourConsts.MaxColourValue.value
        normGreen = pixel.green / ColourConsts.MaxColourValue.value
        normBlue = pixel.blue / ColourConsts.MaxColourValue.value

        # we have to find luminance of the pixel
        # here 0.0 <= source.r/source.g/source.b <= 1.0 
        # and 0.0 <= luminance <= 1.0

        luminance = math.sqrt(lumR * pow(normRed, 2.0) + lumG * pow(normGreen, 2.0) + lumB * pow(normBlue, 2.0))

        # here highlights and and shadows are our desired filter amounts
        # highlights/shadows should be >= -1.0 and <= +1.0
        #  highlights = shadows = 0.0 by default
        # you can change 0.05 and 8.0 according to your needs but okay for me

        h = self.highlight * 0.07 * ( pow(18.0, luminance) - 1.0 )
        s = self.shadow * 0.07 * ( pow(18.0, 1.0 - luminance) - 1.0 )

        pixel.red = Colour.boundColourChannel(round((normRed + h + s) * ColourConsts.MaxColourValue.value))
        pixel.green = Colour.boundColourChannel(round((normGreen + h + s) * ColourConsts.MaxColourValue.value))
        pixel.blue = Colour.boundColourChannel(round((normBlue + h + s) * ColourConsts.MaxColourValue.value))


class TempControl(BasePixelFilter):
    """
    This class inherits from :class:`BasePixelFilter`

    Controls the temperature of a texture file

    Parameters
    ----------
    temp: :class:`int`
        The temperature to set the image. Range from -100 to 100 :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``
    """
    def __init__(self, temp: int = 0):
        self.temp = temp

    def transform(self, pixel: Colour):
        pixel.red = pixel.boundColourChannel(pixel.red + self.temp)
        pixel.blue = pixel.boundColourChannel(pixel.blue - self.temp)


class HueAdjust(BaseTexFilter):
    """
    This class inherits from :class:`BaseTexFilter`

    Adjusts the hue of a texture file

    Parameters
    ----------
    hue: :class:`int`
        The hue to adjust the image. Value is from -180 to 180
    """

    def __init__(self, hue: int):
        self.hue = hue

    def _adjustHue(self, hue: int) -> int:
        """
        Adjusts the hue

        Parameters
        ----------
        hue: :class:`int`
            The current hue that has not been adjust yet

        Returns
        -------
        :class:`int`
            The adjusted hue
        """

        result = hue + self.hue
        if (result > ColourConsts.MaxColourDegree.value):
            result = ColourConsts.MaxColourDegree.value - result
        elif (result < ColourConsts.MinColourDegree.value):
            result += ColourConsts.MaxColourValue.value

        return result
        

    def transform(self, texFile: "TextureFile"):
        Image = Packager.get("PIL.Image", "pillow")

        alphaImg = texFile.img.getchannel('A')

        texFile.img = texFile.img.convert(ImgFormats.HSV.value)
        hImg, sImg, vImg = texFile.img.split()

        hImg = hImg.point(lambda hueVal: self._adjustHue(hueVal))

        texFile.img = Image.merge(ImgFormats.HSV.value, (hImg, sImg, vImg))
        texFile.img = texFile.img.convert(ImgFormats.RGBA.value)
        texFile.img.putalpha(alphaImg)


class GIBuilder(ModTypeBuilder):
    """
    This Class inherits from :class:`ModTypeBuilder`

    Creates new :class:`ModType` objects for some anime game
    """

    @classmethod
    def amber(cls) -> ModType:
        """
        Creates the :class:`ModType` for Amber

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Amber", re.compile(r"^\s*\[\s*TextureOverride.*(Amber)((?!(RemapBlend|CN)).)*Blend.*\s*\]"), 
                    Hashes(map = {"Amber": {"AmberCN"}}),Indices(map = {"Amber": {"AmberCN"}}),
                    aliases = ["BaronBunny", "ColleisBestie"],
                    vgRemaps = VGRemaps(map = {"Amber": {"AmberCN"}}))

    @classmethod
    def amberCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for AmberCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("AmberCN", re.compile(r"^\s*\[\s*TextureOverride.*(AmberCN)((?!RemapBlend).)*Blend.*\s*\]"), 
                    Hashes(map = {"AmberCN": {"Amber"}}),Indices(map = {"AmberCN": {"Amber"}}),
                    aliases = ["BaronBunnyCN", "ColleisBestieCN"],
                    vgRemaps = VGRemaps(map = {"AmberCN": {"Amber"}}))

    @classmethod
    def arlecchino(cls) -> ModType:
        """
        Creates the :class:`ModType` for Arlecchino

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Arlecchino", re.compile(r"^\s*\[\s*TextureOverride.*(Arlecchino)((?!RemapBlend).)*Blend.*\s*\]"), 
                    Hashes(map = {"Arlecchino": {"ArlecchinoBoss"}}), Indices(map = {"Arlecchino": {"ArlecchinoBoss"}}),
                    aliases = ["Father", "Knave", "Perrie", "Peruere", "Harlequin"],
                    vgRemaps = VGRemaps(map = {"Arlecchino": {"ArlecchinoBoss"}}))
    
    @classmethod
    def barbara(cls) -> ModType:
        """
        Creates the :class:`ModType` for Barbara

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Barbara", re.compile(r"^\s*\[\s*TextureOverride.*(Barbara)((?!RemapBlend|Summertime).)*Blend.*\s*\]"), 
                    Hashes(map = {"Barbara": {"BarbaraSummertime"}}),Indices(map = {"Barbara": {"BarbaraSummertime"}}),
                    aliases = ["Idol", "Healer"],
                    vgRemaps = VGRemaps(map = {"Barbara": {"BarbaraSummertime"}}))
    
    @classmethod
    def barbaraSummerTime(cls) -> ModType:
        """
        Creates the :class:`ModType` for BarbaraSummerTime

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("BarbaraSummertime", re.compile(r"^\s*\[\s*TextureOverride.*(BarbaraSummertime)((?!RemapBlend).)*Blend.*\s*\]"), 
                    Hashes(map = {"BarbaraSummertime": {"Barbara"}}),Indices(map = {"BarbaraSummertime": {"Barbara"}}),
                    aliases = ["IdolSummertime", "HealerSummertime", "BarbaraBikini"],
                    vgRemaps = VGRemaps(map = {"BarbaraSummertime": {"Barbara"}}))
    
    @classmethod
    def fischl(cls) -> ModType:
        """
        Creates the :class:`ModType` for Fischl

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Fischl", re.compile(r"^\s*\[\s*TextureOverride.*(Fischl)((?!RemapBlend|Highness).)*Blend.*\s*\]"), 
                    Hashes(map = {"Fischl": {"FischlHighness"}}),Indices(map = {"Fischl": {"FischlHighness"}}),
                    aliases = ["Amy", "Chunibyo", "8thGraderSyndrome", "Delusional", "PrinzessinderVerurteilung", "MeinFraulein", " FischlvonLuftschlossNarfidort", "PrincessofCondemnation", "TheCondemedPrincess", "OzsMiss"],
                    vgRemaps = VGRemaps(map = {"Fischl": {"FischlHighness"}}),
                    iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body", "dress"}]),
                    iniFixBuilder = IniFixBuilder(GIMIObjMergeFixer, args = [{"body": ["body", "dress"]}], kwargs = {"copyPreamble": IniComments.GIMIObjMergerPreamble.value}))
    
    @classmethod
    def fischlHighness(cls) -> ModType:
        """
        Creates the :class:`ModType` for FischlHighness

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("FischlHighness", re.compile(r"^\s*\[\s*TextureOverride.*(FischlHighness)((?!RemapBlend).)*Blend.*\s*\]"), 
                    Hashes(map = {"FischlHighness": {"Fischl"}}),Indices(map = {"FischlHighness": {"Fischl"}}),
                    aliases = ["PrincessAmy", "RealPrinzessinderVerurteilung", "Prinzessin", "PrincessFischlvonLuftschlossNarfidort", "PrinzessinFischlvonLuftschlossNarfidort", "ImmernachtreichPrincess", 
                               "PrinzessinderImmernachtreich", "PrincessoftheEverlastingNight", "OzsPrincess"],
                    vgRemaps = VGRemaps(map = {"FischlHighness": {"Fischl"}}),
                    iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body", "head"}]),
                    iniFixBuilder = IniFixBuilder(GIMIObjSplitFixer, args = [{"body": ["body", "dress"]}], kwargs = {"regEditFilters": [
                        RegRemove(remove = {"head": {"ps-t2"}}),
                        RegRemap(remap = {"head": {"ps-t3": ["ps-t2"]}})
                    ]}))
    
    @classmethod
    def ganyu(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ganyu

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        hueFilter = HueAdjust(5)

        return ModType("Ganyu", re.compile(r"^\s*\[\s*TextureOverride.*(Ganyu)((?!(RemapBlend|Twilight)).)*Blend.*\s*\]"), 
                    Hashes(map = {"Ganyu": {"GanyuTwilight"}}),Indices(map = {"Ganyu": {"GanyuTwilight"}}),
                    aliases = ["Cocogoat"],
                    vgRemaps = VGRemaps(map = {"Ganyu": {"GanyuTwilight"}}),
                    iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"head"}], 
                                                      kwargs = {"texEdits": {"head": {"ps-t0": {"DarkDiffuse": TexEditor(pixelFilters = [HighlightShadow(highlight = 0.3, shadow = -0.7)],
                                                                                                                         preProcessors = [lambda texFile: TexEditor.adjustTranparency(texFile, 32),
                                                                                                                                          lambda texFile: TexEditor.adjustBrightness(texFile, 0.7),
                                                                                                                                          lambda texFile: TexEditor.adjustSaturation(texFile, 1.27)],
                                                                                                                                          
                                                                                                                         postProcessors = [
                                                                                                                                           lambda texFile: hueFilter.transform(texFile)
                                                                                                                                           ])}}}}),
                    iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                        RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"]}}),
                        RegTexEdit(textures = {"DarkDiffuse": ["ps-t1"]}),
                        RegTexAdd(textures = {"head": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}})
                    ]}))
    
    @classmethod
    def ganyuTwilight(cls) -> ModType:
        """
        Creates the :class:`ModType` for GanyuTwilight

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("GanyuTwilight", re.compile(r"^\s*\[\s*TextureOverride.*(GanyuTwilight)((?!(RemapBlend)).)*Blend.*\s*\]"), 
                    Hashes(map = {"GanyuTwilight": {"Ganyu"}}),Indices(map = {"GanyuTwilight": {"Ganyu"}}),
                    aliases = ["GanyuLanternRite", "LanternRiteGanyu", "CocogoatTwilight", "CocogoatLanternRite", "LanternRiteCocogoat"],
                    vgRemaps = VGRemaps(map = {"GanyuTwilight": {"Ganyu"}}),
                    iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"head"}]),
                    iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                        RegRemove(remove = {"head": {"ps-t0"}}),
                        RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"]}})
                    ]}))

    @classmethod
    def jean(cls) -> ModType:
        """
        Creates the :class:`ModType` for Jean

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Jean", re.compile(r"^\s*\[\s*TextureOverride.*(Jean)((?!(RemapBlend|CN|Sea)).)*Blend.*\s*\]"), 
                   Hashes(map = {"Jean": {"JeanCN", "JeanSea"}}), Indices(map = {"Jean": {"JeanCN", "JeanSea"}}),
                   aliases = ["ActingGrandMaster", "KleesBabySitter"],
                   vgRemaps = VGRemaps(map = {"Jean": {"JeanCN", "JeanSea"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body"}]),
                   iniFixBuilder = IniFixBuilder(MultiModFixer, args = [{"JeanCN": IniFixBuilder(GIMIFixer), "JeanSea": IniFixBuilder(GIMIObjSplitFixer, args = [{"body": ["body", "dress"]}])}]))
    
    @classmethod
    def jeanCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for JeanCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("JeanCN", re.compile(r"^\s*\[\s*TextureOverride.*(JeanCN)((?!RemapBlend|Sea).)*Blend.*\s*\]"), 
                   Hashes(map = {"JeanCN": {"Jean", "JeanSea"}}), Indices(map = {"JeanCN": {"Jean", "JeanSea"}}),
                   aliases = ["ActingGrandMasterCN", "KleesBabySitterCN"],
                   vgRemaps = VGRemaps(map = {"JeanCN": {"Jean", "JeanSea"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body"}]),
                   iniFixBuilder = IniFixBuilder(MultiModFixer, args = [{"Jean": IniFixBuilder(GIMIFixer), "JeanSea": IniFixBuilder(GIMIObjSplitFixer, args = [{"body": ["body", "dress"]}])}]))
    
    @classmethod
    def jeanSea(cls) -> ModType:
        """
        Creates the :class:`ModType` for JeanSea

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("JeanSea", re.compile(r"^\s*\[\s*TextureOverride.*(JeanSea)((?!RemapBlend|CN).)*Blend.*\s*\]"), 
                   Hashes(map = {"JeanSea": {"Jean", "JeanCN"}}), Indices(map = {"JeanSea": {"Jean", "JeanCN"}}),
                   aliases = ["ActingGrandMasterSea", "KleesBabySitterSea"],
                   vgRemaps = VGRemaps(map = {"JeanSea": {"Jean", "JeanCN"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body", "dress"}]),
                   iniFixBuilder = IniFixBuilder(GIMIObjMergeFixer, args = [{"body": ["body", "dress"]}], kwargs = {"copyPreamble": IniComments.GIMIObjMergerPreamble.value}))
    
    @classmethod
    def keqing(cls) -> ModType:
        """
        Creates the :class:`ModType` for Keqing

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Keqing", re.compile(r"^\s*\[\s*TextureOverride.*(Keqing)((?!(RemapBlend|Opulent)).)*Blend.*\s*\]"), 
                   Hashes(map = {"Keqing": {"KeqingOpulent"}}),Indices(map = {"Keqing": {"KeqingOpulent"}}),
                   aliases = ["Kequeen", "ZhongliSimp", "MoraxSimp"],
                   vgRemaps = VGRemaps(map = {"Keqing": {"KeqingOpulent"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body", "dress"}]),
                   iniFixBuilder = IniFixBuilder(GIMIObjMergeFixer, args = [{"body": ["body", "dress"]}], kwargs = {"copyPreamble": IniComments.GIMIObjMergerPreamble.value}))
    
    @classmethod
    def keqingOpulent(cls) -> ModType:
        """
        Creates the :class:`ModType` for KeqingOpulent

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("KeqingOpulent", re.compile(r"^\s*\[\s*TextureOverride.*(KeqingOpulent)((?!RemapBlend).)*Blend.*\s*\]"), 
            Hashes(map = {"KeqingOpulent": {"Keqing"}}),Indices(map = {"KeqingOpulent": {"Keqing"}}),
            aliases = ["LanternRiteKeqing", "KeqingLaternRite", "CuterKequeen", "LanternRiteKequeen", "KequeenLanternRite", "KequeenOpulent", "CuterKeqing", 
                       "ZhongliSimpOpulent", "MoraxSimpOpulent", "ZhongliSimpLaternRite", "MoraxSimpLaternRite", "LaternRiteZhongliSimp", "LaternRiteMoraxSimp"],
            vgRemaps = VGRemaps(map = {"KeqingOpulent": {"Keqing"}}), 
            iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"body"}]),
            iniFixBuilder = IniFixBuilder(GIMIObjSplitFixer, args = [{"body": ["body", "dress"]}]))
    
    @classmethod
    def kirara(cls) -> ModType:
        """
        Creates the :class:`ModType` for Kirara

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Kirara", re.compile(r"^\s*\[\s*TextureOverride.*(Kirara)((?!RemapBlend|Boots).)*Blend.*\s*\]"), 
                    Hashes(map = {"Kirara": {"KiraraBoots"}}),Indices(map = {"Kirara": {"KiraraBoots"}}),
                    aliases = ["Nekomata", "KonomiyaExpress", "CatBox"],
                    vgRemaps = VGRemaps(map = {"Kirara": {"KiraraBoots"}}),
                    iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"dress"}], 
                                                      kwargs = {"texEdits": {"dress": {"ps-t2": {"WhitenLightMap": TexEditor(pixelFilters = [
                                                          ColourReplace(Colours.White.value, colourToReplace = ColourRanges.LightMapGreen.value, replaceAlpha = False)
                                                      ])}}}}),
                    iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                        RegRemove(remove = {"dress": {"ps-t0"}}),
                        RegRemap(remap = {"dress": {"ps-t1": ["ps-t0", "ps-t1"]}}),
                        RegTexEdit(textures = {"WhitenLightMap": ["ps-t2"]})
                    ]}))
    
    @classmethod
    def kiraraBoots(cls) -> ModType:
        """
        Creates the :class:`ModType` for KiraraBoots

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("KiraraBoots", re.compile(r"^\s*\[\s*TextureOverride.*(KiraraBoots)((?!RemapBlend).)*Blend.*\s*\]"), 
                    Hashes(map = {"KiraraBoots": {"Kirara"}}),Indices(map = {"KiraraBoots": {"Kirara"}}),
                    aliases = ["NekomataInBoots", "KonomiyaExpressInBoots", "CatBoxWithBoots", "PussInBoots"],
                    vgRemaps = VGRemaps(map = {"KiraraBoots": {"Kirara"}}),
                    iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"dress"}]),
                    iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                        RegRemap(remap = {"dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2"]}}),
                        RegTexAdd(textures = {"dress": {"ps-t0": ("NormalMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value))}}, mustAdd = False)
                    ]}))
    
    @classmethod
    def mona(cls) -> ModType:
        """
        Creates the :class:`ModType` for Mona

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Mona", re.compile(r"^\s*\[\s*TextureOverride.*(Mona)((?!(RemapBlend|CN)).)*Blend.*\s*\]"), 
                   Hashes(map = {"Mona": {"MonaCN"}}),Indices(map = {"Mona": {"MonaCN"}}),
                   aliases = ["NoMora", "BigHat"],
                   vgRemaps = VGRemaps(map = {"Mona": {"MonaCN"}}))
    
    @classmethod
    def monaCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for MonaCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("MonaCN", re.compile(r"^\s*\[\s*TextureOverride.*(MonaCN)((?!RemapBlend).)*Blend.*\s*\]"), 
                   Hashes(map = {"MonaCN": {"Mona"}}),Indices(map = {"MonaCN": {"Mona"}}),
                   aliases = ["NoMoraCN", "BigHatCN"],
                   vgRemaps = VGRemaps(map = {"MonaCN": {"Mona"}}))
    
    @classmethod
    def nilou(cls) -> ModType:
        """
        Creates the :class:`ModType` for Nilou

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Nilou", re.compile(r"^\s*\[\s*TextureOverride.*(Nilou)((?!(RemapBlend|Breeze)).)*Blend.*\s*\]"), 
                   Hashes(map = {"Nilou": {"NilouBreeze"}}),Indices(map = {"Nilou": {"NilouBreeze"}}),
                   aliases = ["Dancer", "Morgiana", "BloomGirl"],
                   vgRemaps = VGRemaps(map = {"Nilou": {"NilouBreeze"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"head", "body", "dress"}]),
                   iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                       RegRemove(remove = {"head": {"ps-t0"}, "body": {"ps-t0"}, "dress": {"ps-t0"}}),
                       RegRemap(remap = {"head": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"]},
                                         "body": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"]},
                                         "dress": {"ps-t1": ["ps-t0"], "ps-t2": ["ps-t1"], "ps-t3": ["ps-t2"]}}),
                       RegNewVals(vals = {"head": {"ResourceRefHeadDiffuse": "reference ps-t0",
                                                   "ResourceRefHeadLightMap": "reference ps-t1"},
                                          "body": {"ResourceRefBodyDiffuse": "reference ps-t0",
                                                   "ResourceRefBodyDiffuse": "reference ps-t0"},
                                          "dress": {"ResourceRefDressDiffuse": "reference ps-t0",
                                                    "ResourceRefDressLightMap": "reference ps-t1"}})
                   ]}))

    @classmethod
    def nilouBreeze(cls) -> ModType:
        """
        Creates the :class:`ModType` for NilouBreeze

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """ 
        return ModType("NilouBreeze", re.compile(r"^\s*\[\s*TextureOverride.*(NilouBreeze)((?!(RemapBlend)).)*Blend.*\s*\]"), 
                   Hashes(map = {"NilouBreeze": {"Nilou"}}),Indices(map = {"NilouBreeze": {"Nilou"}}),
                   aliases = ["ForestFairy", "NilouFairy", "DancerBreeze", "MorgianaBreeze", "BloomGirlBreeze",
                              "DancerFairy", "MorgianaFairy", "BloomGirlFairy", "FairyNilou", "FairyDancer", "FairyMorgiana", "FairyBloomGirl"],
                   vgRemaps = VGRemaps(map = {"NilouBreeze": {"Nilou"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"head", "dress", "body"}]),
                   iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                       RegRemap(remap = {"head": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", "temp"]},
                                         "dress": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", "temp"]},
                                         "body": {"ps-t0": ["ps-t0", "ps-t1"], "ps-t1": ["ps-t2", "temp"]}}),
                       RegNewVals(vals = {"head": {"temp": IniKeywords.ORFixPath.value},
                                          "dress": {"temp": IniKeywords.ORFixPath.value},
                                          "body": {"temp": IniKeywords.ORFixPath.value}}),
                       RegTexAdd(textures = {"head": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)},
                                             "body": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)},
                                             "dress": {"ps-t0": ("NormMap", TexCreator(1024, 1024, colour = Colours.NormalMapYellow.value), False)}}, mustAdd = False),
                       RegRemap(remap = {"head": {"temp": ["run"]},
                                         "dress": {"temp": ["run"]},
                                         "body": {"temp": ["run"]}})
                   ]}))

    @classmethod
    def ningguang(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ningguang

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """

        hueFilter = HueAdjust(-2)

        return ModType("Ningguang", re.compile(r"^\s*\[\s*TextureOverride.*(Ningguang)((?!(RemapBlend|Orchid)).)*Blend.*\s*\]"), 
                   Hashes(map = {"Ningguang": {"NingguangOrchid"}}),Indices(map = {"Ningguang": {"NingguangOrchid"}}),
                   aliases = ["GeoMommy", "SugarMommy"],
                   vgRemaps = VGRemaps(map = {"Ningguang": {"NingguangOrchid"}}),
                   iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"head"}], 
                                                      kwargs = {"texEdits": {"head": {"ps-t0": {"DarkDiffuse": TexEditor(pixelFilters = [HighlightShadow(highlight = 0.35, shadow = -0.62),
                                                                                                                                         TempControl(7)],
                                                                                                                         preProcessors = [lambda texFile: TexEditor.adjustTranparency(texFile, 32),
                                                                                                                                          lambda texFile: TexEditor.adjustBrightness(texFile, 0.63),
                                                                                                                                          lambda texFile: TexEditor.adjustSaturation(texFile, 1.25)],
                                                                                                                         postProcessors = [
                                                                                                                                           lambda texFile: hueFilter.transform(texFile)])}}}}), 
                    iniFixBuilder = IniFixBuilder(GIMIObjRegEditFixer, kwargs = {"regEditFilters": [
                        RegTexEdit({"DarkDiffuse": ["ps-t0"]})
                    ]}))
    
    @classmethod
    def ningguangOrchid(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ningguang

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("NingguangOrchid", re.compile(r"^\s*\[\s*TextureOverride.*(NingguangOrchid)((?!RemapBlend).)*Blend.*\s*\]"), 
                    Hashes(map = {"NingguangOrchid": {"Ningguang"}}),Indices(map = {"NingguangOrchid": {"Ningguang"}}),
                    aliases = ["NingguangLanternRite", "LanternRiteNingguang", "GeoMommyOrchid", "SugarMommyOrchid", "GeoMommyLaternRite", "SugarMommyLanternRite",
                               "LaternRiteGeoMommy", "LanternRiteSugarMommy"],
                    vgRemaps = VGRemaps(map = {"NingguangOrchid": {"Ningguang"}}))
    
    @classmethod
    def raiden(cls) -> ModType:
        """
        Creates the :class:`ModType` for Ei

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Raiden", re.compile(r"^\s*\[\s*TextureOverride.*(Raiden|Shogun)((?!RemapBlend).)*Blend.*\s*\]"), 
                     hashes = Hashes(map = {"Raiden": {"RaidenBoss"}}), indices = Indices(),
                     aliases = ["Ei", "RaidenEi", "Shogun", "RaidenShogun", "RaidenShotgun", "Shotgun", "CrydenShogun", "Cryden", "SmolEi"], 
                     vgRemaps = VGRemaps(map = {"Raiden": {"RaidenBoss"}}))
    
    @classmethod
    def rosaria(cls) -> ModType:
        """
        Creates the :class:`ModType` for Rosaria

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Rosaria", re.compile(r"^\s*\[\s*TextureOverride.*(Rosaria)((?!(RemapBlend|CN)).)*Blend.*\s*\]"), 
                      Hashes(map = {"Rosaria": {"RosariaCN"}}), Indices(map = {"Rosaria": {"RosariaCN"}}),
                      aliases = ["GothGirl"],
                      vgRemaps = VGRemaps(map = {"Rosaria": {"RosariaCN"}}))
    
    @classmethod
    def rosariaCN(cls) -> ModType:
        """
        Creates the :class:`ModType` for RosariaCN

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("RosariaCN", re.compile(r"^\s*\[\s*TextureOverride.*(RosariaCN)((?!RemapBlend).)*Blend.*\s*\]"), 
                      Hashes(map = {"RosariaCN": {"Rosaria"}}), Indices(map = {"RosariaCN": {"Rosaria"}}),
                      aliases = ["GothGirlCN"],
                      vgRemaps = VGRemaps(map = {"RosariaCN": {"Rosaria"}}))
    
    @classmethod
    def shenhe(cls) -> ModType:
        """
        Creates the :class:`ModType` for Shenhe

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("Shenhe", re.compile(r"^\s*\[\s*TextureOverride.*(Shenhe)((?!RemapBlend|FrostFlower).)*Blend.*\s*\]"), 
                     Hashes(map = {"Shenhe": {"ShenheFrostFlower"}}), Indices(map = {"Shenhe": {"ShenheFrostFlower"}}),
                     aliases = ["YelansBestie", "RedRopes"],
                     vgRemaps = VGRemaps(map = {"Shenhe": {"ShenheFrostFlower"}}),
                     iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"dress"}]),
                     iniFixBuilder = IniFixBuilder(GIMIObjSplitFixer, args = [{"dress": ["dress", "extra"]}], kwargs = {"regEditFilters": [
                         RegRemove(remove = {"dress": ["ps-t2"]}),
                         RegRemap(remap = {"dress": {"ps-t3": ["ps-t2"]}})
                     ]}))
    
    @classmethod
    def shenheFrostFlower(cls) -> ModType:
        """
        Creates the :class:`ModType` for ShenheFrostFlower

        Returns 
        -------
        :class:`ModType`
            The resultant :class:`ModType`
        """
        return ModType("ShenheFrostFlower", re.compile(r"^\s*\[\s*TextureOverride.*(ShenheFrostFlower)((?!RemapBlend).)*Blend.*\s*\]"), 
                     Hashes(map = {"ShenheFrostFlower": {"Shenhe"}}), Indices(map = {"ShenheFrostFlower": {"Shenhe"}}),
                     aliases = ["ShenheLanternRite", "LanternRiteShenhe", "YelansBestieFrostFlower", "YelansBestieLanternRite", "LanternRiteYelansBestie",
                                "RedRopesFrostFlower", "RedRopesLanternRite", "LanternRiteRedRopes"],
                     vgRemaps = VGRemaps(map = {"ShenheFrostFlower": {"Shenhe"}}),
                     iniParseBuilder = IniParseBuilder(GIMIObjParser, args = [{"dress", "extra"}]),
                     iniFixBuilder = IniFixBuilder(GIMIObjMergeFixer, args = [{"dress": ["dress", "extra"]}], kwargs = {"copyPreamble": IniComments.GIMIObjMergerPreamble.value}))


class ModTypes(Enum):
    """
    The supported types of mods that can be fixed

    Attributes
    ----------
    Amber: :class:`ModType`
        **Amber mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Amber)((?!(RemapBlend|CN)).)*Blend.*\s*\]``

    AmberCN: :class:`ModType`
        **Amber Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(AmberCN)((?!RemapBlend).)*Blend.*\s*\]``

    Arlecchino: :class:`ModType`
        **Arlecchino mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Arlecchino)((?!RemapBlend).)*Blend.*\s*\]``

    Barbara: :class:`ModType`
        **Barabara mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Barbara)((?!RemapBlend|Summertime).)*Blend.*\s*\]``

    BarbaraSummertime: :class:`ModType`
        **Barabara Summertime mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(BarbaraSummertime)((?!RemapBlend).)*Blend.*\s*\]``

    Fischl: :class:`ModType`
        **Fischl mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Fischl)((?!RemapBlend|Highness).)*Blend.*\s*\]``

    FischlHighness: :class:`ModType`
        **Fischl Highness mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(FischlHighness)((?!RemapBlend).)*Blend.*\s*\]``

    Ganyu: :class:`ModType`
        **Ganyu mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Ganyu)((?!(RemapBlend|Twilight)).)*Blend.*\s*\]``

    GanyuTwilight: :class:`ModType`
        **Ganyu Latern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(GanyuTwilight)((?!(RemapBlend)).)*Blend.*\s*\]``

    Jean: :class:`ModType`
        **Jean mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Jean)((?!(RemapBlend|CN|Sea)).)*Blend.*\s*\]``

    JeanCN: :class:`ModType`
        **Jean Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(JeanCN)((?!RemapBlend|Sea).)*Blend.*\s*\]``

    JeanSea: :class:`ModType`
        **Jean Summertime mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(JeanSea)((?!RemapBlend|CN).)*Blend.*\s*\]``

    Keqing: :class:`ModType`
        **Keqing mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Keqing)((?!(RemapBlend|Opulent)).)*Blend.*\s*\]``

    KeqingOpulent: :class:`ModType`
        **Keqing Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(KeqingOpulent)((?!RemapBlend).)*Blend.*\s*\]``

    Kirara: :class:`ModType`
        **Kirara mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Kirara)((?!RemapBlend|Boots).)*Blend.*\s*\]``

    KiraraBoots: :class:`ModType`
        **Kirara in Boots mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(KiraraBoots)((?!RemapBlend).)*Blend.*\s*\]``

    Mona: :class:`ModType`
        **Mona mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Mona)((?!(RemapBlend|CN)).)*Blend.*\s*\]``

    MonaCN: :class:`ModType`
        **Mona Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(MonaCN)((?!RemapBlend).)*Blend.*\s*\]``

    Nilou: :class:`ModType`
        **Nilou mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Nilou)((?!(RemapBlend|Breeze)).)*Blend.*\s*\]``

    NilouBreeze: :class:`ModType`
        **Nilou Forest Fairy mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(NilouBreeze)((?!(RemapBlend)).)*Blend.*\s*\]``

    Ningguang: :class:`ModType`
        **Ningguang Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Ningguang)((?!(RemapBlend|Orchid)).)*Blend.*\s*\]``

    NingguangOrchid: :class:`ModType`
        **Ningguang Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(NingguangOrchid)((?!RemapBlend).)*Blend.*\s*\]``

    Raiden: :class:`ModType`
        **Raiden mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Raiden|Shogun)((?!RemapBlend).)*Blend.*\s*\]``

    Rosaria: :class:`ModType`
        **Rosaria mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Rosaria)((?!(RemapBlend|CN)).)*Blend.*\s*\]``

    RosariaCN: :class:`ModType`
        **Rosaria Chinese mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(RosariaCN)((?!RemapBlend).)*Blend.*\s*\]``

    Shenhe: :class:`ModType`
        **Shenhe mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(Shenhe)((?!RemapBlend|FrostFlower).)*Blend.*\s*\]``

    ShenheFrostFlower: :class:`ModType`
        **Shenhe Lantern Rite mods** :raw-html:`<br />`

        Checks if the .ini file contains a section with the regex ``^\s*\[\s*TextureOverride.*(ShenheFrostFlower)((?!RemapBlend).)*Blend.*\s*\]``
    """

    Amber = GIBuilder.amber()
    AmberCN = GIBuilder.amberCN()
    Arlecchino = GIBuilder.arlecchino()
    Barbara = GIBuilder.barbara()
    BarbaraSummertime = GIBuilder.barbaraSummerTime()
    Fischl = GIBuilder.fischl()
    FischlHighness = GIBuilder.fischlHighness()
    Ganyu = GIBuilder.ganyu()
    GanyuTwilight = GIBuilder.ganyuTwilight()
    Jean = GIBuilder.jean()
    JeanCN = GIBuilder.jeanCN()
    JeanSea = GIBuilder.jeanSea()
    Keqing = GIBuilder.keqing()
    KeqingOpulent = GIBuilder.keqingOpulent()
    Kirara = GIBuilder.kirara()
    KiraraBoots = GIBuilder.kiraraBoots()
    Mona = GIBuilder.mona()
    MonaCN = GIBuilder.monaCN()
    Nilou = GIBuilder.nilou()
    NilouBreeze = GIBuilder.nilouBreeze()
    Ningguang = GIBuilder.ningguang()
    NingguangOrchid = GIBuilder.ningguangOrchid()
    Raiden = GIBuilder.raiden()
    Rosaria = GIBuilder.rosaria()
    RosariaCN = GIBuilder.rosariaCN()
    Shenhe = GIBuilder.shenhe()
    ShenheFrostFlower = GIBuilder.shenheFrostFlower()
    
    @classmethod
    def getAll(cls) -> Set[ModType]:
        """
        Retrieves a set of all the mod types available

        Returns
        -------
        Set[:class:`ModType`]
            All the available mod types
        """

        result = set()
        for modTypeEnum in cls:
            result.add(modTypeEnum.value)
        return result
    
    @classmethod
    def search(cls, name: str):
        """
        Searches a mod type based off the provided name

        Parameters
        ----------
        name: :class:`str`
            The name of the mod to search for

        Returns
        -------
        Optional[:class:`ModType`]
            The found mod type based off the provided name
        """

        result = None
        for modTypeEnum in cls:
            modType = modTypeEnum.value
            if (modType.isName(name)):
                result = modType
                break
        
        return result
    
    @classmethod
    def getHelpStr(cls, showFullMods: bool = False) -> str:
        result = ""
        helpHeading = Heading("supported types of mods", 15)
        result += f"{helpHeading.open()}\n\nThe names/aliases for the mod types are not case sensitive\n\n"

        if (not showFullMods):
            result += "Below contains a condensed list of all the supported mods, for more details, please visit:\nhttps://github.com/nhok0169/Anime-Game-Remap/tree/nhok0169/Anime%20Game%20Remap%20(for%20all%20users)/api#mod-types\n\n"

        modTypeHelpTxt = []
        for modTypeEnum in cls:
            modType = modTypeEnum.value
            
            if (showFullMods):
                currentHelpStr = modType.getHelpStr()
            else:
                currentHelpStr = f"- {modType.name}"

            modTypeHelpTxt.append(currentHelpStr)

        modTypeHelpTxt = "\n".join(modTypeHelpTxt)
        
        result += f"{modTypeHelpTxt}\n\n{helpHeading.close()}"
        return result


class InvalidModType(Error):
    """
    This Class inherits from :class:`Error`

    Exception when the type of mod specified to fix is not found

    Parameters
    ----------
    type: :class:`str`
        The name for the type of mod specified
    """
    def __init__(self, type: str):
        super().__init__(f"Unable to find the type of mod by the search string, '{type}'")


class ConflictingOptions(Error):
    """
    This Class inherits from :class:`Error`

    Exception when the script or :class:`RemapService` is ran with options that cannot be used together

    Parameters
    ----------
    options: List[:class:`str`]
        The options that cannot be used together
    """
    def __init__(self, options: List[str]):
        optionsStr = ", ".join(options)
        super().__init__(f"The following options cannot be used toghether: {optionsStr}")


class Logger():
    """
    Class for pretty printing output to display on the console

    Parameters
    ----------
    prefix: :class:`str`
        line that is printed before any message is printed out :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ""

    logTxt: :class:`bool`
        Whether to log all the printed messages into a .txt file once the fix is done :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    verbose: :class:`bool`
        Whether to print out output :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    Attributes
    ----------
    includePrefix: :class:`bool`
        Whether to include the prefix string when printing out a message

    verbose: :class:`bool`
        Whether to print out output

    logTxt: :class:`bool`
        Whether to log all the printed messages into a .txt file once the fix is done

    _prefix: :class:`str`
        line that is printed before any message is printed out

    _headings: Deque[:class:`Heading`]
        A stack of headings that have been opened (by calling :meth:`Heading.open`), but have not been closed yet (have not called :meth:`Heading.close` yet)

    _loggedTxt: :class:`str`
        The text that will be logged into a .txt file
    """

    DefaultHeadingSideLen = 2
    DefaultHeadingChar = "="

    def __init__(self, prefix: str = "", logTxt: bool = False, verbose: bool = True):
        self._prefix = prefix
        self.includePrefix = True
        self.verbose = verbose
        self.logTxt = logTxt
        self._loggedTxt = ""
        self._headings = deque()
        self._currentPrefixTxt = ""

        self._setDefaultHeadingAtts()

    @property
    def prefix(self):
        """
        The line of text that is printed before any message is printed out

        :getter: Returns such a prefix
        :setter: Sets up such a prefix for the logger
        :type: :class:`str`
        """
        return self._prefix
    
    @prefix.setter
    def prefix(self, newPrefix):
        self._prefix = newPrefix
        self._currentPrefixTxt = ""

    @property
    def loggedTxt(self):
        """
        The text to be logged into a .txt file

        :getter: Returns such a prefix
        :type: :class:`str`
        """
        return self._loggedTxt

    def clear(self):
        """
        Clears out any saved text from the logger
        """

        self._loggedTxt = ""

    def _setDefaultHeadingAtts(self):
        """
        Sets the default attributes for printing out a header line
        """

        self._headingTxtLen = 0
        self._headingSideLen = self.DefaultHeadingSideLen
        self._headingChar = self.DefaultHeadingChar

    def _addLogTxt(self, txt: str):
        """
        Appends the text to the logged output to be printed to a .txt file

        Parameters
        ----------
        txt: :class:`str`
            The text to be added onto the logged output
        """

        if (self.logTxt):
            self._loggedTxt += f"{txt}\n"

    def getStr(self, message: str):
        """
        Retrieves the string to be printed out by the logger

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out

        Returns
        -------
        :class:`str`
            The transformed text that the logger prints out
        """

        return f"# {self._prefix} --> {message}"

    def log(self, message: str):
        """
        Regularly prints text onto the console

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out
        """

        if (self.includePrefix):
            message = self.getStr(message)

        self._addLogTxt(message)
        self._currentPrefixTxt += f"{message}\n"

        if (self.verbose):
            print(message)

    def split(self):
        """
        Prints out a new line
        """

        if (self._currentPrefixTxt):
            self.log("\n")

    def space(self):
        """
        Prints out a space
        """
        self.log("")

    def openHeading(self, txt: str, sideLen: int = DefaultHeadingSideLen, headingChar = DefaultHeadingChar):
        """
        Prints out an opening heading

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out

        sideLen: :class:`int`
            How many characters we want for the side border of the heading :raw-html:`<br />`
            (see line 1 of the example at :class:`Heading`) :raw-html:`<br />` :raw-html:`<br />`

            **Default**: 2

        headingChar: :class:`str`
            The type of character used to print the side border of the heading :raw-html:`<br />`
            (see line 3 of the example at :class:`Heading`) :raw-html:`<br />` :raw-html:`<br />`

            **Default**: "="
        """

        heading = Heading(title = txt, sideLen = sideLen, sideChar = headingChar)
        self._headings.append(heading)
        self.log(heading.open())

    def closeHeading(self):
        """
        Prints out a closing heading that corresponds to a previous opening heading printed (see line 3 of the example at :class:`Heading`)
        """

        if (not self._headings):
            return

        heading = self._headings.pop()
        self.log(heading.close())

    @classmethod
    def getBulletStr(self, txt: str) -> str:
        """
        Creates the string for an item in an unordered list

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out

        Returns
        -------
        :class:`str`
            The text formatted as an item in an unordered list
        """
        return f"- {txt}"
    
    @classmethod
    def getNumberedStr(self, txt: str, num: int) -> str:
        """
        Creates the string for an ordered list

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out

        num: :class:`str`
            The number we want to print out before the text for the ordered list

        Returns
        -------
        :class:`str`
            The text formatted as an item in an ordered list
        """
        return f"{num}. {txt}"

    def bulletPoint(self, txt: str):
        """
        Prints out an item in an unordered list

        Parameters
        ----------
        txt: :class:`str`
            The message we want to print out
        """
        self.log(self.getBulletStr(txt))

    def list(self, lst: List[str], transform: Optional[Callable[[str], str]] = None):
        """
        Prints out an ordered list

        Parameters
        ----------
        lst: List[:class:`str`]
            The list of messages we want to print out

        transform: Optional[Callable[[:class:`str`], :class:`str`]]
            A function used to do any processing on each message in the list of messages

            If this parameter is ``None``, then the list of message will not go through any type of processing :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (transform is None):
            transform = lambda txt: txt

        lstLen = len(lst)
        for i in range(lstLen):
            newTxt = transform(lst[i])
            self.log(self.getNumberedStr(newTxt, i + 1))

    def box(self, message: str, header: str):
        """
        Prints the message to be sandwiched by the text defined in the argument, ``header``

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out

        header: :class:`str`
            The string that we want to sandwich our message against
        """

        self.log(header)

        messageList = message.split("\n")
        for messagePart in messageList:
            self.log(messagePart)

        self.log(header)

    def error(self, message: str):
        """
        Prints an error message

        Parameters
        ----------
        message: :class:`str`
            The message we want to print out
        """

        prevVerbose = self.verbose
        if (not self.logTxt):
            self.verbose = True

        self.space()

        self.box(message, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        self.space()
        self.verbose = prevVerbose

    def handleException(self, exception: Exception):
        """
        Prints the message for an error

        Parameters
        ----------
        exception: :class:`Exception`
            The error we want to handle
        """

        message = f"\n{type(exception).__name__}: {exception}\n\n{traceback.format_exc()}"
        self.error(message)

    def input(self, desc: str) -> str:
        """
        Handles user input from the console

        Parameters
        ----------
        desc: :class:`str`
            The question/description being asked to the user for input

        Returns
        -------
        :class:`str`
            The resultant input the user entered
        """

        if (self.includePrefix):
            desc = self.getStr(desc)

        self._addLogTxt(desc)
        result = input(desc)
        self._addLogTxt(f"Input: {result}")

        return result

    def waitExit(self):
        """
        Prints the message used when the script finishes running
        """

        prevIncludePrefix = self.includePrefix
        self.includePrefix = False
        self.input("\n== Press ENTER to exit ==")
        self.includePrefix = prevIncludePrefix 


class RemapMissingBlendFile(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when a RemapBlend.buf file is missing its corresponding Blend.buf file

    Parameters
    ----------
    remapBlend: :class:`str`
        The path to the RemapBlend.buf file
    """

    def __init__(self, remapBlend: str):
        super().__init__(f"Missing the corresponding Blend.buf file for the RemapBlend.buf", path = remapBlend)


class BlendFileNotRecognized(FileException):
    """
    This Class inherits from :class:`FileException`

    Exception when a Blend.buf file cannot be read

    Parameters
    ----------
    blendFile: :class:`str`
        The file path to the Blend.buf file
    """
    def __init__(self, blendFile: str):
        super().__init__(f"Blend file format not recognized for {os.path.basename(blendFile)}", path = os.path.dirname(blendFile))


class BadBlendData(Error):
    """
    This Class inherits fsrom :class:`Error`

    Exception when certain bytes do not correspond to the format defined for a Blend.buf file
    """

    def __init__(self):
        super().__init__(f"Bytes do not corresponding to the defined format for a Blend.buf file")


class BlendFile(File):
    """
    This Class inherits from :class:`File`

    Used for handling blend.buf files

    .. note::
        We observe that a Blend.buf file is a binary file defined as:

        * each line contains 32 bytes (256 bits)
        * each line uses little-endian mode (MSB is to the right while LSB is to the left)
        * the first 16 bytes of a line are for the blend weights, each weight is 4 bytes or 32 bits (4 weights/line)
        * the last 16 bytes of a line are for the corresponding indices for the blend weights, each index is 4 bytes or 32 bits (4 indices/line)
        * the blend weights are floating points while the blend indices are unsigned integers

    Parameters
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the blend file

    Attributes
    ----------
    src: Union[:class:`str`, :class:`bytes`]
        The source file or bytes for the blend file

    _data: :class:`bytes`
        The bytes read from the source
    """

    BytesPerLine = 32

    def __init__(self, src: Union[str, bytes]):
        self.src = src
        self._data = self.read()

    def read(self) -> bytes:
        """
        Reads the bytes in the blend.buf file

        Returns
        -------
        :class:`bytes`
            The read bytes
        """

        return self.readFile(self.src)

    @classmethod
    def readFile(cls, blendSrc: Union[str, bytes]):
        result = FileService.readBinary(blendSrc)
        isValid = cls._isValid(result)

        if (not isValid and isinstance(blendSrc, str)):
            raise BlendFileNotRecognized(blendSrc)
        elif (not isValid):
            raise BadBlendData()
        
        return result

    @classmethod
    def _getLineWeight(cls, data: bytes, lineInd: int) -> Tuple[float, float, float, float]:
        return [struct.unpack("<f", data[lineInd + 4 * j : lineInd + 4 * (j+1)])[0] for j in range(4)]
    
    @classmethod
    def _getLineIndices(cls, data: bytes, lineInd: int) -> Tuple[int, int, int, int]:
        return [struct.unpack("<I", data[lineInd + 16 + 4 * j : lineInd + 16 + 4 * (j+1)])[0] for j in range(4)]

    @classmethod
    def _isValid(cls, data: bytes):
        if (len(data) % cls.BytesPerLine != 0):
            return False
        return True

    def correct(self, vgRemap: VGRemap, fixedBlendFile: Optional[str] = None) -> Union[Optional[str], bytearray]:
        """
        Fixes a Blend.buf file

        Parameters
        ----------
        vgRemap: :class:`VGRemap`
            The vertex group remap for correcting the Blend.buf file

        fixedBlendFile: Optional[:class:`str`]
            The file path for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`BlendFileNotRecognized`
            If the original Blend.buf file provided by the parameter ``blendFile`` cannot be read

        :class:`BadBlendData`
            If the bytes passed into this function do not correspond to the format defined for a Blend.buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedBlendFile`` is ``None``, then will return an array of bytes for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed RemapBlend.buf file if the provided Blend.buf file got corrected
        """

        # if no correction is needed to be done
        blendFile = self.src
        blendIsFile = isinstance(blendFile, str)
        if (not vgRemap.remap and blendIsFile):
            return None
        elif (not vgRemap.remap):
            return bytearray(blendFile)

        result = bytearray()
        dataLen = len(self._data)
        for i in range(0,dataLen,32):
            blendweights = self._getLineWeight(self._data, i)
            blendindices = self._getLineIndices(self._data, i)
            outputweights = bytearray()
            outputindices = bytearray()

            # replaces the blend index in the original mod with the corresponding blend index
            #   for the boss
            for weight, index in zip(blendweights, blendindices):
                if weight != 0 and index <= vgRemap.maxIndex:
                    try:
                        index = int(vgRemap.remap[index])
                    except KeyError:
                        pass

                outputweights += struct.pack("<f", weight)
                outputindices += struct.pack("<I", index)
            result += outputweights
            result += outputindices

        if (fixedBlendFile is not None):
            FileService.writeBinary(fixedBlendFile, result)
            return fixedBlendFile

        return result

    @classmethod
    def _addRemap(cls, hasRemap: bool, remap: Dict[bytes, Union[bytes, List[bytes]]], key: bytes, value: bytes) -> bool:
        currentIsRemap = True
        try:
            remap[key]
        except KeyError:
            remap[key] = value
        else:
            remapValue = remap[key]

            if (remapValue != value):
                currentIsRemap = False

                if (not isinstance(remapValue, list)):
                    remap[key] = [remapValue]

                remap[key].append(value)

        return (hasRemap and currentIsRemap)


# KeepFirstDict: Dictionary used to only keep the value of the first instance of a key
class KeepFirstDict(OrderedDict):
    def __setitem__(self, key, value):
        # All values updated into the dictionary of ConfigParser will first updated as a list of values, then
        #    the list of values will be turned into a string
        #
        # eg. the 'value' argument for the __setitem__ method in the case a key has 2 duplicates
        # >> value = ["val1"]           <----------- we only want this list
        # >> value = ["val1", "", "val2"]
        # >> value = ["val1", "", "val2", "", "val3"]
        # >> value = "val1\nval2\nval3"
        #
        # Note:
        #   For the case of duplicate keys, GIMI will only keep the value of the first valid instance of the key.
        #       Since checking for correct syntax and semantics is out of the scope of this program, we only get 
        #        the value of the first instance of the key
        if (key in self and isinstance(self[key], list) and isinstance(value, list)):
            return

        super().__setitem__(key, value)


# KeepAllDict: Dictionary used to keep all instances of a key
class KeepAllDict(OrderedDict):
    def __init__(self):
        super().__init__()
        self._orderInd = 0

    def __setitem__(self, key, value):
        keyExists = key in self
        valueIsList = isinstance(value, list)

        if (keyExists and valueIsList):
            self[key].append(f"{self._orderInd}_{value[0]}")
            self._orderInd += 1
            return
        elif (valueIsList):
            super().__setitem__(key, [f"{self._orderInd}_{value[0]}"])
            self._orderInd += 1
            return

        elif (isinstance(value, str) and keyExists and isinstance(self[key], list)):
            return

        super().__setitem__(key, value)


# IniFile: Class to handle .ini files
class IniFile(File):
    """
    This class inherits from :class:`File`

    Class for handling .ini files

    :raw-html:`<br />`

    .. note::
        We analyse the .ini file using Regex which is **NOT** the right way to do things
        since the modified .ini language that GIMI interprets is a **CFG** (context free grammer) and **NOT** a regular language.
   
        But since we are lazy and don't want make our own compiler with tokenizers, parsing algorithms (eg. SLR(1)), type checking, etc...
        this module should handle regular cases of .ini files generated using existing scripts (assuming the user does not do anything funny...)

    :raw-html:`<br />`

    Parameters
    ----------
    file: Optional[:class:`str`]
        The file path to the .ini file :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    logger: Optional[:class:`Logger`]
        The logger to print messages if necessary

    txt: :class:`str`
        Used as the text content of the .ini file if :attr:`IniFile.file` is set to ``None`` :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ""

    modTypes: Optional[Set[:class:`ModType`]]
        The types of mods that the .ini file should belong to :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    modsToFix: Optional[Set[:class:`str`]]
        The names of the mods we want to fix to :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    defaultModType: Optional[:class:`ModType`]
        The type of mod to use if the .ini file has an unidentified mod type :raw-html:`<br />` :raw-html:`<br />`
        If this value is ``None``, then will skip the .ini file with an unidentified mod type :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    version: Optional[:class:`float`]
        The game version we want the .ini file to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    version: Optional[:class:`float`]
        The game version we want the .ini file to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version.

    _parser: `ConfigParser`_
        Parser used to parse very basic cases in a .ini file

    modTypes: Set[:class:`ModType`]
        The types of mods that the .ini file should belong to

    modsToFix: Set[:class:`str`]
        The names of the mods that we want to fix to

    defaultModType: Optional[:class:`ModType`]
        The type of mod to use if the .ini file has an unidentified mod type

    _textureOverrideBlendRoot: Optional[:class:`str`]
        The name for the `section`_ containing the keywords: ``[.*TextureOverride.*Blend.*]``

    sectionIfTemplates: Dict[:class:`str`, :class:`IfTemplate`]
        All the `sections`_ in the .ini file that can be parsed into an :class:`IfTemplate`

        For more info see :class:`IfTemplate`

        .. attention::
            The modified .ini language that GIMI uses introduces keywords that can be used before the key of a key-value pair :raw-html:`<br />`

            *eg. defining constants*

            .. code-block:: ini
                :linenos:

                [Constants]
                global persist $swapvar = 0
                global persist $swapscarf = 0
                global $active
                global $creditinfo = 0

            :raw-html:`<br />`

            `Sections`_ containing this type of pattern will not be parsed. But generally, these sections are irrelevant to fixing the Raiden Boss

    _resourceBlends: Dict[:class:`str`, :class:`IfTemplate`]
        `Sections`_ that are linked to 1 or more Blend.buf files.

        The keys are the name of the sections.

    remapBlendModels: Dict[:class:`str`, :class:`IniResourceModel`]
        The data for the ``[Resource.*RemapBlend.*]`` `sections`_ used in the fix

        The keys are the original names of the resource with the pattern ``[Resource.*Blend.*]``

    texEditModels: Dict[:class:`str`, Dict[:class:`str`, :class:`IniTexModel`]]
        The data for the ``[Resource.*]`` `sections`_ that belong to some texture file that got editted :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names for the type of texture files *eg. MyBrandNewLightMap*
        * The inner keys are the original names of the resource with the pattern ``[Resource.*]``

    texAddModels: Dict[:class:`str`, Dict[:class:`str`, :class:`IniTexModel`]]
        The data for the ``[Resource.*]`` `sections`_ that belong to some texture file that got added :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names for the type of texture files *eg. MyBrandNewLightMap*
        * The inner keys are the names of the mod object *eg. Head*
    """

    # -- regex strings ---

    _textureOverrideBlendPatternStr = r"^\s*\[\s*TextureOverride.*" + IniKeywords.Blend.value + r".*\s*\]"
    _fixedTextureOverrideBlendPatternStr = r"^\s*\[\s*TextureOverride.*" + IniKeywords.RemapBlend.value + r".*\s*\]"
    
    # --------------------
    # -- regex objects ---
    _sectionPattern = re.compile(r"^\s*\[.*\]")
    _textureOverrideBlendPattern = re.compile(_textureOverrideBlendPatternStr)
    _fixedTextureOverrideBlendPattern = re.compile(_fixedTextureOverrideBlendPatternStr)

    # -------------------

    _ifStructurePattern = re.compile(r"\s*(" + IfPredPartType.EndIf.value + "|" + IfPredPartType.Else.value +  "|" + IfPredPartType.If.value + "|" + IfPredPartType.Elif.value + ")")

    def __init__(self, file: Optional[str] = None, logger: Optional["Logger"] = None, txt: str = "", modTypes: Optional[Set[ModType]] = None, defaultModType: Optional[ModType] = None, 
                 version: Optional[float] = None, modsToFix: Optional[Set[str]] = None):
        super().__init__(logger = logger)

        self._filePath: Optional[FilePath] = None
        self.file = file
        self.version = version

        self._parserDictType = KeepAllDict
        self._parser = configparser.ConfigParser(dict_type = self._parserDictType, strict = False)
        self._parser.optionxform=str

        self._fileLines = []
        self._fileTxt = ""
        self._fileLinesRead = False
        self._ifTemplatesRead = False
        self._setupFileLines(fileTxt = txt)

        if (modTypes is None):
            modTypes = set()
        if (modsToFix is None):
            modsToFix = set()

        self.defaultModType = defaultModType
        self.modTypes = modTypes
        self.modsToFix = modsToFix
        self._heading = IniBoilerPlate.DefaultHeading.value.copy()

        self._isFixed = False
        self._setType(None)
        self._isModIni = False

        self._textureOverrideBlendRoot: Optional[str] = None
        self._textureOverrideBlendSectionName: Optional[str] = None
        self.sectionIfTemplates: Dict[str, IfTemplate] = {}
        self._resourceBlends: Dict[str, IfTemplate] = {}

        self.remapBlendModels: Dict[str, IniResourceModel] = {}
        self.texEditModels: Dict[str, Dict[str, IniTexModel]] = {}
        self.texAddModels: Dict[str, Dict[str, IniTexModel]] = {}

        self._iniParser: Optional[BaseIniParser] = None
        self._iniFixer: Optional[BaseIniFixer] = None
        self._iniRemover: Optional[BaseIniRemover] = None

    @property
    def filePath(self) -> Optional[FilePath]:
        """
        The path to the .ini file

        :getter: Returns the path to the file
        :type: Optional[:class:`FilePath`]
        """
        return self._filePath

    @property
    def file(self) -> Optional[str]:
        """
        The file path to the .ini file

        :getter: Returns the path to the file
        :setter: Sets the new path for the file
        :type: Optional[:class:`str`]
        """

        if (self._filePath is None):
            return None
        return self._filePath.path
    
    @file.setter
    def file(self, newFile: Optional[str]) -> str:
        if (newFile is not None and self._filePath is None):
            self._filePath = FilePath(newFile)
        elif (newFile is not None):
            self._filePath.path = newFile
        elif (self._filePath is not None):
            self._filePath = None

    @property
    def folder(self) -> str:
        """
        The folder where this .ini file resides :raw-html:`<br />` :raw-html:`<br />`

        If :attr:`IniFile.file` is set to ``None``, then will return the folder where this script is ran

        :getter: Retrieves the folder
        :type: :class:`str`
        """

        if (self._filePath is not None):
            return self._filePath.folder
        return FilePathConsts.CurrentDir

    @property
    def isFixed(self) -> bool:
        """
        Whether the .ini file has already been fixed

        :getter: Returns whether the .ini file has already been fixed
        :type: :class:`bool`
        """

        return self._isFixed
    
    @property
    def type(self) -> Optional[ModType]:
        """
        The type of mod the .ini file belongs to

        :getter: Returns the type of mod the .ini file belongs to
        :type: Optional[:class:`ModType`]
        """

        return self._type
    
    def _setType(self, newType: Optional[ModType]):
        self._type = newType
        self._heading.title = None
    
    @property
    def isModIni(self) -> bool:
        """
        Whether the .ini file belongs to a mod

        :getter: Returns whether the .ini file belongs to a mod
        :type: :class:`bool`
        """

        return self._isModIni
    
    @property
    def fileLinesRead(self) -> bool:
        """
        Whether the .ini file has been read

        :getter: Determines whether the .ini file has been read
        :type: :class:`bool`
        """

        return self._fileLinesRead
    
    @property
    def fileTxt(self) -> str:
        """
        The text content of the .ini file

        :getter: Returns the content of the .ini file
        :setter: Reads the new value for both the text content of the .ini file and the text lines of the .ini file 
        :type: :class:`str`
        """

        return self._fileTxt
    
    @fileTxt.setter
    def fileTxt(self, newFileTxt: str):
        self._fileTxt = newFileTxt
        self._fileLines = TextTools.getTextLines(self._fileTxt)

        self._fileLinesRead = True
        self._isFixed = False
        self._textureOverrideBlendRoot = None
        self._textureOverrideBlendSectionName = None

    @property
    def fileLines(self) -> List[str]:
        """
        The text lines of the .ini file :raw-html:`<br />` :raw-html:`<br />`

        .. note::
            For the setter, each line must end with a newline character (same behaviour as `readLines`_)

        :getter: Returns the text lines of the .ini file
        :setter: Reads the new value for both the text lines of the .ini file and the text content of the .ini file
        :type: List[:class:`str`]
        """

        return self._fileLines
    
    @fileLines.setter
    def fileLines(self, newFileLines: List[str]):
        self._fileLines = newFileLines
        self._fileTxt = "".join(self._fileLines)

        self._fileLinesRead = True
        self._isFixed = False
        self._textureOverrideBlendRoot = None
        self._textureOverrideBlendSectionName = None

    def clearRead(self, eraseSourceTxt: bool = False):
        """
        Clears the saved text read in from the .ini file

        .. note::
            If :attr:`IniFile.file` is set to ``None``, then the default run of this function
            with the argument ``eraseSourceTxt`` set to ``False`` will have no effect since the provided text from :attr:`IniFile._fileTxt` is the only source of data for the :class:`IniFile`

            If you also want to clear the above source text data, then run this function with the ``eraseSourceTxt`` argument set to ``True``

        Parameters
        ----------
        eraseSourceTxt: :class:`bool`
            Whether to erase the only data source for this class if :attr:`IniFile.file` is set to ``None``, see the note above for more info :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        if (self._filePath is not None or eraseSourceTxt):
            self._fileLines = []
            self._fileTxt = ""
            self._fileLinesRead = False

            self._isFixed = False
            self._textureOverrideBlendRoot = None
            self._textureOverrideBlendSectionName = None

    def clear(self, eraseSourceTxt: bool = False):
        """
        Clears all the saved data for the .ini file

        .. note::
            Please see the note at :meth:`IniFile.clearRead`

        Parameters
        ----------
        eraseSourceTxt: :class:`bool`
            Whether to erase the only data source for this class if :attr:`IniFile.file` is set to ``None``, see the note at :meth:`IniFile.clearRead` for more info :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        self.clearRead(eraseSourceTxt = eraseSourceTxt)
        self._heading = IniBoilerPlate.DefaultHeading.value.copy()
        self._setType(None)
        self._isModIni = False

        self._ifTemplatesRead = False
        self.sectionIfTemplates = {}
        self._resourceBlends = {}

        self._iniParser = None
        self._iniFixer = None

        self.remapBlendModels.clear()
        self.texEditModels.clear()
        self.texAddModels.clear()


    @property
    def availableType(self) -> Optional[ModType]:
        """
        Retrieves the type of mod identified for this .ini file

        .. note::
            This function is the same as :meth:`IniFile.type`, but will return :attr:`IniFile.defaultModType` if :meth:`IniFile.type` is ``None``

        Returns
        -------
        Optional[:class:`ModType`]
            The type of mod identified
        """

        if (self._type is not None):
            return self._type
        elif (self.defaultModType is not None):
            return self.defaultModType
        
        return None

    def read(self) -> str:
        """
        Reads the .ini file :raw-html:`<br />` :raw-html:`<br />`

        If :attr:`IniFile.file` is set to ``None``, then will read the existing value from :attr:`IniFile.fileTxt`

        Returns
        -------
        :class:`str`
            The text content of the .ini file
        """

        if (self._filePath is not None):
            self.fileTxt = FileService.read(self._filePath.path, "r", lambda filePtr: filePtr.read())
        return self._fileTxt
    
    def write(self, txt: Optional[str] = None) -> str:
        """
        Writes back into the .ini files based off the content in :attr:`IniFile._fileLines`

        Parameters
        ----------
        txt: Optional[:class:`str`]
            The text to write back into the .ini file :raw-html:`<br />` :raw-html:`<br />`

            If this argument is ``None``, then will use the :attr:`IniFile.fileTxt`

            **Default**: ``none``

        Returns
        -------
        :class:`str`
            The text that is written to the .ini file
        """

        if (self._filePath is None and txt is not None):
            self.fileTxt = txt

        if (self._filePath is None):
            return self._fileTxt
        
        if (txt is None):
            txt = self._fileTxt

        with open(self._filePath.path, "w", encoding = FileEncodings.UTF8.value) as f:
            f.write(txt)

        return txt

    def _setupFileLines(self, fileTxt: str = ""):
        if (self._filePath is None):
            self.fileTxt = fileTxt
            self._fileLinesRead = True

    def readFileLines(self) -> List[str]:
        """
        Reads each line in the .ini file :raw-html:`<br />` :raw-html:`<br />`

        If :attr:`IniFile.file` is set to ``None``, then will read the existing value from :attr:`IniFile.fileLines`

        Returns
        -------
        List[:class:`str`]
            All the lines read from the .ini file
        """

        if (self._filePath is not None):
            self.fileLines = FileService.read(self._filePath.path, "r", lambda filePtr: filePtr.readlines())
        return self._fileLines

    def _readLines(func):
        """
        Decorator to read all the lines in the .ini file first before running a certain function

        All the file lines will be saved in :attr:`IniFile._fileLines`

        Examples
        --------
        .. code-block:: python
            :linenos:

            @_readLines
            def printLines(self):
                for line in self._fileLines:
                    print(f"LINE: {line}")
        """

        def readLinesWrapper(self, *args, **kwargs):
            if (not self._fileLinesRead):
                self.readFileLines()
            return func(self, *args, **kwargs)
        return readLinesWrapper
    
    def getTexEditModels(self) -> List[IniTexModel]:
        """
        Retrieves all the file path data needed for editing a texture .dds file
        (transforms :attr:`IniFile.texEditModels` to a list)

        Returns
        -------
        List[:class:`IniTexModel`]
            The data models needed for editting a texture .dds file
        """

        result = []

        for texName in self.texEditModels:
            texTypeModels = self.texEditModels[texName]
            for section in texTypeModels:
                result.append(texTypeModels[section])

        return result
    
    def getTexAddModels(self) -> List[IniTexModel]:
        """
        Retrieves all the file path data needed for creating new texture .dds file
        (transforms :attr:`IniFile.texAddModels` to a list)

        Returns
        -------
        List[:class:`IniTexModel`]
            The data models needed for editting a texture .dds file
        """

        result = []

        for texName in self.texAddModels:
            texTypeModels = self.texAddModels[texName]
            for modObj in texTypeModels:
                result.append(texTypeModels[modObj])

        return result
    
    def checkIsMod(self) -> bool:
        """
        Reads the entire .ini file and checks whether the .ini file belongs to a mod

        .. note::
            If the .ini file has already been parsed (eg. calling :meth:`IniFile.checkModType` or :meth:`IniFile.parse`), then

            you only need to read :meth:`IniFile.isModIni`

        Returns
        -------
        :class:`bool`
            Whether the .ini file is a .ini file that belongs to some mod
        """
        
        self.clearRead()
        section = lambda line: False
        self.getSectionOptions(section, postProcessor = lambda startInd, endInd, fileLines, sectionName, srcTxt: "")
        return self._isModIni
    
    def _checkModType(self, line: str):
        """
        Checks if a line of text contains the keywords to identify whether the .ini file belongs to the types of mods in :attr:`IniFile.modTypes` :raw-html:`<br />` :raw-html:`<br />`

        * If :attr:`IniFile.modTypes` is not empty, then will find the first :class:`ModType` that where the line makes :meth:`ModType.isType` return ``True``
        * Otherwise, will see if the line matches with the regex, ``[.*TextureOverride.*Blend.*]`` 

        Parameters
        ----------
        line: :class:`str`
            The text to check
        """

        if (self._textureOverrideBlendRoot is not None):
            return

        hasDefaultWithoutBlendSectinFound = bool(self.defaultModType is not None and self._textureOverrideBlendSectionName is None)
        blendPatternMatch = None

        if (hasDefaultWithoutBlendSectinFound):
            blendPatternMatch = self._textureOverrideBlendPattern.search(line)

            if (blendPatternMatch):
                self._isModIni = True
                self._textureOverrideBlendSectionName = self._getSectionName(line)
        
        if (not self.modTypes and ((blendPatternMatch is not None and blendPatternMatch) or (blendPatternMatch is None and self._textureOverrideBlendPattern.search(line)))):
            self._textureOverrideBlendRoot = self._getSectionName(line)
            self._isModIni = True
            return

        for modType in self.modTypes:
            if (modType.isType(line)):
                self._textureOverrideBlendRoot = self._getSectionName(line)
                self._setType(modType)
                self._isModIni = True
                break

    def _checkFixed(self, line: str):
        """
        Checks if a line of text matches the regex, ``[.*TextureOverride.*RemapBlend.*]`` ,to identify whether the .ini file has been fixed

        Parameters
        ----------
        line: :class:`str`
            The line of text to check
        """

        if (not self._isFixed and self._fixedTextureOverrideBlendPattern.search(line)):
            self._isFixed = True

    def _parseSection(self, sectionName: str, srcTxt: str, save: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, str]]:
        """
        Regularly parses the key-value pairs of a certain `section`_

        The function parses uses `ConfigParser`_ to parse the `section`_.

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_

        srcTxt: :class:`str`
            The text containing the entire `section`_

        save: Optional[Dict[:class:`str`, Any]]
            Place to save the parsed result for the `section`_  :raw-html:`<br />` :raw-html:`<br />`

            The result for the parsed `section`_ will be saved as a value in the dictionary while section's name will be used in the key for the dictionary :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Optional[Dict[:class:`str`, :class:`str`]]
            The result from parsing the `section`_

            .. note:: 
                If `ConfigParser`_ is unable to parse the section, then ``None`` is returned
        """

        result = None   

        # delete any previously saved sections
        try:
            self._parser[sectionName]
        except KeyError:
            pass
        else:
            del self._parser[sectionName]

        # parse the section
        try:
            self._parser.read_string(srcTxt)
            result = self._parser[sectionName]
        except:
            return result

        if (self._parserDictType == KeepAllDict):
            sectionOpts = {}
            for varName in result:
                sectionOpts[varName] = self._parser.get(sectionName, varName, raw = True)

            result = sectionOpts
            for key in result:
                currentValues = result[key]
                result[key] = []

                for val in currentValues:
                    if (not val):
                        continue

                    currentValue = val.split("_", 1)
                    currentValue[0] = int(currentValue[0])
                    result[key].append(tuple(currentValue))
        else:
            result = dict(result)

        try:
            save[sectionName] = result
        except TypeError:
            pass
        
        #print(f"RESULLULULUT: {result}")
        return result
    
    def _getSectionName(self, line: str) -> str:
        currentSectionName = line
        rightPos = currentSectionName.rfind("]")
        leftPos = currentSectionName.find("[")

        if (rightPos > -1 and leftPos > -1):
            currentSectionName = currentSectionName[leftPos + 1:rightPos]
        elif (rightPos > -1):
            currentSectionName = currentSectionName[:rightPos]
        elif (leftPos > -1):
            currentSectionName = currentSectionName[leftPos + 1:]

        return currentSectionName.strip()

    # retrieves the key-value pairs of a section in the .ini file. Manually parsed the file since ConfigParser
    #   errors out on conditional statements in .ini file for mods. Could later inherit from the parser (RawConfigParser) 
    #   to custom deal with conditionals
    @_readLines
    def getSectionOptions(self, section: Union[str, Pattern, Callable[[str], bool]], postProcessor: Optional[Callable[[int, int, List[str], str, str], Any]] = None, 
                          handleDuplicateFunc: Optional[Callable[[List[Any]], Any]] = None) -> Dict[str, Any]:
        """
        Reads the entire .ini file for a certain type of `section`_

        Parameters
        ----------
        section: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
            The type of section to find

            * If this argument is a :class:`str`, then will check if the line in the .ini file exactly matches the argument
            * If this argument is a `Pattern`_, then will check if the line in the .ini file matches the specified Regex pattern
            * If this argument is a function, then will check if the line in the .ini file passed as an argument for the function will make the function return ``True``

        postProcessor: Optional[Callable[[:class:`int`, :class:`int`, List[:class:`str`], :class:`str`, :class:`str`], Any]]
            Post processor used when a type of `section`_ has been found

            The order of arguments passed into the post processor will be:

            #. The starting line index of the `section`_ in the .ini file
            #. The ending line index of the `section`_ in the .ini file
            #. All the file lines read from the .ini file
            #. The name of the `section`_ found
            #. The entire text for the `section`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: `None`

        handleDuplicateFunc: Optional[Callable[List[Any], Any]]
            Function to used to handle the case of multiple sections names :raw-html:`<br />` :raw-html:`<br />`

            If this value is set to ``None``, will keep all sections with the same names

            .. note::
                For this case, GIMI only keeps the first instance of all sections with same names

            :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        Dict[:class:`str`, Any]
            The resultant `sections`_ found

            The keys are the names of the `sections`_ found and the values are the content for the `section`_,
        """

        sectionFilter = None
        if (isinstance(section, str)):
            sectionFilter = lambda line: line == section
        elif callable(section):
            sectionFilter = section
        else:
            sectionFilter = lambda line: section.search(line)

        if (postProcessor is None):
            postProcessor = lambda startInd, endInd, fileLines, sectionName, srcTxt: self._parseSection(sectionName, srcTxt)

        result = {}
        currentSectionName = None
        currentSectionToParse = None
        currentSectionStartInd = -1

        fileLinesLen = len(self._fileLines)

        for i in range(fileLinesLen):
            line = self._fileLines[i]
            self._checkFixed(line)
            self._checkModType(line)

            # process the resultant section
            if (currentSectionToParse is not None and self._sectionPattern.search(line)):
                currentResult = postProcessor(currentSectionStartInd, i, self._fileLines, currentSectionName, currentSectionToParse)
                if (currentResult is None):
                    continue

                # whether to keep sections with the same name
                try:
                    result[currentSectionName]
                except KeyError:
                    result[currentSectionName] = [currentResult]
                else:
                    result[currentSectionName].append(currentResult)

                currentSectionToParse = None
                currentSectionName = None
                currentSectionStartInd = -1

            elif (currentSectionToParse is not None):
                currentSectionToParse += f"{line}"

            # keep track of the found section
            if (sectionFilter(line)):
                currentSectionToParse = f"{line}"
                currentSectionName = self._getSectionName(currentSectionToParse)
                currentSectionStartInd = i

        # get any remainder section
        if (currentSectionToParse is not None):
            currentResult = postProcessor(currentSectionStartInd, fileLinesLen, self._fileLines, currentSectionName, currentSectionToParse)
            try:
                result[currentSectionName]
            except:
                result[currentSectionName] = [currentResult]
            else:
                result[currentSectionName].append(currentResult)

        if (handleDuplicateFunc is None):
            return result

        # handle the duplicate sections with the same names
        for sectionName in result:
            result[sectionName] = handleDuplicateFunc(result[sectionName])

        return result

    def _removeSection(self, startInd: int, endInd: int, fileLines: List[str], sectionName: str, srcTxt: str) -> Tuple[int, int]:
        """
        Retrieves the starting line index and ending line index of where to remove a certain `section`_ from the read lines of the .ini file

        Parameters
        ----------
        startInd: :class:`int`
            The starting line index of the `section`_

        endInd: :class:`int`
            The ending line index of the `section`_

        fileLines: List[:class:`str`]
            All the file lines read from the .ini file

        sectionName: :class:`str`
            The name of the `section`_

        srcTxt: :class:`str`
            The text content of the `section`_

        Returns
        -------
        Tuple[:class:`int`, :class:`int`]
            The starting line index and the ending line index of the `section`_ to remove
        """

        fileLinesLen = len(fileLines)
        if (endInd > fileLinesLen):
            endInd = fileLinesLen

        if (startInd > fileLinesLen):
            startInd = fileLinesLen

        return (startInd, endInd)
    
    def removeSectionOptions(self, section: Union[str, Pattern, Callable[[str], bool]]):
        """
        Removes a certain type of `section`_ from the .ini file

        Parameters
        ----------
        section: Union[:class:`str`, `Pattern`_, Callable[[:class:`str`], :class:`bool`]]
            The type of `section`_ to remove
        """

        rangesToRemove = self.getSectionOptions(section, postProcessor = self._removeSection)
        partIndices = []

        for sectionName, ranges in rangesToRemove.items():
            for range in ranges:
                partIndices.append(range)

        self.fileLines = TextTools.removeLines(self._fileLines, partIndices)

    def _processIfTemplate(self, startInd: int, endInd: int, fileLines: List[str], sectionName: str, srcTxt: str) -> IfTemplate:
        """
        Parses a `section`_ in the .ini file as an :class:`IfTemplate`

        .. note::
            See :class:`IfTemplate` to see how we define an 'IfTemplate'

        Parameters
        ----------
        startInd: :class:`int`
            The starting line index of the `section`_

        endInd: :class:`int`
            The ending line index of the `section`_

        fileLines: List[:class:`str`]
            All the file lines read from the .ini file

        sectionName: :class:`str`
            The name of the `section`_

        srcTxt: :class:`str`
            The text content of the `section`_

        Returns
        -------
        :class:`IfTemplate`
            The generated :class:`IfTemplate` from the `section`_
        """

        ifTemplate = []
        dummySectionName = "dummySection"
        currentDummySectionName = f"{dummySectionName}"
        replaceSection = ""
        atReplaceSection = False

        for i in range(startInd + 1, endInd):
            line = fileLines[i]
            isConditional = bool(self._ifStructurePattern.match(line))

            if (isConditional and atReplaceSection):
                currentDummySectionName = f"{dummySectionName}{i}"
                replaceSection = f"[{currentDummySectionName}]\n{replaceSection}"

                currentPart = self._parseSection(currentDummySectionName, replaceSection)
                if (currentPart is None):
                    currentPart = {}

                ifTemplate.append(currentPart)
                replaceSection = ""

            if (isConditional):
                ifTemplate.append(line)
                atReplaceSection = False
                continue
            
            replaceSection += line
            atReplaceSection = True

        # get any remainder replacements in the if..else template
        if (replaceSection != ""):
            currentDummySectionName = f"{dummySectionName}END{endInd}"
            replaceSection = f"[{currentDummySectionName}]\n{replaceSection}"
            currentPart = self._parseSection(currentDummySectionName, replaceSection)
            if (currentPart is None):
                currentPart = {}

            if (currentPart):
                ifTemplate.append(currentPart)

        # create the if template
        result = IfTemplate.build(ifTemplate, name = sectionName)
        return result
    

    def getIfTemplates(self, flush: bool = False) -> Dict[str, IfTemplate]:
        """
        Retrieves all the :class:`IfTemplate`s for the .ini file

        .. note::
            This is the same as :meth:`IniFile.readIfTemplates`, but uses caching

        Parameters
        ----------
        flush: :class:`bool`
            Whether to re-parse the :class:`IfTemplates`s instead of using the saved cached values

        Returns
        -------
        Dict[:class:`str`, :class:`IfTempalte`]
            The parsed :class:`IfTemplate`s :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the name of the :class:`IfTemplate`
            * The values are the corresponding :class:`IfTemplate`
        """

        if (not self._ifTemplatesRead or flush):
            self.readIfTemplates()
        return self.sectionIfTemplates

    def readIfTemplates(self) -> Dict[str, IfTemplate]:
        """
        Parses all the :class:`IfTemplate`s for the .ini file

        Returns
        -------
        Dict[:class:`str`, :class:`IfTempalte`]
            The parsed :class:`IfTemplate`s :raw-html:`<br />` :raw-html:`<br />`

            * The keys are the name of the :class:`IfTemplate`
            * The values are the corresponding :class:`IfTemplate`
        """

        self.sectionIfTemplates = self.getSectionOptions(self._sectionPattern, postProcessor = self._processIfTemplate, handleDuplicateFunc = lambda duplicates: duplicates[0])
        self._ifTemplatesRead = True
        return self.sectionIfTemplates 
    
    @classmethod
    def getMergedResourceIndex(cls, mergedResourceName: str) -> Optional[int]:
        """
        Retrieves the index number of a resource created by GIMI's ``genshin_merge_mods.py`` script

        Examples
        --------
        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend.8")
        8


        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend.Score.-100")
        -100


        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend.UnitTests")
        None


        >>> IniFile.getMergedResourceIndex("ResourceCuteLittleEiBlend")
        None

        Parameters
        ----------
        mergedResourceName: :class:`str`
            The name of the `section`_

        Returns
        -------
        Optional[:class:`int`]
            The index for the resource `section`_, if found and the index is an integer
        """
        result = None

        try:
            result = int(mergedResourceName.rsplit(".", 1)[-1])
        except:
            pass
            
        return result
    
    @classmethod
    def compareResources(cls, resourceTuple1: Tuple[str, Optional[int]], resourceTuple2: Tuple[str, Optional[int]]) -> int:
        """
        Compare function used for sorting resources :raw-html:`<br />` :raw-html:`<br />`

        The order for sorting is the resources is:
        
        #. Resources that do are not suffixed by an index number
        #. Resource that are suffixed by an index number (see :meth:`IniFile.getMergedResourceIndex` for more info)

        Parameters
        ----------
        resourceTuple1: Tuple[:class:`str`, Optional[:class:`int`]]
            Data for the first resource in the compare function, contains:

            * Name of the resource
            * The index for the resource

        resourceTuple2: Tuple[:class:`str`, Optional[:class:`int`]]
            Data for the second resource in the compare function, contains:

            * Name of the resource
            * The index for the resource

        Returns
        -------
        :class:`int`
            The result for a typical compare function used in sorting

            * returns -1 if ``resourceTuple1`` should come before ``resourceTuple2``
            * returns 1 if ``resourceTuple1`` should come after ``resourceTuple2``
            * returns 0 if ``resourceTuple1`` is equal to ``resourceTuple2`` 
        """

        resourceKey1 = resourceTuple1[1]
        resourceKey2 = resourceTuple2[1]
        resource1MissingIndex = resourceKey1 is None
        resource2MissingIndex = resourceKey2 is None

        if (resource1MissingIndex):
            resourceKey1 = resourceTuple1[0]
        
        if (resource2MissingIndex):
            resourceKey2 = resourceTuple2[0]

        if ((resource1MissingIndex == resource2MissingIndex and resourceKey1 < resourceKey2) or (resource1MissingIndex and not resource2MissingIndex)):
            return -1
        elif ((resource1MissingIndex == resource2MissingIndex and resourceKey1 > resourceKey2) or (not resource1MissingIndex and resource2MissingIndex)):
            return 1
        
        return 0

    # Disabling the OLD ini
    def disIni(self, makeCopy: bool = False):
        """
        Disables the .ini file

        .. note::
            For more info, see :meth:`FileService.disableFile` 

        Parameters
        ----------
        makeCopy: :class:`bool`
            Whether to make a copy of the disabled .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``
        """

        if (self._filePath is None):
            return

        disabledPath = FileService.disableFile(self._filePath.path)
        if (makeCopy):
            FileService.copyFile(disabledPath, self._filePath.path)

    @classmethod
    def getFixedBlendFile(cls, blendFile: str, modName: str = "") -> str:
        """
        Retrieves the file path for the fixed RemapBlend.buf file

        Parameters
        ----------
        blendFile: :class:`str`
            The file path to the original Blend.buf file

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapBlend.buf file
        """

        blendFolder = os.path.dirname(blendFile)
        blendBaseName = os.path.basename(blendFile)
        blendBaseName = blendBaseName.rsplit(".", 1)[0]
        
        return os.path.join(blendFolder, f"{cls.getRemapBlendName(blendBaseName, modName = modName)}{FileExt.Buf.value}")
    
    @classmethod
    def getFixedTexFile(cls, texFile: str, modName: str = "") -> str:
        """
        Retrieves the file path for the fixed RemapTex.dds file

        Parameters
        ----------
        texFile: :class:`str`
            The file path to the original .dds file

        modName: :class:`str`
            The name of the mod to fix to

        Returns
        -------
        :class:`str`
            The file path of the fixed RemapTex.dds file
        """

        blendFolder = os.path.dirname(texFile)
        blendBaseName = os.path.basename(texFile)
        blendBaseName = blendBaseName.rsplit(".", 1)[0]

        return os.path.join(blendFolder, f"{cls.getRemapTexName(blendBaseName, modName = modName)}{FileExt.DDS.value}")
    
    def getFixModTypeName(self) -> Optional[str]:
        """
        Retrieves the name of the type of mod corresponding to the .ini file to be used for the comment of the fix

        Returns
        -------
        Optional[:class:`str`]
            The name for the type of mod corresponding to the .ini file
        """
        if (self._type is None):
            return None
        return self._type.name.replace("\n", "").replace("\t", "")
    
    def getFixModTypeHeadingname(self):
        """
        Retrieves the name of the type of mod corresponding to the .ini file to be used in the header/footer divider comment of the fix

        Returns
        -------
        Optional[:class:`str`]
            The name for the type of mod to be displayed in the header/footer divider comment
        """

        modTypeName = self.getFixModTypeName()
        if (modTypeName is None):
            modTypeName = "GI"

        return modTypeName

    def getHeadingName(self):
        """
        Retrieves the title for the header of the divider comment of the fix

        Returns
        -------
        :class:`str`
            The title for the header of the divider comment
        """

        result = self.getFixModTypeHeadingname()
        if (result):
            result += " "

        return f"{result}Remap"

    def getFixHeader(self) -> str:
        """
        Retrieves the header text used to identify a code section has been changed by this fix
        in the .ini file

        Returns
        -------
        :class:`str`
            The header section comment to be used in the .ini file
        """
        
        if (self._heading.title is None):
            self._heading.title = self.getHeadingName()
        return f"; {self._heading.open()}"
    
    def getFixFooter(self) -> str:
        """
        Retrieves the footer text used to identify a code section has been changed by this fix
        in the .ini file

        Returns
        -------
        :class:`str`
            The footer section comment to be used in the .ini file
        """

        if (self._heading.title is None):
            self._heading.title = self.getHeadingName()
        return f"\n\n; {self._heading.close()}"
    
    def getFixCredit(self) -> str:
        """
        Retrieves the credit text for the code generated in the .ini file

        Returns
        -------
        :class:`str`
            The credits to be displayed in the .ini file
        """

        modTypeName = self.getFixModTypeName()
        shortModTypeName = modTypeName

        if (modTypeName is None):
            modTypeName = "Mod"
            shortModTypeName = ""

        if (modTypeName):
            modTypeName += " "
        
        if (shortModTypeName):
            shortModTypeName += " "
        
        return IniBoilerPlate.Credit.value.replace(IniBoilerPlate.ModTypeNameReplaceStr.value, modTypeName).replace(IniBoilerPlate.ShortModTypeNameReplaceStr.value, shortModTypeName)
    
    def addFixBoilerPlate(self, fix: str = "") -> str:
        """
        Adds the boilerplate code to identify the .ini `sections`_ have been changed by this fix

        Parameters
        ----------
        fix: :class:`str`
            The content for the fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The fix with the boilerplate code included
        """

        result = self.getFixHeader()
        result += self.getFixCredit()
        result += fix
        result += self.getFixFooter()
        return result

    def fixBoilerPlate(func):
        """
        Decorator used to add the boilerplate code to identify a code section has been changed by this fix in the .ini file

        Examples
        --------
        .. code-block:: python
            :linenos:

            @fixBoilerPlate
            def helloWorld(self) -> str:
                return "Hello World"
        """

        def addFixBoilerPlateWrapper(self, *args, **kwargs):
            fix = func(self, *args, **kwargs)
            fix = self.addFixBoilerPlate(fix = fix)
            return fix
        return addFixBoilerPlateWrapper
    
    @classmethod
    def getResourceName(cls, name: str) -> str:
        """
        Makes the name of a `section`_ to be used for the resource `sections`_ of a .ini file

        Examples
        --------
        >>> IniFile.getResourceName("CuteLittleEi")
        "ResourceCuteLittleEi"


        >>> IniFile.getResourceName("ResourceCuteLittleEi")
        "ResourceCuteLittleEi"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        Returns
        -------
        :class:`str`
            The name of the `section`_ as a resource in a .ini file
        """

        if (not name.startswith(IniKeywords.Resource.value)):
            name = f"{IniKeywords.Resource.value}{name}"
        return name
    
    @classmethod
    def removeResourceName(cls, name: str) -> str:
        """
        Removes the 'Resource' prefix from a section's name

        Examples
        --------
        >>> IniFile.removeResourceName("ResourceCuteLittleEi")
        "CuteLittleEi"


        >>> IniFile.removeResourceName("LittleMissGanyu")
        "LittleMissGanyu"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the 'Resource' prefix removed
        """

        if (name.startswith(IniKeywords.Resource.value)):
            name = name[len(IniKeywords.Resource.value):]

        return name
    
    @classmethod
    def getRemapBlendName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the keyword 'RemapBlend' to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapBlendName("EiTriesToUseBlenderAndFails", "Raiden")
        "EiTriesToUseRaidenRemapBlenderAndFails"


        >>> IniFile.getRemapBlendName("EiBlendsTheBlender", "Yae")
        "EiBlendsTheYaeRemapBlender"
    

        >>> IniFile.getRemapBlendName("ResourceCuteLittleEi", "Raiden")
        "ResourceCuteLittleEiRaidenRemapBlend"


        >>> IniFile.getRemapBlendName("ResourceCuteLittleEiRemapBlend", "Raiden")
        "ResourceCuteLittleEiRemapRaidenRemapBlend"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapBlend' keyword
        """

        nameParts = name.rsplit(IniKeywords.Blend.value, 1)
        namePartsLen = len(nameParts)

        remapName = f"{modName}{IniKeywords.RemapBlend.value}"
        if (namePartsLen > 1):
            name = remapName.join(nameParts)
        else:
            name += remapName

        return name
    
    @classmethod
    def getModSuffixedName(cls, name: str, suffix: str = "", modName: str = ""):
        """
        Changes a `section`_ name to have the suffix of 'modName' followed by 'suffix'

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        suffix: :class:`str`
            The name of the suffix to put at the end of the `section`_ :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added suffix keyword
        """

        remapName = f"{modName}{suffix}"
        if (name.endswith(remapName)):
            return name
        elif(name.endswith(suffix)):
            return name[:len(suffix)] + remapName

        return name + remapName
    
    @classmethod
    def getRemapFixName(cls, name: str, modName: str = "") -> str:
        """
        Changes a `section`_ name to have the suffix `RemapFix` to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapFixName("EiIsDoneWithRemapFix", "Raiden")
        "EiIsDoneWithRaidenRemapFix"

        >>> IniFile.getRemapFixName("EiIsHappy", "Raiden")
        "EiIsHappyRaidenRemapFix"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapFix' keyword
        """

        return cls.getModSuffixedName(name, suffix = IniKeywords.RemapFix.value, modName = modName)
    
    @classmethod
    def getRemapTexName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to have the suffix `RemapFix` to identify that the `section`_
        is created by this fix

        Examples
        --------
        >>> IniFile.getRemapTexName("EiIsDoneWithRemapTex", "Raiden")
        "EiIsDoneWithRaidenRemapTex"

        >>> IniFile.getRemapTexName("EiIsHappy", "Raiden")
        "EiIsHappyRaidenRemapTex"

        Parameters
        ----------
        name: :class:`str`
            The name of the `section`_

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the `section`_ with the added 'RemapFix' keyword
        """

        return cls.getModSuffixedName(name, suffix = IniKeywords.RemapTex.value, modName = modName)

    @classmethod
    def getRemapFixResourceName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to be a new non-blend resource created by this fix

        .. note::
            See :meth:`IniFile.getResourceName` and :meth:`IniFile.getRemapFix` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the suffix 'RemapFix' added
        """

        name = cls.getRemapFixName(name, modName = modName)
        name = cls.getResourceName(name)
        return name
    
    @classmethod
    def getRemapTexResourceName(cls, name: str, modName: str = ""):
        """
        Changes a `section`_ name to be a texture resource created by this fix

        .. note::
            See :meth:`IniFile.getResourceName` and :meth:`IniFile.getRemapTexName` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the suffix 'RemapFix' added
        """

        name = cls.getRemapTexName(name, modName = modName)
        name = cls.getResourceName(name)
        return name

    @classmethod
    def getRemapBlendResourceName(cls, name: str, modName: str = "") -> str:
        """
        Changes the name of a section to be a new resource that this fix will create

        .. note::
            See :meth:`IniFile.getResourceName` and :meth:`IniFile.getRemapBlendName` for more info

        Parameters
        ----------
        name: :class:`str`
            The name of the section

        modName: :class:`str`
            The name of the mod to fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``""``

        Returns
        -------
        :class:`str`
            The name of the section with the prefix 'Resource' and the keyword 'Remap' added
        """

        name = cls.getRemapBlendName(name, modName = modName)
        name = cls.getResourceName(name)
        return name

    def _isIfTemplateResource(self, ifTemplatePart: Dict[str, Any]) -> bool:
        """
        Whether the content for some part of a `section`_ contains the key 'vb1'

        Parameters
        ----------
        ifTemplatePart: Dict[:class:`str`, Any]
            The key-value pairs for some part in a `section`_

        Returns
        -------
        :class:`bool`
            Whether 'vb1' is contained in the part
        """

        return IniKeywords.Vb1.value in ifTemplatePart
    
    def _isIfTemplateDraw(self, ifTemplatePart: Dict[str, Any]) -> bool:
        """
        Whether the content for some part of a `section`_ contains the key 'draw'

        Parameters
        ----------
        ifTemplatePart: Dict[:class:`str`, Any]
            The key-value pairs for some part in a `section`_

        Returns
        -------
        :class:`bool`
            Whether 'draw' is contained in the part
        """


        return IniKeywords.Draw.value in ifTemplatePart
    
    def _getIfTemplateResourceName(self, ifTemplatePart: Dict[str, Any]) -> Any:
        """
        Retrieves the value from the key, 'vb1', for some part of a `section`_

        Parameters
        ----------
        ifTemplatePart: Dict[:class:`str`, Any]
            The key-value pairs for some part in a `section`_

        Returns
        -------
        Any
            The corresponding value for the key 'vb1'
        """

        return ifTemplatePart[IniKeywords.Vb1.value]
    
    # fills the if..else template in the .ini for each section
    def fillIfTemplate(self, modName: str, sectionName: str, ifTemplate: IfTemplate, fillFunc: Callable[[str, str, Union[str, Dict[str, Any]], int, int, str], str], origSectionName: Optional[str] = None) -> str:
        """
        Creates a new :class:`IfTemplate` for an existing `section`_ in the .ini file

        Parameters
        ----------
        modName: :class:`str`
            The name for the type of mod to fix to

        sectionName: :class:`str`
            The new name of the `section`_

        ifTemplate: :class:`IfTemplate`
            The :class:`IfTemplate` of the orginal `section`_

        fillFunc: Callable[[:class:`str`, :class:`str`, Union[:class:`str`, Dict[:class:`str`, Any], :class:`int`, :class:`str`, :class:`str`], :class:`str`]]
            The function to create a new **content part** for the new :class:`IfTemplate`
            :raw-html:`<br />` :raw-html:`<br />`

            .. tip::
                For more info about an 'IfTemplate', see :class:`IfTemplate`

            :raw-html:`<br />`
            The parameter order for the function is:

            #. The name for the type of mod to fix to
            #. The new section name
            #. The corresponding **content part** in the original :class:`IfTemplate`
            #. The index for the content part in the original :class:`IfTemplate`
            #. The string to prefix every line in the **content part** of the :class:`IfTemplate`
            #. The original name of the section

        origSectionName: Optional[:class:`str`]
            The original name of the section.

            If this argument is set to ``None``, then will assume this argument has the same value as the argument for ``sectionName`` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`str`
            The text for the newly created :class:`IfTemplate`
        """

        addFix = f"[{sectionName}]\n"
        partIndex = 0
        linePrefix = ""

        if (origSectionName is None):
            origSectionName = sectionName

        for part in ifTemplate:
            # adding in the if..else statements
            if (isinstance(part, str)):
                addFix += part
                
                linePrefix = re.match(r"^[( |\t)]*", part)
                if (linePrefix):
                    linePrefix = linePrefix.group(0)
                    linePrefixLen = len(linePrefix)

                    linePrefix = part[:linePrefixLen]
                    lStrippedPart = part[linePrefixLen:]

                    if (lStrippedPart.find("endif") == -1):
                        linePrefix += "\t"
                partIndex += 1
                continue
            
            # add in the content within the if..else statements
            addFix += fillFunc(modName, sectionName, part, partIndex, linePrefix, origSectionName)

            partIndex += 1
            
        return addFix
    
    

    # _getCommonMods(): Retrieves the common mods that need to be fixed between all target graphs
    #   that are used for the fix
    def _getCommonMods(self) -> Set[str]:
        if (self._type is None):
            return set()
        
        result = set()
        hashes = self._type.hashes
        indices = self._type.indices

        graphs = [self._blendCommandsGraph, self._nonBlendHashIndexCommandsGraph, self._resourceCommandsGraph]
        for graph in graphs:
            commonMods = graph.getCommonMods(hashes, indices, version = self.version)
            if (not result):
                result = commonMods
            else:
                result = result.intersection(commonMods)

        return result
    

    def _setToFix(self) -> Set[str]:
        """
        Sets the names for the types of mods that will used in the fix

        Returns
        -------
        Set[:class:`str`]
            The names of the mods that will be used in the fix        
        """

        commonMods = self._getCommonMods()
        toFix = commonMods.intersection(self.modsToFix)
        type = self.availableType

        if (not toFix and type is not None):
            self._toFix = type.getModsToFix()
        elif (not toFix):
            self._toFix = commonMods
        else:
            self._toFix = toFix

        return self._toFix

    # _makeRemapNames(): Makes the required names used for the fix
    def _makeRemapNames(self):
        self._blendCommandsGraph.getRemapBlendNames(self._toFix)
        self._nonBlendHashIndexCommandsGraph.getRemapBlendNames(self._toFix)
        self._resourceCommandsGraph.getRemapBlendNames(self._toFix)

    # _getCommonMods(): Retrieves the common mods that need to be fixed between all target graphs
    #   that are used for the fix
    def _getCommonMods(self) -> Set[str]:
        if (self._type is None):
            return set()
        
        result = set()
        hashes = self._type.hashes
        indices = self._type.indices

        graphs = [self._blendCommandsGraph, self._nonBlendHashIndexCommandsGraph, self._resourceCommandsGraph]
        for graph in graphs:
            commonMods = graph.getCommonMods(hashes, indices, version = self.version)
            if (not result):
                result = commonMods
            else:
                result = result.intersection(commonMods)

        return result
    

    def _setToFix(self) -> Set[str]:
        """
        Sets the names for the types of mods that will used in the fix

        Returns
        -------
        Set[:class:`str`]
            The names of the mods that will be used in the fix        
        """

        commonMods = self._getCommonMods()
        toFix = commonMods.intersection(self.modsToFix)
        type = self.availableType

        if (not toFix and type is not None):
            self._toFix = type.getModsToFix()
        elif (not toFix):
            self._toFix = commonMods
        else:
            self._toFix = toFix

        return self._toFix

    
    # _makeRemapNames(): Makes the required names used for the fix
    def _makeRemapNames(self):
        self._blendCommandsGraph.getRemapBlendNames(self._toFix)
        self._nonBlendHashIndexCommandsGraph.getRemapBlendNames(self._toFix)
        self._resourceCommandsGraph.getRemapBlendNames(self._toFix)


    # _getRemapName(sectionName, modName, sectionGraph, remapNameFunc): Retrieves the required remap name for the fix
    def _getRemapName(self, sectionName: str, modName: str, sectionGraph: Optional[IniSectionGraph] = None, remapNameFunc: Optional[Callable[[str, str], str]] = None) -> str:
        error = False
        if (sectionGraph is None):
            error = True

        if (not error):
            try:
                return sectionGraph.remapNames[sectionName][modName]
            except KeyError:
                error = True

        if (sectionName not in self.sectionIfTemplates):
            return sectionName

        if (remapNameFunc is None):
            remapNameFunc = self.getRemapBlendName

        return remapNameFunc(sectionName, modName)
    

    def _getFixer(self):
        """
        Retrieves the fixer for fixing the .ini file

        Returns
        -------
        Optional[:class:`BaseIniFixer`]
            The resultant fixer
        """

        availableType = self.availableType
        if (availableType is not None and self._iniParser is not None and self._iniFixer is None):
            self._iniFixer = availableType.iniFixBuilder.build(self._iniParser)
        
        return self._iniFixer
    
    # _getFixStr(fix, withBoilerPlate): Internal functino to get the needed lines to fix the .ini file
    def _getFixStr(self, fix: str = "", withBoilerPlate: bool = True) -> str:
        fixer = self._getFixer()
        availableType = self.availableType

        if (fixer is None and availableType is not None):
            return fix
        elif (availableType is None):
            raise NoModType()

        result = fixer.getFix(fixStr = fix)

        if (withBoilerPlate):
            return self.addFixBoilerPlate(fix = result)
        return result

    def getFixStr(self, fix: str = "") -> str:
        """
        Generates the newly added code in the .ini file for the fix

        Parameters
        ----------
        fix: :class:`str`
            Any existing text we want the result of the fix to add onto :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ""

        Returns
        -------
        :class:`str`
            The text for the newly generated code in the .ini file
        """

        return self._getFixStr(fix = fix)

    @_readLines
    def injectAddition(self, addition: str, beforeOriginal: bool = True, keepBackup: bool = True, fixOnly: bool = False, update: bool = False) -> str:
        """
        Adds and writes new text to the .ini file

        Parameters
        ----------
        addition: :class:`str`
            The text we want to add to the file

        beforeOriginal: :class:`bool`
            Whether to add the new text before the original text :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        keepBackup: :class:`bool`
            Whether we want to make a backup copy of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether we are only fixing the .ini file without removing any previous changes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        update: :class:`bool`
            Whether to update the source text within this class to reflect the new addition :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The content of the .ini file with the new text added
        """

        original = self._fileTxt
        if (keepBackup and fixOnly and self._filePath is not None):
            self.print("log", "Cleaning up and disabling the OLD STINKY ini")
            self.disIni()

        result = ""
        if (beforeOriginal):
            result = f"{addition}\n\n{original}"
        else:
            result = f"{original}\n{addition}"

        # writing the fixed file
        if (self._filePath is not None):
            with open(self._filePath.path, "w", encoding = FileEncodings.UTF8.value) as f:
                f.write(result)

        # update the source text
        if (update):
            self._fileTxt = result
            self._fileLines = TextTools.getTextLines(result)

        self._isFixed = True
        return result

    def _removeFix(self, parse: bool = False) -> str:
        """
        Removes any previous changes that were probably made by this script :raw-html:`<br />` :raw-html:`<br />`

        For the .ini file will remove:

        #. All code surrounded by the *'---...--- .* Fix ---...----'* header/footer
        #. All `sections`_ containing the keywords ``RemapBlend``

        Parameters
        ----------
        parse: :class:`bool`
            Whether to keep track of the Blend.buf files that also need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file with the changes removed
        """

        self._getRemover()
        return self._iniRemover.remove(parse = parse)
    
    def _getRemover(self) -> BaseIniRemover:
        """
        Retrieves the remover for removing fixes from the .ini file

        Returns
        -------
        :class:`BaseIniRemover`
            The resultant parser
        """

        availableType = self.availableType

        if (availableType is not None and self._iniRemover is None):
            self._iniRemover = availableType.iniRemoveBuilder.build(self)
            self._iniRemover.iniFile = self
        elif (self._iniRemover is None):
            self._iniRemover = GlobalIniRemoveBuilder.build(self)
        
        return self._iniRemover

    @_readLines
    def removeFix(self, keepBackups: bool = True, fixOnly: bool = False, parse: bool = False) -> str:
        """
        Removes any previous changes that were probably made by this script and creates backup copies of the .ini file

        .. tip::
            For more info about what gets removed from the .ini file, see :meth:`IniFile._removeFix`

        Parameters
        ----------
        keepBackup: :class:`bool`
            Whether we want to make a backup copy of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether we are only fixing the .ini file without removing any previous changes :raw-html:`<br />` :raw-html:`<br />`

            .. note::
                If this value is set to ``True``, then the previous changes made by this script will not be removed

            **Default**: ``False``

        parse: :class:`bool`
            Whether to also parse for the .*RemapBlend.buf files that need to be removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        :class:`str`
            The new text content of the .ini file with the changes removed
        """

        if (keepBackups and not fixOnly and self._filePath is not None):
            self.print("log", f"Creating Backup for {self._filePath.base}")
            self.disIni(makeCopy = True)

        if (fixOnly):
            return self._fileTxt

        if (self._filePath is not None):
            self.print("log", f"Removing any previous changes from this script in {self._filePath.base}")

        result = self._removeFix(parse = parse)
        return result
    
    def makeResourceModel(self, ifTemplate: IfTemplate, toFix: Set[str], getFixedFile: Optional[Callable[[str, str], str]] = None,
                          iniResourceModelCls: Type[IniResourceModel] = IniResourceModel, 
                          iniResModelArgs: Optional[List[Any]] = None, iniResModelKwargs: Optional[Dict[str, Any]] = None) -> IniResourceModel:
        """
        Creates the data needed for fixing a particular ``[Resource.*]`` `section`_ in the .ini file

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The particular `section`_ to extract data

        toFix: Set[:class:`str`]
            The names of the mods to fix 

        getFixedFile: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
            The function for transforming the file path of a found resource file into a new file path for the fixed resources file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedBlendFile` :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are:

                # The path to the original file
                # The type of mod to fix to

            **Default**: ``None``

        iniResourceModelCls: Type[:class:`IniResourceModel`]
            A subclass of :class:`IniResourceModel` for constructing the required data

            .. attention::
                The constructor of this subclass must at least have the same arguments and keyword arguments
                as the constructor for :class:`IniResourceModels`

             **Default**: :class:`IniResourceModel`

        iniResModelArgs: Optional[List[Any]]
            Any arguments to add onto the contructor for creating the subclass of a :class:`IniResourceModel` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        iniResModelKwargs: Optional[Dict[:class:`str`, Any]]
            Any keyword arguments to add onto the constructor for creating the subclass of a :class:`IniResourceModel` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Returns
        -------
        :class:`IniResourceModel`
            The data for fixing the particular resource
        """

        folderPath = self.folder
        if (getFixedFile is None):
            getFixedFile = self.getFixedBlendFile

        origResPaths = {}
        fixedResPaths = {}
        partIndex = 0

        for part in ifTemplate:
            if (isinstance(part, IfPredPart)):
                partIndex += 1
                continue

            currentOrigResPaths = []
            try:
                currentOrigResPaths = part[IniKeywords.Filename.value]
            except KeyError:
                partIndex += 1
                continue
            
            currentOrigResPaths = list(map(lambda pathData: FileService.parseOSPath(pathData[1]), currentOrigResPaths))
            origResPaths[partIndex] = currentOrigResPaths

            for modName in toFix:
                currentFixedResPaths = list(map(lambda origBlendFile: getFixedFile(origBlendFile, modName = modName), currentOrigResPaths))

                try:
                    fixedResPaths[partIndex]
                except KeyError:
                    fixedResPaths[partIndex] = {}

                fixedResPaths[partIndex][modName] = currentFixedResPaths

            partIndex += 1

        if (iniResourceModelCls == IniResourceModel): 
            return IniResourceModel(folderPath, fixedResPaths, origPaths = origResPaths)

        if (iniResModelKwargs is None):
            iniResModelKwargs = {}

        if (iniResModelArgs is None):
            iniResModelArgs = []

        return iniResourceModelCls(folderPath, fixedResPaths, *iniResModelArgs, origPaths = origResPaths, **iniResModelKwargs)
    
    def makeTexModel(self, ifTemplate: IfTemplate, toFix: Set[str], texEditors: Union[BaseTexEditor, Dict[int, Dict[str, List[BaseTexEditor]]]], 
                     getFixedFile: Optional[Callable[[str, str], str]] = None) -> IniTexModel:
        """
        Creates the data needed for fixing a particular ``[Resource.*]`` `section`_ for some .dds texture file in the .ini file

        Parameters
        ----------
        ifTemplate: :class:`IfTemplate`
            The particular `section`_ to extract data

        toFix: Set[:class:`str`]
            The names of the mods to fix 

        texEditors: Union[:class:`BaseTexEditor`, Dict[:class:`int`, Dict[:class:`str`, List[:class:`BaseTexEditor`]]]]
            The texture editors for editting the found .dds files :raw-html:`<br />` :raw-html:`<br />`

            * If this argument is of type :class:`BaseTexEditor`, then all .dds files encountered within the parsed `section`_ will use the same texture editor
            * If this argument is a dictionary, then the structure of the dictionary is follows the same structure as :attr:`IniTexModel.texEdits`

        getFixedFile: Optional[Callable[[:class:`str`, :class:`str`], :class:`str`]]
            The function for transforming the file path of a found .dds file into a new file path to the fixed .dds file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use :meth:`IniFile.getFixedBlendFile` :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are:

                # The path to the original file
                # The type of mod to fix to

            **Default**: ``None``

        Returns
        -------
        :class:`IniTexModel`
            The data for fixing the particular texture
        """

        texEdits = {}
        if (isinstance(texEditors, dict)):
            texEdits = texEditors

        elif (isinstance(texEditors, BaseTexEditor)):
            partIndex = 0
            for part in ifTemplate:
                if (isinstance(part, IfPredPart)):
                    partIndex += 1
                    continue

                currentOrigResPaths = []
                try:
                    currentOrigResPaths = part[IniKeywords.Filename.value]
                except KeyError:
                    partIndex += 1
                    continue

                for modName in toFix:
                    currentEditors = list(map(lambda origBlendFile: texEditors, currentOrigResPaths))

                    try:
                        texEdits[partIndex]
                    except KeyError:
                        texEdits[partIndex] = {}

                    texEdits[partIndex][modName] = currentEditors

        return self.makeResourceModel(ifTemplate, toFix, getFixedFile, iniResourceModelCls = IniTexModel, iniResModelArgs = [texEdits])

    def _getSubCommands(self, ifTemplate: IfTemplate, currentSubCommands: Set[str], subCommands: Set[str], subCommandLst: List[str]):
        for partIndex in ifTemplate.calledSubCommands:
            partSubCommands = ifTemplate.calledSubCommands[partIndex]

            for subCommandData in partSubCommands:
                subCommand = subCommandData[1]
                if (subCommand not in subCommands):
                    currentSubCommands.add(subCommand)
                    subCommands.add(subCommand)
                    subCommandLst.append(subCommand)

    def _getCommandIfTemplate(self, sectionName: str, raiseException: bool = True) -> Optional[IfTemplate]:
        """
        Retrieves the :class:`IfTemplate` for a certain `section`_ from `IniFile._sectionIfTemplate`

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_

        raiseException: :class:`bool`
            Whether to raise an exception when the section's :class:`IfTemplate` is not found

        Raises
        ------
        :class:`KeyError`
            If the :class:`IfTemplate` for the `section`_ is not found and ``raiseException`` is set to `True`

        Returns
        -------
        Optional[:class:`IfTemplate`]
            The corresponding :class:`IfTemplate` for the `section`_
        """
        try:
            ifTemplate = self.sectionIfTemplates[sectionName]
        except Exception as e:
            if (raiseException):
                raise KeyError(f"The section by the name '{sectionName}' does not exist") from e
            else:
                return None
        else:
            return ifTemplate

    @classmethod
    def getResources(cls, commandsGraph: IniSectionGraph, isIfTemplateResource: Callable[[IfContentPart], Any],
                     getIfTemplateResource: Callable[[IfContentPart], str], addResource: Callable[[Any, IfContentPart], Any]):
        """
        Retrieves all the referenced resources that were called by `sections`_ related to the ``[TextureOverride.*Blend.*]`` `sections`_

        Parameters
        ----------
        resources: Set[:class:`str`]
            The result for all the resource `sections`_ that were referenced

        commandsGraph: :class:`IniSectionGraph`
            The subgraph for all the `sections`_ related to the resource

        isIfTemplateResource: Callable[[:class:`IfContentPart`], :class:`bool`]
            Checks whether a part in the :class:`IfTemplate` of a `section`_ contains the key that reference the target resource

        getIfTemplateResource: Callable[[:class:`IfContentPart`], Any]
            Function to retrieve the target resource from a part in the :class:`IfTemplate` of a `section`_

        addResource: Callable[[Any, :class:`IfContentPart`], Any]
            Function to add in the result of the found resource `section`_

            :raw-html:`<br />`
            The parameter order for the function is:

            #. the retrieved resource `section`_
            #. the part in the :class:`IfTemplate` where the resource is found
        """

        sections = commandsGraph.sections
        for sectionName in sections:
            ifTemplate = sections[sectionName]

            for part in ifTemplate:
                if (isinstance(part, IfPredPart)):
                    continue

                if (isIfTemplateResource(part)):
                    resource = getIfTemplateResource(part)
                    addResource(resource, part)

    def _getCommands(self, sectionName: str, subCommands: Set[str], subCommandLst: List[str]):
        """
        Low level function for retrieving all the commands/`sections`_ that are called from a certain `section`_ in the .ini file

        Parameters
        ----------
        sectionName: :class:`str`
            The name of the `section`_ we are starting from

        subCommands: Set[:class:`str`]
            The result for all of the `sections`_ that were called

        subCommandLst: List[:class:`str`]
            The result for all of the `sections`_ that were called while maintaining the order
            the `sections`_ are called in the call stack

        Raises
        ------
        :class:`KeyError`
            If the :class:`IfTemplate` is not found for some `section`_
        """

        currentSubCommands = set()
        ifTemplate = self._getCommandIfTemplate(sectionName)

        # add in the current command if it has not been added yet
        if (sectionName not in subCommands):
            subCommands.add(sectionName)
            subCommandLst.append(sectionName)

        # get all the unvisited subcommand sections to visit
        self._getSubCommands(ifTemplate, currentSubCommands, subCommands, subCommandLst)

        # visit the children subcommands that have not been visited yet
        for sectionName in currentSubCommands:
            self._getCommands(sectionName, subCommands, subCommandLst)


    # getTargetHashAndIndexSections(blendCommandNames): Retrieves the sections with target hashes and indices
    def getTargetHashAndIndexSections(self, blendCommandNames: Set[str]) -> Set[IfTemplate]:
        if (self._type is None and self.defaultModType is None):
            return set()
        
        type = self._type
        if (self._type is None):
            type = self.defaultModType

        result = {}
        hashes = set(type.hashes.fromAssets)
        indices = set(type.indices.fromAssets)
        
        # get the sections with the hashes/indices
        for sectionName in self.sectionIfTemplates:
            ifTemplate = self.sectionIfTemplates[sectionName]
            if (sectionName in blendCommandNames):
                continue

            if (hashes.intersection(ifTemplate.hashes) or indices.intersection(ifTemplate.indices)):
                result[sectionName] = ifTemplate

        return result
    
    def _getParser(self) -> Optional[BaseIniParser]:
        """
        Retrieves the parser for parsing the .ini file

        Returns
        -------
        Optional[:class:`BaseIniParser`]
            The resultant parser
        """

        availableType = self.availableType
        if (availableType is not None and self._iniParser is None):
            self._iniParser = availableType.iniParseBuilder.build(self)
        
        return self._iniParser


    # parse(): Parses the merged.ini file for any info needing to keep track of
    def parse(self):
        """
        Parses the .ini file

        Raises
        ------
        :class:`KeyError`
            If a certain resource `section`_ is not found :raw-html:`<br />` :raw-html:`<br />`
            
            (either the name of the `section`_ is not found in the .ini file or the `section`_ was skipped due to some error when parsing the `section`_)
        """
        self.remapBlendModels.clear()
        self.texAddModels.clear()
        self.texEditModels.clear()

        self.getIfTemplates(flush = True)
        if (self.defaultModType is not None and self._textureOverrideBlendSectionName is not None and self._textureOverrideBlendRoot is None):
            self._textureOverrideBlendRoot = self._textureOverrideBlendSectionName

        parser = self._getParser()
        try:
            self.sectionIfTemplates[self._textureOverrideBlendRoot]
        except KeyError:
            if (self._iniParser is not None):
                self._iniParser.clear()
            return

        if (parser is not None):
            parser.clear()
        else:
            return

        parser.parse()

    # _fix(keepBackup, fixOnly, update, withBoilerPlate, withSrc): Internal function to fix the .ini file
    def _fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False, withBoilerPlate: bool = True, withSrc: bool = True) -> str:
        fix = ""
        fix += self._getFixStr(fix = fix, withBoilerPlate = withBoilerPlate)

        if (withBoilerPlate):
            fix = f"\n\n{fix}"
        
        if (not withSrc):
            self._isFixed = True
            return fix

        fix = self.injectAddition(fix, beforeOriginal = False, keepBackup = keepBackup, fixOnly = fixOnly, update = update)
        self._isFixed = True
        return fix

    def fix(self, keepBackup: bool = True, fixOnly: bool = False, update: bool = False) -> Union[str, List[str]]:
        """
        Fixes the .ini file

        Parameters
        ----------
        keepBackup: :class:`bool`
            Whether we want to make a backup copy of the .ini file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: `True`

        fixOnly: :class:`bool`
            Whether we are only fixing the .ini file without removing any previous changes :raw-html:`<br />` :raw-html:`<br />`

            **Default**: `False`

        update: :class:`bool`
            Whether to also update the source text of this classs with the fix :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        Union[:class:`str`, List[:class:`str`]]
            The new content of the .ini file which includes the fix and the new content of any other newly created .ini files related to fixing the particular .ini file
        """

        fixer = self._getFixer()
        availableType = self.availableType

        if (availableType is None):
            raise NoModType()
        elif (fixer is None):
            return

        return fixer.fix(keepBackup = keepBackup, fixOnly = fixOnly, update = update)


class FileStats():
    """
    Keeps track of different types of files encountered by the program

    Attributes
    ----------
    fixed: Set[:class:`str`]
        The paths to the fixed files

    skipped: Dict[:class:`str`, :class:`Exception`]
        The exceptions to files paths that were skipped due to errors

    skippedByMods: DefaultDict[:class:`str`, Dict[:class:`str`, :class:`Exception`]]
        The exceptions to file paths that were skipped due to errors, grouped for each mod folder paths :raw-html:`<br />` :raw-html:`<br />`

        * The outer keys are the names to the mod folders
        * The inner keys are the names of the file paths
        * The inner values are the errors encountered

    removed: Set[:class:`str`]
        The file paths for files that got removed

    undoed: Set[:class:`str`]
        The file paths for files that got undoed to a previous state before the software was ran

    visitedAtRemoval: Set[:class:`str`]
        The file paths for files that got visited when attempting to remove those files
    """

    def __init__(self):
        self.fixed: Set[str] = set()
        self.skipped: Dict[str, Exception] = {}
        self.skippedByMods: DefaultDict[str, Dict[str, Exception]] = defaultdict(lambda: {})
        self.removed: Set[str] = set()
        self.undoed: Set[str] = set()
        self.visitedAtRemoval: Set[str] = set()

    def clear(self):
        """
        Clears out all saved data about the files
        """

        self.fixed.clear()
        self.skipped.clear()
        self.skippedByMods.clear()
        self.removed.clear()
        self.undoed.clear()
        self.visitedAtRemoval.clear()

    def updateFixed(self, newFixed: Set[str]):
        """
        Adds in new fixed file paths

        Parameters
        ----------
        newFixed: Set[:class:`str`]
            The newly added file paths that got fixed      
        """

        self.fixed.update(newFixed)

    def addFixed(self, filePath: str):
        """
        Adds a new file path to the paths of fixed files

        Parameters
        ----------
        filePath: :class:`str`
            the new file path to a fixed file
        """
        
        self.fixed.add(filePath)

    def updateSkipped(self, newSkipped: Dict[str, Exception], modFolder: Optional[str] = None):
        """
        Adds in new file paths that got skipped due to errors

        Parameters
        ----------
        newSkipped: Dict[:class:`str`, :class:`Exception`]
            The newly skipped file paths due to errors within a particular mod folder

        modFolder: Optional[:class:`str`]
            The folder where the files got skipped. If this argument is ``None``, will read the folder from
            the provided file pahts in `newSkipped`
        """

        if (modFolder is not None): 
            DictTools.update(self.skipped, newSkipped)
            if (newSkipped):
                DictTools.update(self.skippedByMods[modFolder], newSkipped)
            return
        
        for skippedFile in newSkipped:
            self.addSkipped(skippedFile, newSkipped[skippedFile], modFolder = modFolder)

    def addSkipped(self, filePath: str, error: Exception, modFolder: Optional[str] = None):
        """
        Adds a new file path to the paths of skipped files

        Parameters
        ----------
        filePath: :class:`str`
            the new file path that got skipped

        error: :class:`Exception`
            The exception that caused the file to be skipped

        modFolder: Optional[:class:`str`]
            The mod folder that contains the file path. If this argument is ``None``, will read the folder from
            the provided argument in `filePath` :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (modFolder is None):
            modFolder = os.path.dirname(filePath)
        
        self.skipped[filePath] = error
        self.skippedByMods[modFolder][filePath] = error

    def updateRemoved(self, newRemoved: Set[str]):
        """
        Adds in new file paths that got removed

        Parameters
        ----------
        newRemoved: Set[:class:`str`]
            The newly added file paths that got removed
        """

        self.removed.update(newRemoved)

    def addRemoved(self, filePath: str):
        """
        Adds in a new file path that got removed

        Parameters
        ----------
        filePath: :class:`str`
            The file path that got removed
        """

        self.removed.add(filePath)

    def updateUndoed(self, newUndoed: Set[str]):
        """
        Adds in new file paths that got contents undoed to a previous state before the software was ran

        Parameters
        ----------
        newRemoved: Set[:class:`str`]
            The newly added file paths that got contents undoed to a previous state before the software was ran
        """

        self.undoed.update(newUndoed)

    def addUndoed(self, filePath: str):
        """
        Adds in a new file path that got undoeds

        Parameters
        ----------
        filePath: :class:`str`
            The file path that got undoed
        """

        self.undoed.add(filePath)

    def updateVisitedAtRemoval(self, newVisitedAtRemoval: Set[str]):
        """
        Adds in new file paths that got visited when the software attempts to remove those files

        Parameters
        ----------
        newVisitedAtRemoved: Set[:class:`str`]
            The newly added file paths that got visited when the software attempts to remove those files
        """

        self.visitedAtRemoval.update(newVisitedAtRemoval)

    def addVisitedAtRemoval(self, filePath: str):
        """
        Adds in a new file path that got visited when the software attempts to remove the file

        Parameters
        ----------
        filePath: :class:`str`
            The file path that got visited when the software attempts to remove the file
        """

        self.visitedAtRemoval.add(filePath)

    def update(self, modFolder: Optional[str] = None, newFixed: Optional[Set[str]] = None, 
               newSkipped: Optional[Dict[str, Exception]] = None, newRemoved: Optional[Set[str]] = None, 
               newUndoed: Optional[Set[str]] = None, newVisitedAtRemoval: Optional[Set[str]] = None):
        """
        Updates the overall file paths in this class

        .. note::
            See :meth:`FileStats.updateFixed`, :meth:`FileStats.updateSkipped` and :meth:`FileStats.updateRemoved` for more details

        Parameters
        ----------
        modFolder: Optional[:class:`str`]
            The folder where the files got skipped :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newFixed: Optional[Set[:class:`str`]]
            The newly added file paths that got fixed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newSkipped: Optional[Dict[:class:`str`, :class:`Exception`]]
            The newly skipped file paths due to errors within a particular mod folder :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newRemoved: Optional[Set[:class:`str`]]
            The newly added file paths that got removed :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        newUndoed: Optional[Set[:class:`str`]]
             The newly added file paths that got contents undoed to a previous state before the software was ran :raw-html:`<br />` :raw-html:`<br />`

             **Default**: ``None``

        newVisitedAtRemoved: Optional[Set[:class:`str`]]
            The newly added file paths that got visited when the software attempts to remove those files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """

        if (newFixed is not None):
            self.updateFixed(newFixed)

        if (newSkipped is not None):
            self.updateSkipped(newSkipped, modFolder = modFolder)

        if (newRemoved is not None):
            self.updateRemoved(newRemoved)

        if (newUndoed is not None):
            self.updateUndoed(newUndoed)

        if (newVisitedAtRemoval is not None):
            self.updateVisitedAtRemoval(newVisitedAtRemoval)


class Mod(Model):
    """
    This Class inherits from :class:`Model`

    Used for handling a mod

    .. note::
        We define **a mod** based off the following criteria:

        * A folder that contains at least 1 .ini file
        * At least 1 of the .ini files in the folder contains:

            * a section with the regex ``[TextureOverride.*Blend]`` if :attr:`RemapService.readAllInis` is set to ``True`` or the script is ran with the ``--all`` flag :raw-html:`<br />`  :raw-html:`<br />` **OR** :raw-html:`<br />` :raw-html:`<br />`
            * a section that meets the criteria of one of the mod types defined :attr:`Mod._types` by running the mod types' :meth:`ModType.isType` function

        :raw-html:`<br />`
        See :class:`ModTypes` for some predefined types of mods
        
    Parameters
    ----------
    path: Optional[:class:`str`]
        The file location to the mod folder. :raw-html:`<br />` :raw-html:`<br />`
        
        If this value is set to ``None``, then will use the current directory of where this module is loaded.
        :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    files: Optional[List[:class:`str`]]
        The direct children files to the mod folder (does not include files located in a folder within the mod folder). :raw-html:`<br />` :raw-html:`<br />`

        If this parameter is set to ``None``, then the class will search the files for you when the class initializes :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    logger: Optional[:class:`Logger`]
        The logger used to pretty print messages :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    types: Optional[Set[:class:`ModType`]]
        The types of mods this mod should be. :raw-html:`<br />` :raw-html:`<br />` 
        If this argument is empty or is ``None``, then all the .ini files in this mod will be parsed :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    remappedTypes: Optional[Set[:class:`ModType`]]
        The types of mods to the mods specified at :attr:`Mod._types` will be fixed to.

        .. note::
            For more details, see :attr:`RemapService.remappedTypes`

        **Default**: ``None``

    defaultType: Optional[:class:`ModType`]
        The type of mod to use if a mod has an unidentified type :raw-html:`<br />` :raw-html:`<br />`
        If this argument is ``None``, then will skip the mod with an identified type :raw-html:`<br />` :raw-html:`<br />` 

        **Default**: ``None``

    version: Optional[:class:`float`]
        The game version we want the fixed mod :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will fix the mod to using the latest hashes/indices.

    Attributes
    ----------
    path: Optional[:class:`str`]
        The file location to the mod folder

    version: Optional[:class:`float`]
        The game version we want the fixed mod

    _files: List[:class:`str`]
        The direct children files to the mod folder (does not include files located in a folder within the mod folder).

    _types: Set[:class:`ModType`]
        The types of mods this mod should be

    _remappedType: Set[:class:`str`]
        The types of mods to the mods specified at :attr:`Mod.types` will be fixed to.

        .. note::
            For more details, see :attr:`RemapService.remappedTypes`

    _defaultType: Optional[:class:`ModType`]
        The type of mod to use if a mod has an unidentified type

    logger: Optional[:class:`Logger`]
        The logger used to pretty print messages

    inis: Dict[:class:`str`, :class:`IniFile`]
        The .ini files found for the mod :raw-html:`<br />` :raw-html:`<br />`

        The keys are the file paths to the .ini file

    remapBlend: List[:class:`str`]
        The RemapBlend.buf files found for the mod

    backupInis: List[:class:`str`]
        The DISABLED_RemapBackup.txt files found for the mod

    remapCopies: List[:class:`str`]
        The *remapFix*.ini files found for the mod

    remapTextures: List[:class:`str`]
        The *remapFix*.dds files found for the mod
    """
    def __init__(self, path: Optional[str] = None, files: Optional[List[str]] = None, logger: Optional[Logger] = None, types: Optional[Set[ModType]] = None, 
                 defaultType: Optional[ModType] = None, version: Optional[float] = None, remappedTypes: Optional[Set[str]] = None):
        super().__init__(logger = logger)
        self.path = FileService.getPath(path)
        self.version = version
        self._files = files

        if (types is None):
            types = set()
        if (remappedTypes is None):
            remappedTypes = set()

        self._types = types
        self._remappedTypes = remappedTypes
        self._defaultType = defaultType

        self.inis = []
        self.remapBlend = []
        self.backupInis = []
        self._setupFiles()

    @property
    def files(self):
        """
        The direct children files to the mod folder (does not include files located in a folder within the mod folder).

        :getter: Returns the files to the mod
        :setter: Sets up the files for the mod
        :type: Optional[List[:class:`str`]]
        """

        return self._files

    @files.setter
    def files(self, newFiles: Optional[List[str]] = None):
        self._files = newFiles
        self._setupFiles()

    def _setupFiles(self):
        """
        Searches the direct children files to the mod folder if :attr:`Mod.files` is set to ``None``        
        """

        if (self._files is None):
            self._files = FileService.getFiles(path = self.path)

        self.inis, self.remapBlend, self.backupInis, self.remapCopies, self.remapTextures = self.getOptionalFiles()

        iniPaths = self.inis
        self.inis = {}
        for iniPath in iniPaths:
            iniFile = IniFile(iniPath, logger = self.logger, modTypes = self._types, defaultModType = self._defaultType, version = self.version, modsToFix = self._remappedTypes)
            self.inis[iniFile.file] = iniFile

    @classmethod
    def isIni(cls, file: str) -> bool:
        """
        Determines whether the file is a .ini file which is the file used to control how a mod behaves

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a .ini file
        """

        return file.endswith(FileExt.Ini.value)
    
    @classmethod
    def isSrcIni(cls, file: str) -> bool:
        """
        Determines whether the file is a .ini file that is not created by this fix

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a .ini file not created by this fix
        """

        fileBaseName = os.path.basename(file)
        return (cls.isIni(file) and fileBaseName.find(FileSuffixes.RemapFixCopy.value) == -1)
    
    @classmethod
    def isRemapBlend(cls, file: str) -> bool:
        """
        Determines whether the file is a RemapBlend.buf file which is the fixed Blend.buf file created by this fix

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a RemapBlend.buf file
        """

        baseName = os.path.basename(file)
        if (not baseName.endswith(FileExt.Buf.value)):
            return False

        baseName = baseName.rsplit(".", 1)[0]
        baseNameParts = baseName.rsplit("RemapBlend", 1)

        return (len(baseNameParts) > 1)
    
    @classmethod
    def isBlend(cls, file: str) -> bool:
        """
        Determines whether the file is a Blend.buf file which is the original blend file provided in the mod

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a Blend.buf file
        """

        return bool(file.endswith(FileTypes.Blend.value) and not cls.isRemapBlend(file))
   
    @classmethod
    def isBackupIni(cls, file: str) -> bool:
        """
        Determines whether the file is a DISABLED_RemapBackup.txt file that is used to make
        backup copies of .ini files

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a DISABLED_RemapBackup.txt file
        """

        fileBaseName = os.path.basename(file)
        return (fileBaseName.startswith(FilePrefixes.BackupFilePrefix.value) or fileBaseName.startswith(FilePrefixes.OldBackupFilePrefix.value)) and file.endswith(FileExt.Txt.value)
    
    @classmethod
    def isRemapCopyIni(cls, file: str) -> bool:
        """
        Determines whether the file is *RemapFix*.ini file which are .ini files generated by this fix to remap specific type of mods :raw-html:`<br />` :raw-html:`<br />`

        *eg. mods such as Keqing or Jean that are fixed by :class:`GIMIObjMergeFixer` *

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a *RemapFix*.ini file
        """

        fileBaseName = os.path.basename(file)
        return (cls.isIni(file) and fileBaseName.rfind(FileSuffixes.RemapFixCopy.value) > -1)
    
    @classmethod
    def isRemapTexture(cls, file: str) -> bool:
        """
        Determines whether the file is a *RemapTex*.dds file which are texture .dds files generated by this fix to edit a particular texture file for some specific type of mods :raw-html:`<br />` :raw-html:`<br />`

        *eg. mods such as Kirara or Nilou that are fixed by :class:`GIMIRegEditFixer` *

        Parameters
        ----------
        file: :class:`str`
            The file path to check

        Returns
        -------
        :class:`bool`
            Whether the passed in file is a *RemapTex*.dds file
        """

        return bool(file.endswith(FileTypes.RemapTexture.value)) 

    def getOptionalFiles(self) -> List[Optional[str]]:
        """
        Retrieves a list of each type of files that are not mandatory for the mod

        Returns
        -------
        [ List[:class:`str`], List[:class:`str`], List[:class:`str`]]
            The resultant files found for the following file categories (listed in the same order as the return type):

            #. .ini files not created by this fix
            #. .RemapBlend.buf files
            #. DISABLED_RemapBackup.txt files
            #. RemapFix.ini files

            .. note::
                See :meth:`Mod.isIni`, :meth:`Mod.isRemapBlend`, :meth:`Mod.isBackupIni`, :meth:`Mod.isRemapCopyIni` for the specifics of each type of file
        """

        SingleFileFilters = {}
        MultiFileFilters = [self.isSrcIni, self.isRemapBlend, self.isBackupIni, self.isRemapCopyIni, self.isRemapTexture]

        singleFiles = []
        if (SingleFileFilters):
            singleFiles = FileService.getSingleFiles(path = self.path, filters = SingleFileFilters, files = self._files, optional = True)
        multiFiles = FileService.getFiles(path = self.path, filters = MultiFileFilters, files = self._files)

        result = singleFiles
        if (not isinstance(result, list)):
            result = [result]

        result += multiFiles
        return result
    
    # _removeFileType(fileTypeAtt, logFunc): Removes all the files for a particular file type for the mod
    def _removeFileType(self, fileTypeAtt: str, logFunc: Callable[[str], str]):
        files = getattr(self, fileTypeAtt)

        for file in files:
            logTxt = logFunc(file)
            self.print("log", logTxt)
            try:
                os.remove(file)
            except FileNotFoundError:
                pass
    
    def removeBackupInis(self):
        """
        Removes all DISABLED_RemapBackup.txt contained in the mod
        """

        self._removeFileType("backupInis", lambda file: f"Removing the backup ini, {os.path.basename(file)}")

    def removeRemapCopies(self):
        """
        Removes all RemapFix.ini files contained in the mod
        """

        self._removeFileType("remapCopies", lambda file: f"Removing the ini remap copy, {os.path.basename(file)}")

    def _removeIniResources(self, ini: IniFile, result: Set[str], resourceName: str, resourceStats: FileStats, getIniResources: Callable[[IniFile], List[IniResourceModel]]) -> bool:
        """
        Removes a particular type of resource from a .ini file

        Parameters
        ----------
        ini: :class:`IniFile`
            The particular .ini file to be processed

        result: Set[:class:`str`]
            The resultant paths to the resources that got removed

        resourceName: :class:`str`
            The name of the type of resource

        resourceStats: :class:`FileStats`
            The associated statistical data for the resource type

        getIniResource: Callable[[:class:`IniFile`], List[:class:`IniResourceModel`]]
            The function to retrieve the data related to the resource from the .ini file

        Returns
        -------
        :class:`bool`
            Whether there was a file that was attempted to be removed
        """

        iniResources = getIniResources(ini)
        hasRemovedResource = False

        for texModel in iniResources:
            for fixedPath, fixedFullPath, origPath, origFullPath in texModel:
                if (fixedFullPath not in resourceStats.fixed and fixedFullPath not in resourceStats.visitedAtRemoval):
                    try:
                        os.remove(fixedFullPath)
                    except FileNotFoundError as e:
                        self.print("log", f"No Previous {resourceName} found at {fixedFullPath}")
                    else:
                        self.print("log", f"Removing previous {resourceName} at {fixedFullPath}")
                        result.add(fixedFullPath)
                    
                    resourceStats.addVisitedAtRemoval(fixedFullPath)

                    if (not hasRemovedResource):
                        hasRemovedResource = True

        return hasRemovedResource

    def removeFix(self, blendStats: FileStats, iniStats: FileStats, texStats:FileStats, keepBackups: bool = True, fixOnly: bool = False, readAllInis: bool = False) -> List[Set[str]]:
        """
        Removes any previous changes done by this module's fix

        Parameters
        ----------
        blendStats: :class:`FileStats`
            The data about Blend.buf files

        iniStats: :class:`FileStats`
            The data about .ini files

        texStats: :class:`FileStats`
            The data about .dds files

        keepBackups: :class:`bool`
            Whether to create or keep DISABLED_RemapBackup.txt files in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        fixOnly: :class:`bool`
            Whether to not undo any changes created in the .ini files :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        readAllInis: :class:`bool`
            Whether to remove the .ini fix from all the .ini files encountered :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``False``

        Returns
        -------
        [Set[:class:`str`], Set[:class:`str`], Set[:class:`str`]]
            The removed files that have their fix removed, where the types of files for the return value is based on the list below:

            #. .ini files with their fix removed
            #. RemapBlend.buf files that got deleted
            #. RemapTex.dds files that got deleted
        """

        removedRemapBlends = set()
        removedTextures = set()
        undoedInis = set()

        for iniPath in self.inis:
            ini = self.inis[iniPath]

            remapBlendsRemoved = False
            texRemoved = False
            iniFilesUndoed = False
            iniFullPath = None
            iniHasErrors = False
            if (ini.file is not None):
                iniFullPath = FileService.absPathOfRelPath(ini.file, self.path)

            # parse the .ini file even if we are only undoing fixes for the case where some resource file (Blend.buf, .dds, etc...)
            #   forms a bridge with some disconnected folder subtree of a mod
            # Also, we only want to remove the resource files connected to particular types of .ini files, 
            #   instead of all the resource files in the folder
            if (iniFullPath is None or (iniFullPath not in iniStats.fixed and iniFullPath not in iniStats.skipped)):
                try:
                    ini.parse()
                except Exception as e:
                    iniStats.addSkipped(iniFullPath, e, modFolder = self.path)
                    iniHasErrors = True
                    self.print("handleException", e)

            # remove the fix from the .ini files
            if (not iniHasErrors and iniFullPath is not None and iniFullPath not in iniStats.fixed and iniFullPath not in iniStats.skipped and (ini.isModIni or readAllInis)):
                try:
                    ini.removeFix(keepBackups = keepBackups, fixOnly = fixOnly, parse = True)
                except Exception as e:
                    iniStats.addSkipped(iniFullPath, e, modFolder = self.path)
                    iniHasErrors = True
                    self.print("handleException", e)
                    continue

                undoedInis.add(iniFullPath)

                if (not iniFilesUndoed):
                    iniFilesUndoed = True

            if (iniFilesUndoed):
                self.print("space")

            # remove only the remap blends that have not been recently created
            remapBlendsRemoved = self._removeIniResources(ini, removedRemapBlends, FileTypes.RemapBlend.value, blendStats, lambda iniFile: iniFile.remapBlendModels.values())
            if (remapBlendsRemoved):
                self.print("space")

            # remove only the remap texture files that have not been recently created
            texRemoved = self._removeIniResources(ini, removedTextures, FileTypes.RemapTexture.value, texStats, lambda iniFile: iniFile.getTexAddModels())
            if (texRemoved):
                self.print("space")

        return [undoedInis, removedRemapBlends, removedTextures]

    @classmethod
    def blendCorrection(cls, blendFile: Union[str, bytes], modType: ModType, modToFix: str, 
                        fixedBlendFile: Optional[str] = None, version: Optional[float] = None) -> Union[Optional[str], bytearray]:
        """
        Fixes a Blend.buf file

        See :meth:`BlendFile.correct` for more info

        Parameters
        ----------
        blendFile: Union[:class:`str`, :class:`bytes`]
            The file path to the Blend.buf file to fix

        modType: :class:`ModType`
            The type of mod to fix from

        modToFix: :class:`str`
            The name of the mod to fix to

        fixedBlendFile: Optional[:class:`str`]
            The file path for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        version: Optional[float]
            The game version to fix to :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will fix to the latest game version :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        Raises
        ------
        :class:`BlendFileNotRecognized`
            If the original Blend.buf file provided by the parameter ``blendFile`` cannot be read

        :class:`BadBlendData`
            If the bytes passed into this function do not correspond to the format defined for a Blend.buf file

        Returns
        -------
        Union[Optional[:class:`str`], :class:`bytearray`]
            If the argument ``fixedBlendFile`` is ``None``, then will return an array of bytes for the fixed Blend.buf file :raw-html:`<br />` :raw-html:`<br />`
            Otherwise will return the filename to the fixed RemapBlend.buf file if the provided Blend.buf file got corrected
        """

        blend = BlendFile(blendFile)
        vgRemap = modType.getVGRemap(modToFix, version = version)
        return blend.correct(vgRemap = vgRemap, fixedBlendFile = fixedBlendFile)
    
    @classmethod
    def _texCorrection(cls, fixedTexFile: str, modToFix: str, model: IniTexModel, partInd: int, pathInd: int, texFile: Optional[str] = None) -> str:
        texEditor = model.texEdits[partInd][modToFix][pathInd]
        return cls.texCorrection(fixedTexFile, texEditor, texFile = texFile)
    
    @classmethod
    def texCorrection(cls, fixedTexFile: str, texEditor: BaseTexEditor, texFile: Optional[str] = None) -> Optional[str]:
        """
        Fixes a .dds file

        Parameters
        ----------
        fixedTexFile: :class:`str`
            The name of the file path to the fixed RemapTex.dds file

        texEditor: :class:`BaseTexEditor`
            The texture editor to change the texture file

        texFile Optional[:class:`str`]
            The file path to the original texture .dds file :raw-html:`<br />` :raw-html:`<br />`

            If this value is ``None``, then will use 'fixedTexFile' as the original file path to the texture .dds file 
            (usually this case for creating a brand new .dds file by also passing in object of type :class:`TexCreator` into the 'texEditor' argument) :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``
        """
        if (texFile is None):
            texFile = fixedTexFile

        tex = TextureFile(texFile)
        texEditor.fix(tex, fixedTexFile)
        return fixedTexFile

    def correctResource(self, resourceStats: FileStats, getResourceModels: Callable[[IniFile], List[IniResourceModel]], correctFile: Callable[[str, str, ModType, str, int, IniResourceModel], str], 
                        iniPaths: Optional[List[str]] = None, fileTypeName: str = "", needsSrcFile: bool = True, fixOnly: bool = False) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the files for a particular type of resource referenced by the mod

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.parse` function

        Parameters
        ----------
        resourceStats: :class:`FileStats`
            The stats to keep track of whether the particular resource has been fixed or skipped

        getResourceModels: Callable[[:class:`IniFile`], List[:class:`IniResourceModel`]]
            Function to retrieve all of the needed :class:`IniResourceModel` from some .ini file

        correctFile: Callable[[:class:`str`, :class:`str`, :class:`ModType`, :class:`str`, :class:`int`, :class:`IniResourceModel`], :class:`str`]
            Function to fix up the resource file :raw-html:`<br />` :raw-html:`<br />`

            The parameters for the function are as follows:

            #. The full file path to the original resource
            #. The fixed file path to the resource
            #. The type of mod being fixed within the .ini file
            #. The name of the mod to fix to
            #. The index of the part within the :class:`IfTemplate`
            #. The index of the path within the particular part of the :class:`IfTemplate`
            #. The version of the game to fix to
            #. The current :class:`IniResourceModel` being processed

            :raw-html:`<br />` :raw-html:`<br />`

            The function returns a :class:`str` with the fixed file path to the resource

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their resources corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fileTypeName: :class:`str`
            The name of the file resource

        fixOnly: :class:`bool`
            Whether to not correct some Blend.buf file if its corresponding RemapBlend.buf already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the RemapBlend.buf files that were fixed
            #. The exceptions encountered when trying to fix some RemapBlend.buf files :raw-html:`<br />` :raw-html:`<br />`

            The keys are absolute filepath to the RemapBlend.buf file and the values are the exception encountered
        """

        currentBlendsSkipped = {}
        currentBlendsFixed = set()
        fileTypeName = "file" if (fileTypeName == "") else f"{fileTypeName} file"

        if (iniPaths is None):
            iniPaths = list(self.inis.keys())
        else:
            iniPaths = ListTools.getDistinct(iniPaths, keepOrder = True)

        for iniPath in iniPaths:
            ini = None
            try:
                ini = self.inis[iniPath]
            except KeyError:
                continue

            if (ini is None):
                continue
            
            modType = ini.availableType
            resourceModels = getResourceModels(ini)
            for model in resourceModels:
                for partIndex, partFullPaths in model.fullPaths.items():
                    for modName, fixedFullPaths in partFullPaths.items():

                        fixedFullPathsLen = len(fixedFullPaths)
                        for i in range(fixedFullPathsLen):
                            fixedFullPath = fixedFullPaths[i]
                            origFullPath = None
                            if (needsSrcFile):
                                try:
                                    origFullPath = model.origFullPaths[partIndex][i]
                                except KeyError:
                                    self.print("log", f"Missing Original {fileTypeName} for the RemapBlend file at {fixedFullPath}")
                                    if (fixedFullPath not in resourceStats.skipped):
                                        error = RemapMissingBlendFile(fixedFullPath)
                                        currentBlendsSkipped[fixedFullPath] = error
                                        resourceStats.addSkipped(fixedFullPath, error, modFolder = self.path)
                                    break

                            # check if the file was already encountered and did not need to be fixed
                            if ((origFullPath is not None and origFullPath in resourceStats.fixed) or modType is None):
                                break
                            
                            # check if the file that did not need to be fixed already had encountered an error
                            if (origFullPath is not None and origFullPath in resourceStats.skipped):
                                self.print("log", f"{fileTypeName} has already previously encountered an error at {origFullPath}")
                                break
                            
                            # check if the file has been fixed
                            if (fixedFullPath in resourceStats.fixed):
                                self.print("log", f"{fileTypeName} has already been corrected at {fixedFullPath}")
                                continue

                            # check if the file already had encountered an error
                            if (fixedFullPath in resourceStats.skipped):
                                self.print("log", f"{fileTypeName} has already previously encountered an error at {fixedFullPath}")
                                continue

                            # check if the fixed file already exists and we only want to fix mods without removing their previous fixes
                            if (fixOnly and os.path.isfile(fixedFullPath)):
                                self.print("log", f"{fileTypeName} was previously fixed at {fixedFullPath}")
                                continue
                            
                            # fix the file resource
                            correctedResourcePath = None
                            try:
                                correctedResourcePath = correctFile(origFullPath, fixedFullPath, modType, modName, partIndex, i, self.version, model)
                            except Exception as e:
                                currentBlendsSkipped[fixedFullPath] = e
                                resourceStats.addSkipped(fixedFullPath, e, modFolder = self.path)
                                self.print("handleException", e)
                            else:
                                pathToAdd = ""
                                if (correctedResourcePath is None):
                                    self.print("log", f"{fileTypeName} does not need to be corrected at {origFullPath}")
                                    pathToAdd = origFullPath
                                else:
                                    self.print("log", f'{fileTypeName} correction done at {fixedFullPath}')
                                    pathToAdd = fixedFullPath

                                currentBlendsFixed.add(pathToAdd)
                                resourceStats.addFixed(pathToAdd)

        return [currentBlendsFixed, currentBlendsSkipped]
    
    def correctTex(self, texAddStats: FileStats, texEditStats: FileStats, iniPaths: Optional[List[str]] = None, fixOnly: bool = False) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the texture .dds files reference by the mods

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.fix` function

        Parameters
        ----------
        texAddStats: :class:`FileStats`
            The stats to keep track of whether the particular .dds file have been newly created or skipped

        texEditStats: :class:`FileStats`
            The stats to keep track of whether the particular .dds file has been editted or skipped

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their .dds files corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fixOnly: :class:`bool`
            Whether to not correct some .dds file if its corresponding RemapTex.dds already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`], Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the .dds files that were added
            #. The exceptions encountered when trying to created some .dds files 
            #. The absolute file paths of the .dds files that were editted
            #. The exceptions encountered when trying to edit some .dds files :raw-html:`<br />` :raw-html:`<br />`

            For the exceptions, the keys are absolute filepath to the .dds file and the values are the exception encountered        
        """

        fixedTexAdds, skippedTexAdds = self.correctResource(texAddStats, lambda iniFile: iniFile.getTexAddModels(), 
                                    lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniTexModel: self._texCorrection(fixedFullPath, modName, iniTexModel, partInd, pathInd, texFile = origFullPath),
                                    fileTypeName = "Texture", fixOnly = fixOnly, iniPaths = iniPaths)
        
        fixedTexEdits, skippedTexEdits = self.correctResource(texEditStats, lambda iniFile: iniFile.getTexEditModels(), 
                                    lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniTexModel: self._texCorrection(fixedFullPath, modName, iniTexModel, partInd, pathInd, texFile = origFullPath),
                                    fileTypeName = "Texture", fixOnly = fixOnly, iniPaths = iniPaths)
        
        return fixedTexAdds, skippedTexAdds, fixedTexEdits, skippedTexEdits
    
    def correctBlend(self, blendStats: FileStats, iniPaths: Optional[List[str]] = None, fixOnly: bool = False) -> List[Union[Set[str], Dict[str, Exception]]]:
        """
        Fixes all the Blend.buf files reference by the mod

        Requires all the .ini files in the mod to have ran their :meth:`IniFile.parse` function

        Parameters
        ----------
        blendStats: :class:`FileStats`
            The stats to keep track of whether the particular the blend.buf files have been fixed or skipped

        iniPaths: Optional[List[:class:`str`]]
            The file paths to the .ini file to have their blend.buf files corrected. If this value is ``None``, then will correct all the .ini file in the mod :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``None``

        fixOnly: :class:`bool`
            Whether to not correct some Blend.buf file if its corresponding RemapBlend.buf already exists :raw-html:`<br />` :raw-html:`<br />`

            **Default**: ``True``

        Returns
        -------
        [Set[:class:`str`], Dict[:class:`str`, :class:`Exception`]]
            #. The absolute file paths of the RemapBlend.buf files that were fixed
            #. The exceptions encountered when trying to fix some RemapBlend.buf files :raw-html:`<br />` :raw-html:`<br />`

            The keys are absolute filepath to the RemapBlend.buf file and the values are the exception encountered
        """

        return self.correctResource(blendStats, lambda iniFile: iniFile.remapBlendModels.values(), 
                                    lambda origFullPath,  fixedFullPath, modType, modName, partInd, pathInd, version, iniResourceModel: self.blendCorrection(origFullPath, modType, modName, fixedBlendFile = fixedFullPath, version = version),
                                    fileTypeName = "Blend", fixOnly = fixOnly, iniPaths = iniPaths)


class RemapService():
    """
    The overall class for remapping modss

    Parameters
    ----------
    path: Optional[:class:`str`]
        The file location of where to run the fix. :raw-html:`<br />` :raw-html:`<br />`

        If this attribute is set to ``None``, then will run the fix from wherever this class is called :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    keepBackups: :class:`bool`
        Whether to keep backup versions of any .ini files that the script fixes :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    fixOnly: :class:`bool`
        Whether to only fix the mods without removing any previous changes this fix script may have made :raw-html:`<br />` :raw-html:`<br />`

        .. warning::
            if this is set to ``True`` and :attr:`undoOnly` is also set to ``True``, then the fix will not run and will throw a :class:`ConflictingOptions` exception

        :raw-html:`<br />`

        **Default**: ``False``

    undoOnly: :class:`bool`
        Whether to only undo the fixes previously made by the fix :raw-html:`<br />` :raw-html:`<br />`

        .. warning::
            if this is set to ``True`` and :attr:`fixOnly` is also set to ``True``, then the fix will not run and will throw a :class:`ConflictingOptions` exception

        :raw-html:`<br />`

        **Default**: ``True``

    readAllInis: :class:`bool`
        Whether to read all the .ini files that the fix encounters :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    types: Optional[List[:class:`str`]]
        The names for all the types of mods to fix.  :raw-html:`<br />` :raw-html:`<br />`

        If this argument is an empty list or this argument is ``None``, then will fix all the types of mods supported by this fix :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    remappedTypes: Optional[List[:class:`str`]]
        The names for the types of mods to be remapped based from the types of mods specified at :attr:`RemapService.types`. :raw-html:`<br />` :raw-html:`<br />`

        For a mod specified at :attr:`RemapService.types`, if none of its corresponding mods to remap are specified in this attribute, then will remap the mod specified at :attr:`RemapService.types` to all its corresponding mods to remap.

        If this argument is an empty list or this argument is ``None``, then will fix the mods specified at :attr:`RemapService.types` to all of their corresponding remapped mods :raw-html:`<br />` :raw-html:`<br />`

        eg.
        if :attr:`RemapService.types` is ``["Kequeen", "jean"]`` and this attribute is ``["jeanSea"]``, then this class will perform the following remaps:
        
        * Keqing --> KeqingOpulent
        * Jean --> JeanSea

        **Note: ** Jean --> JeanCN will not be remapped for the above example :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    defaultType: Optional[:class:`str`]
        The name for the type to use if a mod has an unidentified type :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then mods with unidentified types will be skipped :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    log: Optional[:class:`str`]
        The folder location to log the run of the fix into a seperate text file :raw-html:`<br />` :raw-html:`<br />`

        If this value is ``None``, then will not log the fix :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    verbose: :class:`bool`
        Whether to print the progress for fixing mods :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``True``

    handleExceptions: :class:`bool`
        When an exception is caught, whether to silently stop running the fix :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``False``

    version: Optional[:class:`str`]
        The game version we want the fix to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version. :raw-html:`<br />` :raw-html:`<br />`

        **Default**: ``None``

    Attributes
    ----------
    _loggerBasePrefix: :class:`str`
        The prefix string for the logger used when the fix returns back to the original directory that it started to run

    logger: :class:`Logger`
        The logger used to pretty print messages

    _path: :class:`str`
        The file location of where to run the fix.

    keepBackups: :class:`bool`
        Whether to keep backup versions of any .ini files that the script fixes

    fixOnly: :class:`bool`
        Whether to only fix the mods without removing any previous changes this fix script may have made

    undoOnly: :class:`bool`
        Whether to only undo the fixes previously made by the fix

    readAllInis: :class:`bool`
        Whether to read all the .ini files that the fix encounters

    types: Set[:class:`ModType`]
        All the types of mods that will be fixed.

    remappedTypes: Set[:class:`str`]
        The names for the types of mods to be remapped based from the types of mods specified at :attr:`RemapService.types`. :raw-html:`<br />` :raw-html:`<br />`

        For a mod specified at :attr:`RemapService.types`, if none of its corresponding mods to remap are specified in this attribute, then will remap the mod specified at :attr:`RemapService.types` to all its corresponding mods to remap.

        If this argument is an empty list or this argument is ``None``, then will fix the mods specified at :attr:`RemapService.types` to all of their corresponding remapped mods :raw-html:`<br />` :raw-html:`<br />`

        eg.
        if :attr:`RemapService.types` is ``["Kequeen", "jean"]`` and this attribute is ``["jeanSea"]``, then this class will perform the following remaps:
        
        * Keqing --> KeqingOpulent
        * Jean --> JeanSea

        **Note: ** Jean --> JeanCN will not be remapped for the above example

    defaultType: Optional[:class:`ModType`]
        The type to use if a mod has an unidentified type

    verbose: :class:`bool`
        Whether to print the progress for fixing mods

    version: Optional[:class:`float`]
        The game version we want the fix to be compatible with :raw-html:`<br />` :raw-html:`<br />`

        If This value is ``None``, then will retrieve the hashes/indices of the latest version.

    handleExceptions: :class:`bool`
        When an exception is caught, whether to silently stop running the fix

    _logFile: :class:`str`
        The file path of where to generate a log .txt file

    _pathIsCWD: :class:`bool`
        Whether the filepath that the program runs from is the current directory where this module is loaded

    blendStats: :class:`FileStats`
        Stats about whether some Blend.buf files got fixed/skipped/removed

        .. note::
            * removed Blend.buf files refer to RemapBlend.buf files that were previously made by this software on a previous run

    iniStats: :class:`FileStats`
        Stats about whether some .ini files got fixed/skipped/undoed

        .. note::
            * The skipped .ini files may or may not have been previously fixed. A path to some .ini file in this attribute **DOES NOT** imply that the .ini file previously had a fix

    modStats: :class:`FileStats`
        Stats about whether a mod has been fixed/skipped

    texAddStats: :class:`FileStats`
        Stats about whether an existing texture file has been editted/removed

    texEditStats: :class:`FileStats`
        Stats about whether some brand new texture file created by this software has been created/removed
    """

    def __init__(self, path: Optional[str] = None, keepBackups: bool = True, fixOnly: bool = False, undoOnly: bool = False, 
                 readAllInis: bool = False, types: Optional[List[str]] = None, defaultType: Optional[str] = None, log: Optional[str] = None, 
                 verbose: bool = True, handleExceptions: bool = False, version: Optional[str] = None, remappedTypes: Optional[List[str]] = None):
        self.log = log
        self._loggerBasePrefix = ""
        self.logger = Logger(logTxt = log, verbose = verbose)
        self._path = path
        self.keepBackups = keepBackups
        self.fixOnly = fixOnly
        self.undoOnly = undoOnly
        self.readAllInis = readAllInis
        self.types = types
        self.remappedTypes = remappedTypes
        self.defaultType = defaultType
        self.verbose = verbose
        self.version = version
        self.handleExceptions = handleExceptions
        self._pathIsCwd = False
        self.__errorsBeforeFix = None

        # certain statistics about the fix
        self.blendStats = FileStats()
        self.iniStats = FileStats()
        self.modStats = FileStats()
        self.texEditStats = FileStats()
        self.texAddStats = FileStats()

        self._setupModPath()
        self._setupModTypes("types")
        self._setupRemappedTypes()
        self._setupDefaultModType()
        self._setupVersion()

        if (self.__errorsBeforeFix is None):
            self._printModsToFix()

    @property
    def pathIsCwd(self):
        """
        Whether the filepath that the program runs from is the current directory where this module is loaded

        :getter: Returns whether the filepath that the program runs from is the current directory of where the module is loaded
        :type: :class:`bool`
        """

        return self._pathIsCwd
    
    @property
    def path(self) -> str:
        """
        The filepath of where the fix is running from

        :getter: Returns the path of where the fix is running
        :setter: Sets the path for where the fix runs
        :type: :class:`str`
        """

        return self._path
    
    @path.setter
    def path(self, newPath: Optional[str]):
        self._path = newPath
        self._setupModPath()
        self.clear()

    @property
    def log(self) -> str:
        """
        The folder location to log the run of the fix into a seperate text file

        :getter: Returns the file path to the log
        :setter: Sets the path for the log
        :type: :class:`str`
        """

        return self._log
    
    @log.setter
    def log(self, newLog: Optional[str]):
        self._log = newLog
        self._setupLogPath()

    def clear(self, clearLog: bool = True):
        """
        Clears up all the saved data

        Paramters
        ---------
        clearLog: :class:`bool`
            Whether to also clear out any saved data in the logger
        """

        self.blendStats.clear()
        self.iniStats.clear()
        self.modStats.clear()
        self.texAddStats.clear()
        self.texEditStats.clear()

        if (clearLog):
            self.logger.clear()
    
    def _setupModPath(self):
        """
        Sets the filepath of where the fix will run from
        """

        self._pathIsCwd = False
        if (self._path is None):
            self._path = FilePathConsts.DefaultPath
            self._pathIsCwd = True
            return

        self._path = FileService.parseOSPath(self._path)
        self._path = FileService.parseOSPath(os.path.abspath(self._path))
        self._pathIsCwd = (self._path == FilePathConsts.DefaultPath)

    def _setupLogPath(self):
        """
        Sets the folder path for where the log file will be stored
        """

        if (self._log is not None):
            self._log = FileService.parseOSPath(os.path.join(self._log, FileTypes.Log.value))

    def _setupModTypes(self, attr: str):
        """
        Sets the types of mods that will be fixed / fix to

        Parameters
        ----------
        attr: :class:`str`
            The name of the attribute within this class set the mods for
        """
        attrVal = getattr(self, attr)
        if (isinstance(attrVal, set)):
            return

        modTypes = set()
        if (attrVal is None or self.readAllInis or not attrVal):
            modTypes = ModTypes.getAll()

        # search for the types of mods to fix
        else:
            for typeStr in attrVal:
                modType = ModTypes.search(typeStr)
                modTypeFound = bool(modType is not None)

                if (modTypeFound):
                    modTypes.add(modType)
                elif (self.__errorsBeforeFix is None):
                    self.__errorsBeforeFix = InvalidModType(typeStr)
                    return

        setattr(self, attr, modTypes)

    def _setupRemappedTypes(self):
        """
        Sets the names for the types of mods that will be fixed to
        """

        self._setupModTypes("remappedTypes")
        if (self.__errorsBeforeFix is not None):
            return
        
        self.remappedTypes = set(map(lambda remappedType: remappedType.name, self.remappedTypes))

    def _setupVersion(self):
        """
        Sets the game version to fix to
        """

        if (self.version is None):
            return

        try:
            self.version = float(self.version)
        except ValueError:
            if (self.__errorsBeforeFix is None):
                self.__errorsBeforeFix = ValueError("Please enter a float for the game version")

    def _setupDefaultModType(self):
        """
        Sets the default mod type to be used for an unidentified mod
        """

        if (not self.readAllInis):
            self.defaultType = None
        elif (self.defaultType is None):
            self.defaultType = ModTypes.Raiden.value
            return

        if (self.defaultType is None or isinstance(self.defaultType, ModType)):
            return

        self.defaultType = ModTypes.search(self.defaultType)

        if (self.defaultType is None and self.__errorsBeforeFix is None):
            self.__errorsBeforeFix = InvalidModType(self.defaultType)

    def _printModsToFix(self):
        """
        Prints out the types of mods that will be fixed
        """

        self.logger.includePrefix = False

        self.logger.openHeading("Types of Mods To Fix", 5)
        self.logger.space()

        if (not self.types):
            self.logger.log("All mods")
        else:
            sortedModNames = list(map(lambda modType: modType.name, self.types))
            sortedModNames.sort()

            for name in sortedModNames:
                self.logger.bulletPoint(f"{name}")
        
        self.logger.space()
        self.logger.closeHeading()
        self.logger.split() 
        self.logger.includePrefix = True
    
    # fixes an ini file in a mod
    def fixIni(self, ini: IniFile, mod: Mod) -> bool:
        """
        Fixes an individual .ini file for a particular mod

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`

        Parameters
        ----------
        ini: :class:`IniFile`
            The .ini file to fix

        mod: :class:`Mod`
            The mod being fixed

        Returns
        -------
        :class:`bool`
            Whether the particular .ini file has just been fixed
        """

        # check if the .ini is belongs to some mod
        if (ini is None or not ini.isModIni):
            return False

        if (self.undoOnly):
            return True

        fileBaseName = os.path.basename(ini.file)
        iniFullPath = FileService.absPathOfRelPath(ini.file, mod.path)

        if (iniFullPath in self.iniStats.skipped):
            self.logger.log(f"the ini file, {fileBaseName}, has alreaedy encountered an error")
            return False
        
        if (iniFullPath in self.iniStats.fixed):
            self.logger.log(f"the ini file, {fileBaseName}, is already fixed")
            return True

        # parse the .ini file
        self.logger.log(f"Parsing {fileBaseName}...")
        ini.parse()

        if (ini.isFixed):
            self.logger.log(f"the ini file, {fileBaseName}, is already fixed")
            return True

        # fix the blends
        self.logger.log(f"Fixing the {FileTypes.Blend.value} files for {fileBaseName}...")
        mod.correctBlend(self.blendStats, fixOnly = self.fixOnly, iniPaths = [ini.file])

        # writing the fixed file
        self.logger.log(f"Making the fixed ini file for {fileBaseName}")
        ini.fix(keepBackup = self.keepBackups, fixOnly = self.fixOnly)

        # fix the textures
        self.logger.log(f"Fixing the {FileTypes.Texture.value} files for {fileBaseName}...")
        mod.correctTex(self.texAddStats, self.texEditStats, fixOnly = self.fixOnly, iniPaths = [ini.file])

        return True

    # fixes a mod
    def fixMod(self, mod: Mod) -> bool:
        """
        Fixes a particular mod

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`

        Parameters
        ----------
        mod: :class:`Mod`
            The mod being fixed

        Returns
        -------
        :class:`bool`
            Whether the particular mod has just been fixed
        """

        # remove any backups
        if (not self.keepBackups):
            mod.removeBackupInis()

        for iniPath in mod.inis:
            ini = mod.inis[iniPath]
            ini.checkIsMod()

        # undo any previous fixes
        if (not self.fixOnly):
            undoedInis, removedRemapBlends, removedTextures = mod.removeFix(self.blendStats, self.iniStats, self.texAddStats, keepBackups = self.keepBackups, fixOnly = self.fixOnly, readAllInis = self.readAllInis)
            self.blendStats.updateRemoved(removedRemapBlends)
            self.iniStats.updateUndoed(undoedInis)
            self.texAddStats.updateRemoved(removedTextures)

        result = False
        firstIniException = None
        inisLen = len(mod.inis)
        iniCopiesRemoved = False

        i = 0
        for iniPath in mod.inis:
            ini = mod.inis[iniPath]
            iniFullPath = FileService.absPathOfRelPath(ini.file, mod.path)
            iniIsFixed = False

            # remove any copies of .ini files previously created by this fix
            if (not iniCopiesRemoved and ini.isModIni):
                mod.removeRemapCopies()
                iniCopiesRemoved = True

            try:
                iniIsFixed = self.fixIni(ini, mod)
            except Exception as e:
                self.logger.handleException(e)
                self.iniStats.addSkipped(iniFullPath, e)

                if (firstIniException is None):
                    firstIniException = e

            if (firstIniException is None and iniFullPath in self.iniStats.skipped):
                firstIniException = self.iniStats.skipped[iniFullPath]

            result = (result or iniIsFixed)

            if (not iniIsFixed):
                i += 1
                continue
            
            if (i < inisLen - 1):
                self.logger.space()

            self.iniStats.addFixed(iniFullPath)
            i += 1

        if (not result and firstIniException is not None):
            self.modStats.addSkipped(mod.path, firstIniException, modFolder = mod.path)

        return result
    
    def addTips(self):
        """
        Prints out any useful tips for the user to know
        """

        self.logger.includePrefix = False

        if (not self.undoOnly or self.keepBackups):
            self.logger.split()
            self.logger.openHeading("Tips", sideLen = 10)

            if (self.keepBackups):
                self.logger.bulletPoint(f'Hate deleting the "{FilePrefixes.BackupFilePrefix.value}" {FileExt.Ini.value}/{FileExt.Txt.value} files yourself after running this script? (cuz I know I do!) Run this script again (on CMD) using the {CommandOpts.DeleteBackup.value} option')

            if (not self.undoOnly):
                self.logger.bulletPoint(f"Want to undo this script's fix? Run this script again (on CMD) using the {CommandOpts.Revert.value} option")

            if (not self.readAllInis):
                self.logger.bulletPoint(f"Were your {FileTypes.Ini.value}s not read? Run this script again (on CMD) using the {CommandOpts.All.value} option")

            self.logger.space()
            self.logger.log("For more info on command options, run this script (on CMD) using the --help option")
            self.logger.closeHeading()

        self.logger.includePrefix = True


    def reportSkippedAsset(self, assetName: str, assetDict: Dict[str, Exception], warnStrFunc: Callable[[str], str]):
        """
        Prints out the exception message for why a particular .ini file or Blend.buf file has been skipped

        Parameters
        ----------
        assetName: :class:`str`
            The name for the type of asset (files, folders, mods, etc...) that was skipped

        assetDict: Dict[:class:`str`, :class:`Exception`]
            Locations of where exceptions have occured for the particular asset :raw-html:`<br />` :raw-html:`<br />`

            The keys are the absolute folder paths to where the exception occured

        wantStrFunc: Callable[[:class:`str`], :class:`str`]
            Function for how we want to print out the warning for each exception :raw-html:`<br />` :raw-html:`<br />`

            Takes in the folder location of where the exception occured as a parameter
        """

        if (assetDict):
            message = f"\nWARNING: The following {assetName} were skipped due to warnings (see log above):\n\n"
            for dir in assetDict:
                message += warnStrFunc(dir)

            self.logger.error(message)
            self.logger.space()

    def warnSkippedIniResource(self, modPath: str):
        """
        Prints out all of the resource files from the .ini files that were skipped due to exceptions

        Parameters
        ----------
        modPath: :class:`str`
            The absolute path to a particular folder
        """

        parentFolder = os.path.dirname(self._path)
        relModPath = FileService.getRelPath(modPath, parentFolder)
        modHeading = Heading(f"Mod: {relModPath}", 5)
        message = f"{modHeading.open()}\n\n"
        blendWarnings = self.blendStats.skippedByMods[modPath]
        
        for blendPath in blendWarnings:
            relBlendPath = FileService.getRelPath(blendPath, self._path)
            message += self.logger.getBulletStr(f"{relBlendPath}:\n\t{Heading(type(blendWarnings[blendPath]).__name__, 3, '-').open()}\n\t{blendWarnings[blendPath]}\n\n")
        
        message += f"{modHeading.close()}\n"
        return message

    def reportSkippedMods(self):
        """
        Prints out all of the mods that were skipped due to exceptions

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`
        """

        self.reportSkippedAsset("mods", self.modStats.skipped, lambda dir: self.logger.getBulletStr(f"{dir}:\n\t{Heading(type(self.modStats.skipped[dir]).__name__, 3, '-').open()}\n\t{self.modStats.skipped[dir]}\n\n"))
        self.reportSkippedAsset(f"{FileTypes.Ini.value}s", self.iniStats.skipped, lambda file: self.logger.getBulletStr(f"{file}:\n\t{Heading(type(self.iniStats.skipped[file]).__name__, 3, '-').open()}\n\t{self.iniStats.skipped[file]}\n\n"))
        self.reportSkippedAsset(f"{FileTypes.Blend.value} files", self.blendStats.skippedByMods, lambda dir: self.warnSkippedIniResource(dir))
        self.reportSkippedAsset(f"newly added {FileTypes.Texture.value} files", self.texAddStats.skippedByMods, lambda dir: self.warnSkippedIniResource(dir))
        self.reportSkippedAsset(f"editted {FileTypes.Texture.value} files", self.texAddStats.skippedByMods, lambda dir: self.warnSkippedIniResource(dir))

    def reportSummary(self):
        skippedMods = len(self.modStats.skipped)
        fixedMods = len(self.modStats.fixed)
        foundMods = fixedMods + skippedMods

        fixedBlends = len(self.blendStats.fixed)
        skippedBlends = len(self.blendStats.skipped)
        removedRemapBlends = len(self.blendStats.removed)
        foundBlends = fixedBlends + skippedBlends

        fixedInis = len(self.iniStats.fixed)
        skippedInis = len(self.iniStats.skipped)
        undoedInis = len(self.iniStats.undoed)
        foundInis = fixedInis + skippedInis

        fixedAddTextures = len(self.texAddStats.fixed)
        skippedAddTextures = len(self.texAddStats.skipped)
        removedTextures = len(self.texAddStats.removed)
        foundAddTextures = fixedAddTextures + skippedAddTextures

        fixedEditTextures = len(self.texEditStats.fixed)
        skippedEditTextures = len(self.texEditStats.skipped)
        foundEditTextures = fixedEditTextures + skippedEditTextures

        self.logger.openHeading("Summary", sideLen = 10)
        self.logger.space()
        
        modFixMsg = ""
        blendFixMsg = ""
        iniFixMsg = ""
        removedRemappedMsg = ""
        undoedInisMsg = ""
        texAddFixMsg = ""
        texEditFixMsg = ""
        removedTexMsg = ""

        if (not self.undoOnly):
            modFixMsg = f"Out of {foundMods} found mods, fixed {fixedMods} mods and skipped {skippedMods} mods"
            iniFixMsg = f"Out of the {foundInis} {FileTypes.Ini.value}s within the found mods, fixed {fixedInis} {FileTypes.Ini.value}s and skipped {skippedInis} {FileTypes.Ini.value}s"
            blendFixMsg = f"Out of the {foundBlends} {FileTypes.Blend.value} files within the found mods, fixed {fixedBlends} {FileTypes.Blend.value} files and skipped {skippedBlends} {FileTypes.Blend.value} files"
            texAddFixMsg = f"Out of the {foundAddTextures} {FileTypes.Texture.value} files that were attempted to be created in the found mods, created {fixedAddTextures} {FileTypes.Texture.value} files and skipped {skippedAddTextures} {FileTypes.Texture.value} files"
            texEditFixMsg = f"Out of the {foundEditTextures} {FileTypes.Texture.value} files within the found mods, editted {fixedEditTextures} {FileTypes.Texture.value} files and skipped {skippedEditTextures} {FileTypes.Texture.value} files"
        else:
            modFixMsg = f"Out of {foundMods} found mods, remove fix from {fixedMods} mods and skipped {skippedMods} mods"

        if (not self.fixOnly and undoedInis > 0):
            undoedInisMsg = f"Removed fix from up to {undoedInis} {FileTypes.Ini.value}s"

            if (self.undoOnly):
                undoedInisMsg += f" and skipped {skippedInis} {FileTypes.Ini.value}s"

        if (not self.fixOnly and removedRemapBlends > 0):
            removedRemappedMsg = f"Removed {removedRemapBlends} old {FileTypes.RemapBlend.value} files"

        if (not self.fixOnly and removedTextures > 0):
            removedTexMsg = f"Removed {removedTextures} old {FileTypes.RemapTexture.value} files"


        self.logger.bulletPoint(modFixMsg)
        if (iniFixMsg):
            self.logger.bulletPoint(iniFixMsg)

        if (blendFixMsg):
            self.logger.bulletPoint(blendFixMsg)

        if (texAddFixMsg):
            self.logger.bulletPoint(texAddFixMsg)

        if (texEditFixMsg):
            self.logger.bulletPoint(texEditFixMsg)

        if (undoedInisMsg):
            self.logger.bulletPoint(undoedInisMsg)

        if (removedRemappedMsg):
            self.logger.bulletPoint(removedRemappedMsg)

        if (removedTexMsg):
            self.logger.bulletPoint(removedTexMsg)

        self.logger.space()
        self.logger.closeHeading()

    def createLog(self):
        """
        Creates a log text file that contains all the text printed on the command line
        """

        if (self._log is None):
            return

        self.logger.includePrefix = False
        self.logger.space()

        self.logger.log(f"Creating log file, {FileTypes.Log.value}")

        self.logger.includePrefix = True

        with open(self._log, "w", encoding = FileEncodings.UTF8.value) as f:
            f.write(self.logger.loggedTxt)

    def createMod(self, path: Optional[str] = None, files: Optional[List[str]] = None) -> Mod:
        """
        Creates a mod

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`

        Parameters
        ----------
        path: Optional[:class:`str`]
            The absolute path to the mod folder. :raw-html:`<br />` :raw-html:`<br />`
            
            If this argument is set to ``None``, then will use the current directory of where this module is loaded

        files: Optional[List[:class:`str`]]
            The direct children files to the mod folder (does not include files located in a folder within the mod folder). :raw-html:`<br />` :raw-html:`<br />`

            If this parameter is set to ``None``, then the module will search the folders for you

        Returns
        -------
        :class:`Mod`
            The mod that has been created
        """

        path = FileService.getPath(path)
        mod = Mod(path = path, files = files, logger = self.logger, types = self.types, defaultType = self.defaultType, version = self.version, remappedTypes = self.remappedTypes)
        return mod

    def _fix(self):
        """
        The overall logic for fixing a bunch of mods

        For finding out which folders may contain mods, this function:
            #. recursively searches all folders from where the :attr:`RemapService.path` is located
            #. for every .ini file in a valid mod and every Blend.buf file encountered that is encountered, recursively search all the folders from where the .ini file or Blend.buf file is located

        .. tip:: 
            For more info about how we define a 'mod', go to :class:`Mod`
        """

        if (self.__errorsBeforeFix is not None):
            raise self.__errorsBeforeFix

        if (self.fixOnly and self.undoOnly):
            raise ConflictingOptions([CommandOpts.FixOnly.value, CommandOpts.Revert.value])

        parentFolder = os.path.dirname(self._path)
        self._loggerBasePrefix = os.path.basename(self._path)
        self.logger.prefix = os.path.basename(FilePathConsts.DefaultPath)

        visitedDirs = set()
        visitingDirs = set()
        dirs = deque()
        dirs.append(self._path)
        visitingDirs.add(self._path)
    
        while (dirs):
            path = dirs.popleft()
            fixedMod = False

            # skip if the directory has already been visited
            if (path in visitedDirs):
                visitingDirs.remove(path)
                visitedDirs.add(path)
                continue 
            
            self.logger.split()

            # get the relative path to where the program runs
            self.logger.prefix = FileService.getRelPath(path, parentFolder)

            # try to make the mod, skip if cannot be made
            try:
                mod = self.createMod(path = path)
            except Exception as e:
                visitingDirs.remove(path)
                visitedDirs.add(path)
                continue
            
            # fix the mod
            try:
                fixedMod = self.fixMod(mod)
            except Exception as e:
                self.logger.handleException(e)
                if (mod.inis):
                    self.modStats.addSkipped(path, e, modFolder = path)

            # get all the folders that could potentially be other mods
            modFiles, modDirs = FileService.getFilesAndDirs(path = path, recursive = True)

            if (mod.inis):
                for iniPath in mod.inis:
                    ini = mod.inis[iniPath]
                    for _, blendModel in ini.remapBlendModels.items():
                        resourceModDirs = []
                        for partInd in blendModel.origFullPaths:
                            resourceModDirs += list(map(lambda origBlendPath: os.path.dirname(origBlendPath), blendModel.origFullPaths[partInd]))

                        modDirs += resourceModDirs
            
            # add in all the folders that need to be visited
            for dir in modDirs:
                if (dir in visitedDirs):
                    continue

                if (dir not in visitingDirs):
                    dirs.append(dir)
                visitingDirs.add(dir)

            # increment the count of mods found
            if (fixedMod):
                self.modStats.addFixed(path)

            visitingDirs.remove(path)
            visitedDirs.add(path)

        self.logger.split()
        self.logger.prefix = self._loggerBasePrefix
        self.reportSkippedMods()
        self.logger.space()
        self.reportSummary()


    def fix(self):
        """
        Fixes a bunch of mods

        see :meth:`_fix` for more info
        """
        
        try:
            self._fix()
        except Exception as e:
            if (self.handleExceptions):
                self.logger.handleException(e)
            else:
                self.createLog()
                raise e from e
        else:
            noErrors = bool(not self.modStats.skipped and not self.blendStats.skippedByMods)

            if (noErrors):
                self.logger.space()
                self.logger.log("ENJOY")

            self.logger.split()

            if (noErrors):
                self.addTips()

        self.createLog()


def remapMain():

    command = CommandBuilder()
    command.addEpilog(ModTypes.getHelpStr())

    args = command.parse()
    readAllInis = args.all
    defaultType = args.defaultType

    remapService = RemapService(path = args.src, keepBackups = not args.deleteBackup, fixOnly = args.fixOnly, 
                                undoOnly = args.undo, readAllInis = readAllInis, types = args.types, defaultType = defaultType,
                                log = args.log, verbose = True, handleExceptions = True, remappedTypes = args.remappedTypes,
                                version = args.version)
    remapService.fix()
    remapService.logger.waitExit()


# Main Driver Code
if __name__ == "__main__":
    remapMain()

########### END OF AUTO-GENERATED SCRIPT ###########